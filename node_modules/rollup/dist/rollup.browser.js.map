{"version":3,"file":"rollup.browser.js","sources":["../node_modules/gobble-browserify/node_modules/browserify/node_modules/process/browser.js","../node_modules/gobble-browserify/node_modules/browserify/node_modules/buffer/node_modules/is-array/index.js","../node_modules/gobble-browserify/node_modules/browserify/node_modules/buffer/node_modules/ieee754/index.js","../node_modules/gobble-browserify/node_modules/browserify/node_modules/buffer/node_modules/base64-js/lib/b64.js","../node_modules/gobble-browserify/node_modules/browserify/node_modules/buffer/index.js","../node_modules/acorn/dist/acorn.js","../.gobble-build/03-rollup/1/rollup.browser.js","../node_modules/gobble-browserify/node_modules/browserify/node_modules/browser-pack/_prelude.js"],"sourcesContent":["// shim for using process in browser\n\nvar process = module.exports = {};\nvar queue = [];\nvar draining = false;\nvar currentQueue;\nvar queueIndex = -1;\n\nfunction cleanUpNextTick() {\n    draining = false;\n    if (currentQueue.length) {\n        queue = currentQueue.concat(queue);\n    } else {\n        queueIndex = -1;\n    }\n    if (queue.length) {\n        drainQueue();\n    }\n}\n\nfunction drainQueue() {\n    if (draining) {\n        return;\n    }\n    var timeout = setTimeout(cleanUpNextTick);\n    draining = true;\n\n    var len = queue.length;\n    while(len) {\n        currentQueue = queue;\n        queue = [];\n        while (++queueIndex < len) {\n            currentQueue[queueIndex].run();\n        }\n        queueIndex = -1;\n        len = queue.length;\n    }\n    currentQueue = null;\n    draining = false;\n    clearTimeout(timeout);\n}\n\nprocess.nextTick = function (fun) {\n    var args = new Array(arguments.length - 1);\n    if (arguments.length > 1) {\n        for (var i = 1; i < arguments.length; i++) {\n            args[i - 1] = arguments[i];\n        }\n    }\n    queue.push(new Item(fun, args));\n    if (queue.length === 1 && !draining) {\n        setTimeout(drainQueue, 0);\n    }\n};\n\n// v8 likes predictible objects\nfunction Item(fun, array) {\n    this.fun = fun;\n    this.array = array;\n}\nItem.prototype.run = function () {\n    this.fun.apply(null, this.array);\n};\nprocess.title = 'browser';\nprocess.browser = true;\nprocess.env = {};\nprocess.argv = [];\nprocess.version = ''; // empty string to avoid regexp issues\nprocess.versions = {};\n\nfunction noop() {}\n\nprocess.on = noop;\nprocess.addListener = noop;\nprocess.once = noop;\nprocess.off = noop;\nprocess.removeListener = noop;\nprocess.removeAllListeners = noop;\nprocess.emit = noop;\n\nprocess.binding = function (name) {\n    throw new Error('process.binding is not supported');\n};\n\n// TODO(shtylman)\nprocess.cwd = function () { return '/' };\nprocess.chdir = function (dir) {\n    throw new Error('process.chdir is not supported');\n};\nprocess.umask = function() { return 0; };\n","\n/**\n * isArray\n */\n\nvar isArray = Array.isArray;\n\n/**\n * toString\n */\n\nvar str = Object.prototype.toString;\n\n/**\n * Whether or not the given `val`\n * is an array.\n *\n * example:\n *\n *        isArray([]);\n *        // > true\n *        isArray(arguments);\n *        // > false\n *        isArray('');\n *        // > false\n *\n * @param {mixed} val\n * @return {bool}\n */\n\nmodule.exports = isArray || function (val) {\n  return !! val && '[object Array]' == str.call(val);\n};\n","exports.read = function (buffer, offset, isLE, mLen, nBytes) {\n  var e, m\n  var eLen = nBytes * 8 - mLen - 1\n  var eMax = (1 << eLen) - 1\n  var eBias = eMax >> 1\n  var nBits = -7\n  var i = isLE ? (nBytes - 1) : 0\n  var d = isLE ? -1 : 1\n  var s = buffer[offset + i]\n\n  i += d\n\n  e = s & ((1 << (-nBits)) - 1)\n  s >>= (-nBits)\n  nBits += eLen\n  for (; nBits > 0; e = e * 256 + buffer[offset + i], i += d, nBits -= 8) {}\n\n  m = e & ((1 << (-nBits)) - 1)\n  e >>= (-nBits)\n  nBits += mLen\n  for (; nBits > 0; m = m * 256 + buffer[offset + i], i += d, nBits -= 8) {}\n\n  if (e === 0) {\n    e = 1 - eBias\n  } else if (e === eMax) {\n    return m ? NaN : ((s ? -1 : 1) * Infinity)\n  } else {\n    m = m + Math.pow(2, mLen)\n    e = e - eBias\n  }\n  return (s ? -1 : 1) * m * Math.pow(2, e - mLen)\n}\n\nexports.write = function (buffer, value, offset, isLE, mLen, nBytes) {\n  var e, m, c\n  var eLen = nBytes * 8 - mLen - 1\n  var eMax = (1 << eLen) - 1\n  var eBias = eMax >> 1\n  var rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0)\n  var i = isLE ? 0 : (nBytes - 1)\n  var d = isLE ? 1 : -1\n  var s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0\n\n  value = Math.abs(value)\n\n  if (isNaN(value) || value === Infinity) {\n    m = isNaN(value) ? 1 : 0\n    e = eMax\n  } else {\n    e = Math.floor(Math.log(value) / Math.LN2)\n    if (value * (c = Math.pow(2, -e)) < 1) {\n      e--\n      c *= 2\n    }\n    if (e + eBias >= 1) {\n      value += rt / c\n    } else {\n      value += rt * Math.pow(2, 1 - eBias)\n    }\n    if (value * c >= 2) {\n      e++\n      c /= 2\n    }\n\n    if (e + eBias >= eMax) {\n      m = 0\n      e = eMax\n    } else if (e + eBias >= 1) {\n      m = (value * c - 1) * Math.pow(2, mLen)\n      e = e + eBias\n    } else {\n      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen)\n      e = 0\n    }\n  }\n\n  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}\n\n  e = (e << mLen) | m\n  eLen += mLen\n  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}\n\n  buffer[offset + i - d] |= s * 128\n}\n","var lookup = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';\n\n;(function (exports) {\n\t'use strict';\n\n  var Arr = (typeof Uint8Array !== 'undefined')\n    ? Uint8Array\n    : Array\n\n\tvar PLUS   = '+'.charCodeAt(0)\n\tvar SLASH  = '/'.charCodeAt(0)\n\tvar NUMBER = '0'.charCodeAt(0)\n\tvar LOWER  = 'a'.charCodeAt(0)\n\tvar UPPER  = 'A'.charCodeAt(0)\n\tvar PLUS_URL_SAFE = '-'.charCodeAt(0)\n\tvar SLASH_URL_SAFE = '_'.charCodeAt(0)\n\n\tfunction decode (elt) {\n\t\tvar code = elt.charCodeAt(0)\n\t\tif (code === PLUS ||\n\t\t    code === PLUS_URL_SAFE)\n\t\t\treturn 62 // '+'\n\t\tif (code === SLASH ||\n\t\t    code === SLASH_URL_SAFE)\n\t\t\treturn 63 // '/'\n\t\tif (code < NUMBER)\n\t\t\treturn -1 //no match\n\t\tif (code < NUMBER + 10)\n\t\t\treturn code - NUMBER + 26 + 26\n\t\tif (code < UPPER + 26)\n\t\t\treturn code - UPPER\n\t\tif (code < LOWER + 26)\n\t\t\treturn code - LOWER + 26\n\t}\n\n\tfunction b64ToByteArray (b64) {\n\t\tvar i, j, l, tmp, placeHolders, arr\n\n\t\tif (b64.length % 4 > 0) {\n\t\t\tthrow new Error('Invalid string. Length must be a multiple of 4')\n\t\t}\n\n\t\t// the number of equal signs (place holders)\n\t\t// if there are two placeholders, than the two characters before it\n\t\t// represent one byte\n\t\t// if there is only one, then the three characters before it represent 2 bytes\n\t\t// this is just a cheap hack to not do indexOf twice\n\t\tvar len = b64.length\n\t\tplaceHolders = '=' === b64.charAt(len - 2) ? 2 : '=' === b64.charAt(len - 1) ? 1 : 0\n\n\t\t// base64 is 4/3 + up to two characters of the original data\n\t\tarr = new Arr(b64.length * 3 / 4 - placeHolders)\n\n\t\t// if there are placeholders, only get up to the last complete 4 chars\n\t\tl = placeHolders > 0 ? b64.length - 4 : b64.length\n\n\t\tvar L = 0\n\n\t\tfunction push (v) {\n\t\t\tarr[L++] = v\n\t\t}\n\n\t\tfor (i = 0, j = 0; i < l; i += 4, j += 3) {\n\t\t\ttmp = (decode(b64.charAt(i)) << 18) | (decode(b64.charAt(i + 1)) << 12) | (decode(b64.charAt(i + 2)) << 6) | decode(b64.charAt(i + 3))\n\t\t\tpush((tmp & 0xFF0000) >> 16)\n\t\t\tpush((tmp & 0xFF00) >> 8)\n\t\t\tpush(tmp & 0xFF)\n\t\t}\n\n\t\tif (placeHolders === 2) {\n\t\t\ttmp = (decode(b64.charAt(i)) << 2) | (decode(b64.charAt(i + 1)) >> 4)\n\t\t\tpush(tmp & 0xFF)\n\t\t} else if (placeHolders === 1) {\n\t\t\ttmp = (decode(b64.charAt(i)) << 10) | (decode(b64.charAt(i + 1)) << 4) | (decode(b64.charAt(i + 2)) >> 2)\n\t\t\tpush((tmp >> 8) & 0xFF)\n\t\t\tpush(tmp & 0xFF)\n\t\t}\n\n\t\treturn arr\n\t}\n\n\tfunction uint8ToBase64 (uint8) {\n\t\tvar i,\n\t\t\textraBytes = uint8.length % 3, // if we have 1 byte left, pad 2 bytes\n\t\t\toutput = \"\",\n\t\t\ttemp, length\n\n\t\tfunction encode (num) {\n\t\t\treturn lookup.charAt(num)\n\t\t}\n\n\t\tfunction tripletToBase64 (num) {\n\t\t\treturn encode(num >> 18 & 0x3F) + encode(num >> 12 & 0x3F) + encode(num >> 6 & 0x3F) + encode(num & 0x3F)\n\t\t}\n\n\t\t// go through the array every three bytes, we'll deal with trailing stuff later\n\t\tfor (i = 0, length = uint8.length - extraBytes; i < length; i += 3) {\n\t\t\ttemp = (uint8[i] << 16) + (uint8[i + 1] << 8) + (uint8[i + 2])\n\t\t\toutput += tripletToBase64(temp)\n\t\t}\n\n\t\t// pad the end with zeros, but make sure to not forget the extra bytes\n\t\tswitch (extraBytes) {\n\t\t\tcase 1:\n\t\t\t\ttemp = uint8[uint8.length - 1]\n\t\t\t\toutput += encode(temp >> 2)\n\t\t\t\toutput += encode((temp << 4) & 0x3F)\n\t\t\t\toutput += '=='\n\t\t\t\tbreak\n\t\t\tcase 2:\n\t\t\t\ttemp = (uint8[uint8.length - 2] << 8) + (uint8[uint8.length - 1])\n\t\t\t\toutput += encode(temp >> 10)\n\t\t\t\toutput += encode((temp >> 4) & 0x3F)\n\t\t\t\toutput += encode((temp << 2) & 0x3F)\n\t\t\t\toutput += '='\n\t\t\t\tbreak\n\t\t}\n\n\t\treturn output\n\t}\n\n\texports.toByteArray = b64ToByteArray\n\texports.fromByteArray = uint8ToBase64\n}(typeof exports === 'undefined' ? (this.base64js = {}) : exports))\n","/*!\n * The buffer module from node.js, for the browser.\n *\n * @author   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>\n * @license  MIT\n */\n\nvar base64 = require('base64-js')\nvar ieee754 = require('ieee754')\nvar isArray = require('is-array')\n\nexports.Buffer = Buffer\nexports.SlowBuffer = SlowBuffer\nexports.INSPECT_MAX_BYTES = 50\nBuffer.poolSize = 8192 // not used by this implementation\n\nvar rootParent = {}\n\n/**\n * If `Buffer.TYPED_ARRAY_SUPPORT`:\n *   === true    Use Uint8Array implementation (fastest)\n *   === false   Use Object implementation (most compatible, even IE6)\n *\n * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,\n * Opera 11.6+, iOS 4.2+.\n *\n * Due to various browser bugs, sometimes the Object implementation will be used even\n * when the browser supports typed arrays.\n *\n * Note:\n *\n *   - Firefox 4-29 lacks support for adding new properties to `Uint8Array` instances,\n *     See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438.\n *\n *   - Safari 5-7 lacks support for changing the `Object.prototype.constructor` property\n *     on objects.\n *\n *   - Chrome 9-10 is missing the `TypedArray.prototype.subarray` function.\n *\n *   - IE10 has a broken `TypedArray.prototype.subarray` function which returns arrays of\n *     incorrect length in some situations.\n\n * We detect these buggy browsers and set `Buffer.TYPED_ARRAY_SUPPORT` to `false` so they\n * get the Object implementation, which is slower but behaves correctly.\n */\nBuffer.TYPED_ARRAY_SUPPORT = (function () {\n  function Bar () {}\n  try {\n    var arr = new Uint8Array(1)\n    arr.foo = function () { return 42 }\n    arr.constructor = Bar\n    return arr.foo() === 42 && // typed array instances can be augmented\n        arr.constructor === Bar && // constructor can be set\n        typeof arr.subarray === 'function' && // chrome 9-10 lack `subarray`\n        arr.subarray(1, 1).byteLength === 0 // ie10 has broken `subarray`\n  } catch (e) {\n    return false\n  }\n})()\n\nfunction kMaxLength () {\n  return Buffer.TYPED_ARRAY_SUPPORT\n    ? 0x7fffffff\n    : 0x3fffffff\n}\n\n/**\n * Class: Buffer\n * =============\n *\n * The Buffer constructor returns instances of `Uint8Array` that are augmented\n * with function properties for all the node `Buffer` API functions. We use\n * `Uint8Array` so that square bracket notation works as expected -- it returns\n * a single octet.\n *\n * By augmenting the instances, we can avoid modifying the `Uint8Array`\n * prototype.\n */\nfunction Buffer (arg) {\n  if (!(this instanceof Buffer)) {\n    // Avoid going through an ArgumentsAdaptorTrampoline in the common case.\n    if (arguments.length > 1) return new Buffer(arg, arguments[1])\n    return new Buffer(arg)\n  }\n\n  this.length = 0\n  this.parent = undefined\n\n  // Common case.\n  if (typeof arg === 'number') {\n    return fromNumber(this, arg)\n  }\n\n  // Slightly less common case.\n  if (typeof arg === 'string') {\n    return fromString(this, arg, arguments.length > 1 ? arguments[1] : 'utf8')\n  }\n\n  // Unusual.\n  return fromObject(this, arg)\n}\n\nfunction fromNumber (that, length) {\n  that = allocate(that, length < 0 ? 0 : checked(length) | 0)\n  if (!Buffer.TYPED_ARRAY_SUPPORT) {\n    for (var i = 0; i < length; i++) {\n      that[i] = 0\n    }\n  }\n  return that\n}\n\nfunction fromString (that, string, encoding) {\n  if (typeof encoding !== 'string' || encoding === '') encoding = 'utf8'\n\n  // Assumption: byteLength() return value is always < kMaxLength.\n  var length = byteLength(string, encoding) | 0\n  that = allocate(that, length)\n\n  that.write(string, encoding)\n  return that\n}\n\nfunction fromObject (that, object) {\n  if (Buffer.isBuffer(object)) return fromBuffer(that, object)\n\n  if (isArray(object)) return fromArray(that, object)\n\n  if (object == null) {\n    throw new TypeError('must start with number, buffer, array or string')\n  }\n\n  if (typeof ArrayBuffer !== 'undefined') {\n    if (object.buffer instanceof ArrayBuffer) {\n      return fromTypedArray(that, object)\n    }\n    if (object instanceof ArrayBuffer) {\n      return fromArrayBuffer(that, object)\n    }\n  }\n\n  if (object.length) return fromArrayLike(that, object)\n\n  return fromJsonObject(that, object)\n}\n\nfunction fromBuffer (that, buffer) {\n  var length = checked(buffer.length) | 0\n  that = allocate(that, length)\n  buffer.copy(that, 0, 0, length)\n  return that\n}\n\nfunction fromArray (that, array) {\n  var length = checked(array.length) | 0\n  that = allocate(that, length)\n  for (var i = 0; i < length; i += 1) {\n    that[i] = array[i] & 255\n  }\n  return that\n}\n\n// Duplicate of fromArray() to keep fromArray() monomorphic.\nfunction fromTypedArray (that, array) {\n  var length = checked(array.length) | 0\n  that = allocate(that, length)\n  // Truncating the elements is probably not what people expect from typed\n  // arrays with BYTES_PER_ELEMENT > 1 but it's compatible with the behavior\n  // of the old Buffer constructor.\n  for (var i = 0; i < length; i += 1) {\n    that[i] = array[i] & 255\n  }\n  return that\n}\n\nfunction fromArrayBuffer (that, array) {\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    // Return an augmented `Uint8Array` instance, for best performance\n    array.byteLength\n    that = Buffer._augment(new Uint8Array(array))\n  } else {\n    // Fallback: Return an object instance of the Buffer class\n    that = fromTypedArray(that, new Uint8Array(array))\n  }\n  return that\n}\n\nfunction fromArrayLike (that, array) {\n  var length = checked(array.length) | 0\n  that = allocate(that, length)\n  for (var i = 0; i < length; i += 1) {\n    that[i] = array[i] & 255\n  }\n  return that\n}\n\n// Deserialize { type: 'Buffer', data: [1,2,3,...] } into a Buffer object.\n// Returns a zero-length buffer for inputs that don't conform to the spec.\nfunction fromJsonObject (that, object) {\n  var array\n  var length = 0\n\n  if (object.type === 'Buffer' && isArray(object.data)) {\n    array = object.data\n    length = checked(array.length) | 0\n  }\n  that = allocate(that, length)\n\n  for (var i = 0; i < length; i += 1) {\n    that[i] = array[i] & 255\n  }\n  return that\n}\n\nfunction allocate (that, length) {\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    // Return an augmented `Uint8Array` instance, for best performance\n    that = Buffer._augment(new Uint8Array(length))\n  } else {\n    // Fallback: Return an object instance of the Buffer class\n    that.length = length\n    that._isBuffer = true\n  }\n\n  var fromPool = length !== 0 && length <= Buffer.poolSize >>> 1\n  if (fromPool) that.parent = rootParent\n\n  return that\n}\n\nfunction checked (length) {\n  // Note: cannot use `length < kMaxLength` here because that fails when\n  // length is NaN (which is otherwise coerced to zero.)\n  if (length >= kMaxLength()) {\n    throw new RangeError('Attempt to allocate Buffer larger than maximum ' +\n                         'size: 0x' + kMaxLength().toString(16) + ' bytes')\n  }\n  return length | 0\n}\n\nfunction SlowBuffer (subject, encoding) {\n  if (!(this instanceof SlowBuffer)) return new SlowBuffer(subject, encoding)\n\n  var buf = new Buffer(subject, encoding)\n  delete buf.parent\n  return buf\n}\n\nBuffer.isBuffer = function isBuffer (b) {\n  return !!(b != null && b._isBuffer)\n}\n\nBuffer.compare = function compare (a, b) {\n  if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {\n    throw new TypeError('Arguments must be Buffers')\n  }\n\n  if (a === b) return 0\n\n  var x = a.length\n  var y = b.length\n\n  var i = 0\n  var len = Math.min(x, y)\n  while (i < len) {\n    if (a[i] !== b[i]) break\n\n    ++i\n  }\n\n  if (i !== len) {\n    x = a[i]\n    y = b[i]\n  }\n\n  if (x < y) return -1\n  if (y < x) return 1\n  return 0\n}\n\nBuffer.isEncoding = function isEncoding (encoding) {\n  switch (String(encoding).toLowerCase()) {\n    case 'hex':\n    case 'utf8':\n    case 'utf-8':\n    case 'ascii':\n    case 'binary':\n    case 'base64':\n    case 'raw':\n    case 'ucs2':\n    case 'ucs-2':\n    case 'utf16le':\n    case 'utf-16le':\n      return true\n    default:\n      return false\n  }\n}\n\nBuffer.concat = function concat (list, length) {\n  if (!isArray(list)) throw new TypeError('list argument must be an Array of Buffers.')\n\n  if (list.length === 0) {\n    return new Buffer(0)\n  }\n\n  var i\n  if (length === undefined) {\n    length = 0\n    for (i = 0; i < list.length; i++) {\n      length += list[i].length\n    }\n  }\n\n  var buf = new Buffer(length)\n  var pos = 0\n  for (i = 0; i < list.length; i++) {\n    var item = list[i]\n    item.copy(buf, pos)\n    pos += item.length\n  }\n  return buf\n}\n\nfunction byteLength (string, encoding) {\n  if (typeof string !== 'string') string = '' + string\n\n  var len = string.length\n  if (len === 0) return 0\n\n  // Use a for loop to avoid recursion\n  var loweredCase = false\n  for (;;) {\n    switch (encoding) {\n      case 'ascii':\n      case 'binary':\n      // Deprecated\n      case 'raw':\n      case 'raws':\n        return len\n      case 'utf8':\n      case 'utf-8':\n        return utf8ToBytes(string).length\n      case 'ucs2':\n      case 'ucs-2':\n      case 'utf16le':\n      case 'utf-16le':\n        return len * 2\n      case 'hex':\n        return len >>> 1\n      case 'base64':\n        return base64ToBytes(string).length\n      default:\n        if (loweredCase) return utf8ToBytes(string).length // assume utf8\n        encoding = ('' + encoding).toLowerCase()\n        loweredCase = true\n    }\n  }\n}\nBuffer.byteLength = byteLength\n\n// pre-set for values that may exist in the future\nBuffer.prototype.length = undefined\nBuffer.prototype.parent = undefined\n\nfunction slowToString (encoding, start, end) {\n  var loweredCase = false\n\n  start = start | 0\n  end = end === undefined || end === Infinity ? this.length : end | 0\n\n  if (!encoding) encoding = 'utf8'\n  if (start < 0) start = 0\n  if (end > this.length) end = this.length\n  if (end <= start) return ''\n\n  while (true) {\n    switch (encoding) {\n      case 'hex':\n        return hexSlice(this, start, end)\n\n      case 'utf8':\n      case 'utf-8':\n        return utf8Slice(this, start, end)\n\n      case 'ascii':\n        return asciiSlice(this, start, end)\n\n      case 'binary':\n        return binarySlice(this, start, end)\n\n      case 'base64':\n        return base64Slice(this, start, end)\n\n      case 'ucs2':\n      case 'ucs-2':\n      case 'utf16le':\n      case 'utf-16le':\n        return utf16leSlice(this, start, end)\n\n      default:\n        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)\n        encoding = (encoding + '').toLowerCase()\n        loweredCase = true\n    }\n  }\n}\n\nBuffer.prototype.toString = function toString () {\n  var length = this.length | 0\n  if (length === 0) return ''\n  if (arguments.length === 0) return utf8Slice(this, 0, length)\n  return slowToString.apply(this, arguments)\n}\n\nBuffer.prototype.equals = function equals (b) {\n  if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer')\n  if (this === b) return true\n  return Buffer.compare(this, b) === 0\n}\n\nBuffer.prototype.inspect = function inspect () {\n  var str = ''\n  var max = exports.INSPECT_MAX_BYTES\n  if (this.length > 0) {\n    str = this.toString('hex', 0, max).match(/.{2}/g).join(' ')\n    if (this.length > max) str += ' ... '\n  }\n  return '<Buffer ' + str + '>'\n}\n\nBuffer.prototype.compare = function compare (b) {\n  if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer')\n  if (this === b) return 0\n  return Buffer.compare(this, b)\n}\n\nBuffer.prototype.indexOf = function indexOf (val, byteOffset) {\n  if (byteOffset > 0x7fffffff) byteOffset = 0x7fffffff\n  else if (byteOffset < -0x80000000) byteOffset = -0x80000000\n  byteOffset >>= 0\n\n  if (this.length === 0) return -1\n  if (byteOffset >= this.length) return -1\n\n  // Negative offsets start from the end of the buffer\n  if (byteOffset < 0) byteOffset = Math.max(this.length + byteOffset, 0)\n\n  if (typeof val === 'string') {\n    if (val.length === 0) return -1 // special case: looking for empty string always fails\n    return String.prototype.indexOf.call(this, val, byteOffset)\n  }\n  if (Buffer.isBuffer(val)) {\n    return arrayIndexOf(this, val, byteOffset)\n  }\n  if (typeof val === 'number') {\n    if (Buffer.TYPED_ARRAY_SUPPORT && Uint8Array.prototype.indexOf === 'function') {\n      return Uint8Array.prototype.indexOf.call(this, val, byteOffset)\n    }\n    return arrayIndexOf(this, [ val ], byteOffset)\n  }\n\n  function arrayIndexOf (arr, val, byteOffset) {\n    var foundIndex = -1\n    for (var i = 0; byteOffset + i < arr.length; i++) {\n      if (arr[byteOffset + i] === val[foundIndex === -1 ? 0 : i - foundIndex]) {\n        if (foundIndex === -1) foundIndex = i\n        if (i - foundIndex + 1 === val.length) return byteOffset + foundIndex\n      } else {\n        foundIndex = -1\n      }\n    }\n    return -1\n  }\n\n  throw new TypeError('val must be string, number or Buffer')\n}\n\n// `get` is deprecated\nBuffer.prototype.get = function get (offset) {\n  console.log('.get() is deprecated. Access using array indexes instead.')\n  return this.readUInt8(offset)\n}\n\n// `set` is deprecated\nBuffer.prototype.set = function set (v, offset) {\n  console.log('.set() is deprecated. Access using array indexes instead.')\n  return this.writeUInt8(v, offset)\n}\n\nfunction hexWrite (buf, string, offset, length) {\n  offset = Number(offset) || 0\n  var remaining = buf.length - offset\n  if (!length) {\n    length = remaining\n  } else {\n    length = Number(length)\n    if (length > remaining) {\n      length = remaining\n    }\n  }\n\n  // must be an even number of digits\n  var strLen = string.length\n  if (strLen % 2 !== 0) throw new Error('Invalid hex string')\n\n  if (length > strLen / 2) {\n    length = strLen / 2\n  }\n  for (var i = 0; i < length; i++) {\n    var parsed = parseInt(string.substr(i * 2, 2), 16)\n    if (isNaN(parsed)) throw new Error('Invalid hex string')\n    buf[offset + i] = parsed\n  }\n  return i\n}\n\nfunction utf8Write (buf, string, offset, length) {\n  return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length)\n}\n\nfunction asciiWrite (buf, string, offset, length) {\n  return blitBuffer(asciiToBytes(string), buf, offset, length)\n}\n\nfunction binaryWrite (buf, string, offset, length) {\n  return asciiWrite(buf, string, offset, length)\n}\n\nfunction base64Write (buf, string, offset, length) {\n  return blitBuffer(base64ToBytes(string), buf, offset, length)\n}\n\nfunction ucs2Write (buf, string, offset, length) {\n  return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length)\n}\n\nBuffer.prototype.write = function write (string, offset, length, encoding) {\n  // Buffer#write(string)\n  if (offset === undefined) {\n    encoding = 'utf8'\n    length = this.length\n    offset = 0\n  // Buffer#write(string, encoding)\n  } else if (length === undefined && typeof offset === 'string') {\n    encoding = offset\n    length = this.length\n    offset = 0\n  // Buffer#write(string, offset[, length][, encoding])\n  } else if (isFinite(offset)) {\n    offset = offset | 0\n    if (isFinite(length)) {\n      length = length | 0\n      if (encoding === undefined) encoding = 'utf8'\n    } else {\n      encoding = length\n      length = undefined\n    }\n  // legacy write(string, encoding, offset, length) - remove in v0.13\n  } else {\n    var swap = encoding\n    encoding = offset\n    offset = length | 0\n    length = swap\n  }\n\n  var remaining = this.length - offset\n  if (length === undefined || length > remaining) length = remaining\n\n  if ((string.length > 0 && (length < 0 || offset < 0)) || offset > this.length) {\n    throw new RangeError('attempt to write outside buffer bounds')\n  }\n\n  if (!encoding) encoding = 'utf8'\n\n  var loweredCase = false\n  for (;;) {\n    switch (encoding) {\n      case 'hex':\n        return hexWrite(this, string, offset, length)\n\n      case 'utf8':\n      case 'utf-8':\n        return utf8Write(this, string, offset, length)\n\n      case 'ascii':\n        return asciiWrite(this, string, offset, length)\n\n      case 'binary':\n        return binaryWrite(this, string, offset, length)\n\n      case 'base64':\n        // Warning: maxLength not taken into account in base64Write\n        return base64Write(this, string, offset, length)\n\n      case 'ucs2':\n      case 'ucs-2':\n      case 'utf16le':\n      case 'utf-16le':\n        return ucs2Write(this, string, offset, length)\n\n      default:\n        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)\n        encoding = ('' + encoding).toLowerCase()\n        loweredCase = true\n    }\n  }\n}\n\nBuffer.prototype.toJSON = function toJSON () {\n  return {\n    type: 'Buffer',\n    data: Array.prototype.slice.call(this._arr || this, 0)\n  }\n}\n\nfunction base64Slice (buf, start, end) {\n  if (start === 0 && end === buf.length) {\n    return base64.fromByteArray(buf)\n  } else {\n    return base64.fromByteArray(buf.slice(start, end))\n  }\n}\n\nfunction utf8Slice (buf, start, end) {\n  end = Math.min(buf.length, end)\n  var res = []\n\n  var i = start\n  while (i < end) {\n    var firstByte = buf[i]\n    var codePoint = null\n    var bytesPerSequence = (firstByte > 0xEF) ? 4\n      : (firstByte > 0xDF) ? 3\n      : (firstByte > 0xBF) ? 2\n      : 1\n\n    if (i + bytesPerSequence <= end) {\n      var secondByte, thirdByte, fourthByte, tempCodePoint\n\n      switch (bytesPerSequence) {\n        case 1:\n          if (firstByte < 0x80) {\n            codePoint = firstByte\n          }\n          break\n        case 2:\n          secondByte = buf[i + 1]\n          if ((secondByte & 0xC0) === 0x80) {\n            tempCodePoint = (firstByte & 0x1F) << 0x6 | (secondByte & 0x3F)\n            if (tempCodePoint > 0x7F) {\n              codePoint = tempCodePoint\n            }\n          }\n          break\n        case 3:\n          secondByte = buf[i + 1]\n          thirdByte = buf[i + 2]\n          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {\n            tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | (thirdByte & 0x3F)\n            if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {\n              codePoint = tempCodePoint\n            }\n          }\n          break\n        case 4:\n          secondByte = buf[i + 1]\n          thirdByte = buf[i + 2]\n          fourthByte = buf[i + 3]\n          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {\n            tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | (fourthByte & 0x3F)\n            if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {\n              codePoint = tempCodePoint\n            }\n          }\n      }\n    }\n\n    if (codePoint === null) {\n      // we did not generate a valid codePoint so insert a\n      // replacement char (U+FFFD) and advance only 1 byte\n      codePoint = 0xFFFD\n      bytesPerSequence = 1\n    } else if (codePoint > 0xFFFF) {\n      // encode to utf16 (surrogate pair dance)\n      codePoint -= 0x10000\n      res.push(codePoint >>> 10 & 0x3FF | 0xD800)\n      codePoint = 0xDC00 | codePoint & 0x3FF\n    }\n\n    res.push(codePoint)\n    i += bytesPerSequence\n  }\n\n  return decodeCodePointsArray(res)\n}\n\n// Based on http://stackoverflow.com/a/22747272/680742, the browser with\n// the lowest limit is Chrome, with 0x10000 args.\n// We go 1 magnitude less, for safety\nvar MAX_ARGUMENTS_LENGTH = 0x1000\n\nfunction decodeCodePointsArray (codePoints) {\n  var len = codePoints.length\n  if (len <= MAX_ARGUMENTS_LENGTH) {\n    return String.fromCharCode.apply(String, codePoints) // avoid extra slice()\n  }\n\n  // Decode in chunks to avoid \"call stack size exceeded\".\n  var res = ''\n  var i = 0\n  while (i < len) {\n    res += String.fromCharCode.apply(\n      String,\n      codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)\n    )\n  }\n  return res\n}\n\nfunction asciiSlice (buf, start, end) {\n  var ret = ''\n  end = Math.min(buf.length, end)\n\n  for (var i = start; i < end; i++) {\n    ret += String.fromCharCode(buf[i] & 0x7F)\n  }\n  return ret\n}\n\nfunction binarySlice (buf, start, end) {\n  var ret = ''\n  end = Math.min(buf.length, end)\n\n  for (var i = start; i < end; i++) {\n    ret += String.fromCharCode(buf[i])\n  }\n  return ret\n}\n\nfunction hexSlice (buf, start, end) {\n  var len = buf.length\n\n  if (!start || start < 0) start = 0\n  if (!end || end < 0 || end > len) end = len\n\n  var out = ''\n  for (var i = start; i < end; i++) {\n    out += toHex(buf[i])\n  }\n  return out\n}\n\nfunction utf16leSlice (buf, start, end) {\n  var bytes = buf.slice(start, end)\n  var res = ''\n  for (var i = 0; i < bytes.length; i += 2) {\n    res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256)\n  }\n  return res\n}\n\nBuffer.prototype.slice = function slice (start, end) {\n  var len = this.length\n  start = ~~start\n  end = end === undefined ? len : ~~end\n\n  if (start < 0) {\n    start += len\n    if (start < 0) start = 0\n  } else if (start > len) {\n    start = len\n  }\n\n  if (end < 0) {\n    end += len\n    if (end < 0) end = 0\n  } else if (end > len) {\n    end = len\n  }\n\n  if (end < start) end = start\n\n  var newBuf\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    newBuf = Buffer._augment(this.subarray(start, end))\n  } else {\n    var sliceLen = end - start\n    newBuf = new Buffer(sliceLen, undefined)\n    for (var i = 0; i < sliceLen; i++) {\n      newBuf[i] = this[i + start]\n    }\n  }\n\n  if (newBuf.length) newBuf.parent = this.parent || this\n\n  return newBuf\n}\n\n/*\n * Need to make sure that buffer isn't trying to write out of bounds.\n */\nfunction checkOffset (offset, ext, length) {\n  if ((offset % 1) !== 0 || offset < 0) throw new RangeError('offset is not uint')\n  if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length')\n}\n\nBuffer.prototype.readUIntLE = function readUIntLE (offset, byteLength, noAssert) {\n  offset = offset | 0\n  byteLength = byteLength | 0\n  if (!noAssert) checkOffset(offset, byteLength, this.length)\n\n  var val = this[offset]\n  var mul = 1\n  var i = 0\n  while (++i < byteLength && (mul *= 0x100)) {\n    val += this[offset + i] * mul\n  }\n\n  return val\n}\n\nBuffer.prototype.readUIntBE = function readUIntBE (offset, byteLength, noAssert) {\n  offset = offset | 0\n  byteLength = byteLength | 0\n  if (!noAssert) {\n    checkOffset(offset, byteLength, this.length)\n  }\n\n  var val = this[offset + --byteLength]\n  var mul = 1\n  while (byteLength > 0 && (mul *= 0x100)) {\n    val += this[offset + --byteLength] * mul\n  }\n\n  return val\n}\n\nBuffer.prototype.readUInt8 = function readUInt8 (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 1, this.length)\n  return this[offset]\n}\n\nBuffer.prototype.readUInt16LE = function readUInt16LE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  return this[offset] | (this[offset + 1] << 8)\n}\n\nBuffer.prototype.readUInt16BE = function readUInt16BE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  return (this[offset] << 8) | this[offset + 1]\n}\n\nBuffer.prototype.readUInt32LE = function readUInt32LE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return ((this[offset]) |\n      (this[offset + 1] << 8) |\n      (this[offset + 2] << 16)) +\n      (this[offset + 3] * 0x1000000)\n}\n\nBuffer.prototype.readUInt32BE = function readUInt32BE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return (this[offset] * 0x1000000) +\n    ((this[offset + 1] << 16) |\n    (this[offset + 2] << 8) |\n    this[offset + 3])\n}\n\nBuffer.prototype.readIntLE = function readIntLE (offset, byteLength, noAssert) {\n  offset = offset | 0\n  byteLength = byteLength | 0\n  if (!noAssert) checkOffset(offset, byteLength, this.length)\n\n  var val = this[offset]\n  var mul = 1\n  var i = 0\n  while (++i < byteLength && (mul *= 0x100)) {\n    val += this[offset + i] * mul\n  }\n  mul *= 0x80\n\n  if (val >= mul) val -= Math.pow(2, 8 * byteLength)\n\n  return val\n}\n\nBuffer.prototype.readIntBE = function readIntBE (offset, byteLength, noAssert) {\n  offset = offset | 0\n  byteLength = byteLength | 0\n  if (!noAssert) checkOffset(offset, byteLength, this.length)\n\n  var i = byteLength\n  var mul = 1\n  var val = this[offset + --i]\n  while (i > 0 && (mul *= 0x100)) {\n    val += this[offset + --i] * mul\n  }\n  mul *= 0x80\n\n  if (val >= mul) val -= Math.pow(2, 8 * byteLength)\n\n  return val\n}\n\nBuffer.prototype.readInt8 = function readInt8 (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 1, this.length)\n  if (!(this[offset] & 0x80)) return (this[offset])\n  return ((0xff - this[offset] + 1) * -1)\n}\n\nBuffer.prototype.readInt16LE = function readInt16LE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  var val = this[offset] | (this[offset + 1] << 8)\n  return (val & 0x8000) ? val | 0xFFFF0000 : val\n}\n\nBuffer.prototype.readInt16BE = function readInt16BE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  var val = this[offset + 1] | (this[offset] << 8)\n  return (val & 0x8000) ? val | 0xFFFF0000 : val\n}\n\nBuffer.prototype.readInt32LE = function readInt32LE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return (this[offset]) |\n    (this[offset + 1] << 8) |\n    (this[offset + 2] << 16) |\n    (this[offset + 3] << 24)\n}\n\nBuffer.prototype.readInt32BE = function readInt32BE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return (this[offset] << 24) |\n    (this[offset + 1] << 16) |\n    (this[offset + 2] << 8) |\n    (this[offset + 3])\n}\n\nBuffer.prototype.readFloatLE = function readFloatLE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length)\n  return ieee754.read(this, offset, true, 23, 4)\n}\n\nBuffer.prototype.readFloatBE = function readFloatBE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length)\n  return ieee754.read(this, offset, false, 23, 4)\n}\n\nBuffer.prototype.readDoubleLE = function readDoubleLE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 8, this.length)\n  return ieee754.read(this, offset, true, 52, 8)\n}\n\nBuffer.prototype.readDoubleBE = function readDoubleBE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 8, this.length)\n  return ieee754.read(this, offset, false, 52, 8)\n}\n\nfunction checkInt (buf, value, offset, ext, max, min) {\n  if (!Buffer.isBuffer(buf)) throw new TypeError('buffer must be a Buffer instance')\n  if (value > max || value < min) throw new RangeError('value is out of bounds')\n  if (offset + ext > buf.length) throw new RangeError('index out of range')\n}\n\nBuffer.prototype.writeUIntLE = function writeUIntLE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset | 0\n  byteLength = byteLength | 0\n  if (!noAssert) checkInt(this, value, offset, byteLength, Math.pow(2, 8 * byteLength), 0)\n\n  var mul = 1\n  var i = 0\n  this[offset] = value & 0xFF\n  while (++i < byteLength && (mul *= 0x100)) {\n    this[offset + i] = (value / mul) & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeUIntBE = function writeUIntBE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset | 0\n  byteLength = byteLength | 0\n  if (!noAssert) checkInt(this, value, offset, byteLength, Math.pow(2, 8 * byteLength), 0)\n\n  var i = byteLength - 1\n  var mul = 1\n  this[offset + i] = value & 0xFF\n  while (--i >= 0 && (mul *= 0x100)) {\n    this[offset + i] = (value / mul) & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeUInt8 = function writeUInt8 (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0)\n  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)\n  this[offset] = value\n  return offset + 1\n}\n\nfunction objectWriteUInt16 (buf, value, offset, littleEndian) {\n  if (value < 0) value = 0xffff + value + 1\n  for (var i = 0, j = Math.min(buf.length - offset, 2); i < j; i++) {\n    buf[offset + i] = (value & (0xff << (8 * (littleEndian ? i : 1 - i)))) >>>\n      (littleEndian ? i : 1 - i) * 8\n  }\n}\n\nBuffer.prototype.writeUInt16LE = function writeUInt16LE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = value\n    this[offset + 1] = (value >>> 8)\n  } else {\n    objectWriteUInt16(this, value, offset, true)\n  }\n  return offset + 2\n}\n\nBuffer.prototype.writeUInt16BE = function writeUInt16BE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value >>> 8)\n    this[offset + 1] = value\n  } else {\n    objectWriteUInt16(this, value, offset, false)\n  }\n  return offset + 2\n}\n\nfunction objectWriteUInt32 (buf, value, offset, littleEndian) {\n  if (value < 0) value = 0xffffffff + value + 1\n  for (var i = 0, j = Math.min(buf.length - offset, 4); i < j; i++) {\n    buf[offset + i] = (value >>> (littleEndian ? i : 3 - i) * 8) & 0xff\n  }\n}\n\nBuffer.prototype.writeUInt32LE = function writeUInt32LE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset + 3] = (value >>> 24)\n    this[offset + 2] = (value >>> 16)\n    this[offset + 1] = (value >>> 8)\n    this[offset] = value\n  } else {\n    objectWriteUInt32(this, value, offset, true)\n  }\n  return offset + 4\n}\n\nBuffer.prototype.writeUInt32BE = function writeUInt32BE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value >>> 24)\n    this[offset + 1] = (value >>> 16)\n    this[offset + 2] = (value >>> 8)\n    this[offset + 3] = value\n  } else {\n    objectWriteUInt32(this, value, offset, false)\n  }\n  return offset + 4\n}\n\nBuffer.prototype.writeIntLE = function writeIntLE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) {\n    var limit = Math.pow(2, 8 * byteLength - 1)\n\n    checkInt(this, value, offset, byteLength, limit - 1, -limit)\n  }\n\n  var i = 0\n  var mul = 1\n  var sub = value < 0 ? 1 : 0\n  this[offset] = value & 0xFF\n  while (++i < byteLength && (mul *= 0x100)) {\n    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeIntBE = function writeIntBE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) {\n    var limit = Math.pow(2, 8 * byteLength - 1)\n\n    checkInt(this, value, offset, byteLength, limit - 1, -limit)\n  }\n\n  var i = byteLength - 1\n  var mul = 1\n  var sub = value < 0 ? 1 : 0\n  this[offset + i] = value & 0xFF\n  while (--i >= 0 && (mul *= 0x100)) {\n    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeInt8 = function writeInt8 (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80)\n  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)\n  if (value < 0) value = 0xff + value + 1\n  this[offset] = value\n  return offset + 1\n}\n\nBuffer.prototype.writeInt16LE = function writeInt16LE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = value\n    this[offset + 1] = (value >>> 8)\n  } else {\n    objectWriteUInt16(this, value, offset, true)\n  }\n  return offset + 2\n}\n\nBuffer.prototype.writeInt16BE = function writeInt16BE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value >>> 8)\n    this[offset + 1] = value\n  } else {\n    objectWriteUInt16(this, value, offset, false)\n  }\n  return offset + 2\n}\n\nBuffer.prototype.writeInt32LE = function writeInt32LE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = value\n    this[offset + 1] = (value >>> 8)\n    this[offset + 2] = (value >>> 16)\n    this[offset + 3] = (value >>> 24)\n  } else {\n    objectWriteUInt32(this, value, offset, true)\n  }\n  return offset + 4\n}\n\nBuffer.prototype.writeInt32BE = function writeInt32BE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)\n  if (value < 0) value = 0xffffffff + value + 1\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value >>> 24)\n    this[offset + 1] = (value >>> 16)\n    this[offset + 2] = (value >>> 8)\n    this[offset + 3] = value\n  } else {\n    objectWriteUInt32(this, value, offset, false)\n  }\n  return offset + 4\n}\n\nfunction checkIEEE754 (buf, value, offset, ext, max, min) {\n  if (value > max || value < min) throw new RangeError('value is out of bounds')\n  if (offset + ext > buf.length) throw new RangeError('index out of range')\n  if (offset < 0) throw new RangeError('index out of range')\n}\n\nfunction writeFloat (buf, value, offset, littleEndian, noAssert) {\n  if (!noAssert) {\n    checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -3.4028234663852886e+38)\n  }\n  ieee754.write(buf, value, offset, littleEndian, 23, 4)\n  return offset + 4\n}\n\nBuffer.prototype.writeFloatLE = function writeFloatLE (value, offset, noAssert) {\n  return writeFloat(this, value, offset, true, noAssert)\n}\n\nBuffer.prototype.writeFloatBE = function writeFloatBE (value, offset, noAssert) {\n  return writeFloat(this, value, offset, false, noAssert)\n}\n\nfunction writeDouble (buf, value, offset, littleEndian, noAssert) {\n  if (!noAssert) {\n    checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, -1.7976931348623157E+308)\n  }\n  ieee754.write(buf, value, offset, littleEndian, 52, 8)\n  return offset + 8\n}\n\nBuffer.prototype.writeDoubleLE = function writeDoubleLE (value, offset, noAssert) {\n  return writeDouble(this, value, offset, true, noAssert)\n}\n\nBuffer.prototype.writeDoubleBE = function writeDoubleBE (value, offset, noAssert) {\n  return writeDouble(this, value, offset, false, noAssert)\n}\n\n// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)\nBuffer.prototype.copy = function copy (target, targetStart, start, end) {\n  if (!start) start = 0\n  if (!end && end !== 0) end = this.length\n  if (targetStart >= target.length) targetStart = target.length\n  if (!targetStart) targetStart = 0\n  if (end > 0 && end < start) end = start\n\n  // Copy 0 bytes; we're done\n  if (end === start) return 0\n  if (target.length === 0 || this.length === 0) return 0\n\n  // Fatal error conditions\n  if (targetStart < 0) {\n    throw new RangeError('targetStart out of bounds')\n  }\n  if (start < 0 || start >= this.length) throw new RangeError('sourceStart out of bounds')\n  if (end < 0) throw new RangeError('sourceEnd out of bounds')\n\n  // Are we oob?\n  if (end > this.length) end = this.length\n  if (target.length - targetStart < end - start) {\n    end = target.length - targetStart + start\n  }\n\n  var len = end - start\n  var i\n\n  if (this === target && start < targetStart && targetStart < end) {\n    // descending copy from end\n    for (i = len - 1; i >= 0; i--) {\n      target[i + targetStart] = this[i + start]\n    }\n  } else if (len < 1000 || !Buffer.TYPED_ARRAY_SUPPORT) {\n    // ascending copy from start\n    for (i = 0; i < len; i++) {\n      target[i + targetStart] = this[i + start]\n    }\n  } else {\n    target._set(this.subarray(start, start + len), targetStart)\n  }\n\n  return len\n}\n\n// fill(value, start=0, end=buffer.length)\nBuffer.prototype.fill = function fill (value, start, end) {\n  if (!value) value = 0\n  if (!start) start = 0\n  if (!end) end = this.length\n\n  if (end < start) throw new RangeError('end < start')\n\n  // Fill 0 bytes; we're done\n  if (end === start) return\n  if (this.length === 0) return\n\n  if (start < 0 || start >= this.length) throw new RangeError('start out of bounds')\n  if (end < 0 || end > this.length) throw new RangeError('end out of bounds')\n\n  var i\n  if (typeof value === 'number') {\n    for (i = start; i < end; i++) {\n      this[i] = value\n    }\n  } else {\n    var bytes = utf8ToBytes(value.toString())\n    var len = bytes.length\n    for (i = start; i < end; i++) {\n      this[i] = bytes[i % len]\n    }\n  }\n\n  return this\n}\n\n/**\n * Creates a new `ArrayBuffer` with the *copied* memory of the buffer instance.\n * Added in Node 0.12. Only available in browsers that support ArrayBuffer.\n */\nBuffer.prototype.toArrayBuffer = function toArrayBuffer () {\n  if (typeof Uint8Array !== 'undefined') {\n    if (Buffer.TYPED_ARRAY_SUPPORT) {\n      return (new Buffer(this)).buffer\n    } else {\n      var buf = new Uint8Array(this.length)\n      for (var i = 0, len = buf.length; i < len; i += 1) {\n        buf[i] = this[i]\n      }\n      return buf.buffer\n    }\n  } else {\n    throw new TypeError('Buffer.toArrayBuffer not supported in this browser')\n  }\n}\n\n// HELPER FUNCTIONS\n// ================\n\nvar BP = Buffer.prototype\n\n/**\n * Augment a Uint8Array *instance* (not the Uint8Array class!) with Buffer methods\n */\nBuffer._augment = function _augment (arr) {\n  arr.constructor = Buffer\n  arr._isBuffer = true\n\n  // save reference to original Uint8Array set method before overwriting\n  arr._set = arr.set\n\n  // deprecated\n  arr.get = BP.get\n  arr.set = BP.set\n\n  arr.write = BP.write\n  arr.toString = BP.toString\n  arr.toLocaleString = BP.toString\n  arr.toJSON = BP.toJSON\n  arr.equals = BP.equals\n  arr.compare = BP.compare\n  arr.indexOf = BP.indexOf\n  arr.copy = BP.copy\n  arr.slice = BP.slice\n  arr.readUIntLE = BP.readUIntLE\n  arr.readUIntBE = BP.readUIntBE\n  arr.readUInt8 = BP.readUInt8\n  arr.readUInt16LE = BP.readUInt16LE\n  arr.readUInt16BE = BP.readUInt16BE\n  arr.readUInt32LE = BP.readUInt32LE\n  arr.readUInt32BE = BP.readUInt32BE\n  arr.readIntLE = BP.readIntLE\n  arr.readIntBE = BP.readIntBE\n  arr.readInt8 = BP.readInt8\n  arr.readInt16LE = BP.readInt16LE\n  arr.readInt16BE = BP.readInt16BE\n  arr.readInt32LE = BP.readInt32LE\n  arr.readInt32BE = BP.readInt32BE\n  arr.readFloatLE = BP.readFloatLE\n  arr.readFloatBE = BP.readFloatBE\n  arr.readDoubleLE = BP.readDoubleLE\n  arr.readDoubleBE = BP.readDoubleBE\n  arr.writeUInt8 = BP.writeUInt8\n  arr.writeUIntLE = BP.writeUIntLE\n  arr.writeUIntBE = BP.writeUIntBE\n  arr.writeUInt16LE = BP.writeUInt16LE\n  arr.writeUInt16BE = BP.writeUInt16BE\n  arr.writeUInt32LE = BP.writeUInt32LE\n  arr.writeUInt32BE = BP.writeUInt32BE\n  arr.writeIntLE = BP.writeIntLE\n  arr.writeIntBE = BP.writeIntBE\n  arr.writeInt8 = BP.writeInt8\n  arr.writeInt16LE = BP.writeInt16LE\n  arr.writeInt16BE = BP.writeInt16BE\n  arr.writeInt32LE = BP.writeInt32LE\n  arr.writeInt32BE = BP.writeInt32BE\n  arr.writeFloatLE = BP.writeFloatLE\n  arr.writeFloatBE = BP.writeFloatBE\n  arr.writeDoubleLE = BP.writeDoubleLE\n  arr.writeDoubleBE = BP.writeDoubleBE\n  arr.fill = BP.fill\n  arr.inspect = BP.inspect\n  arr.toArrayBuffer = BP.toArrayBuffer\n\n  return arr\n}\n\nvar INVALID_BASE64_RE = /[^+\\/0-9A-Za-z-_]/g\n\nfunction base64clean (str) {\n  // Node strips out invalid characters like \\n and \\t from the string, base64-js does not\n  str = stringtrim(str).replace(INVALID_BASE64_RE, '')\n  // Node converts strings with length < 2 to ''\n  if (str.length < 2) return ''\n  // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not\n  while (str.length % 4 !== 0) {\n    str = str + '='\n  }\n  return str\n}\n\nfunction stringtrim (str) {\n  if (str.trim) return str.trim()\n  return str.replace(/^\\s+|\\s+$/g, '')\n}\n\nfunction toHex (n) {\n  if (n < 16) return '0' + n.toString(16)\n  return n.toString(16)\n}\n\nfunction utf8ToBytes (string, units) {\n  units = units || Infinity\n  var codePoint\n  var length = string.length\n  var leadSurrogate = null\n  var bytes = []\n\n  for (var i = 0; i < length; i++) {\n    codePoint = string.charCodeAt(i)\n\n    // is surrogate component\n    if (codePoint > 0xD7FF && codePoint < 0xE000) {\n      // last char was a lead\n      if (!leadSurrogate) {\n        // no lead yet\n        if (codePoint > 0xDBFF) {\n          // unexpected trail\n          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n          continue\n        } else if (i + 1 === length) {\n          // unpaired lead\n          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n          continue\n        }\n\n        // valid lead\n        leadSurrogate = codePoint\n\n        continue\n      }\n\n      // 2 leads in a row\n      if (codePoint < 0xDC00) {\n        if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n        leadSurrogate = codePoint\n        continue\n      }\n\n      // valid surrogate pair\n      codePoint = leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00 | 0x10000\n    } else if (leadSurrogate) {\n      // valid bmp char, but last char was a lead\n      if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n    }\n\n    leadSurrogate = null\n\n    // encode utf8\n    if (codePoint < 0x80) {\n      if ((units -= 1) < 0) break\n      bytes.push(codePoint)\n    } else if (codePoint < 0x800) {\n      if ((units -= 2) < 0) break\n      bytes.push(\n        codePoint >> 0x6 | 0xC0,\n        codePoint & 0x3F | 0x80\n      )\n    } else if (codePoint < 0x10000) {\n      if ((units -= 3) < 0) break\n      bytes.push(\n        codePoint >> 0xC | 0xE0,\n        codePoint >> 0x6 & 0x3F | 0x80,\n        codePoint & 0x3F | 0x80\n      )\n    } else if (codePoint < 0x110000) {\n      if ((units -= 4) < 0) break\n      bytes.push(\n        codePoint >> 0x12 | 0xF0,\n        codePoint >> 0xC & 0x3F | 0x80,\n        codePoint >> 0x6 & 0x3F | 0x80,\n        codePoint & 0x3F | 0x80\n      )\n    } else {\n      throw new Error('Invalid code point')\n    }\n  }\n\n  return bytes\n}\n\nfunction asciiToBytes (str) {\n  var byteArray = []\n  for (var i = 0; i < str.length; i++) {\n    // Node's code seems to be doing this and not & 0x7F..\n    byteArray.push(str.charCodeAt(i) & 0xFF)\n  }\n  return byteArray\n}\n\nfunction utf16leToBytes (str, units) {\n  var c, hi, lo\n  var byteArray = []\n  for (var i = 0; i < str.length; i++) {\n    if ((units -= 2) < 0) break\n\n    c = str.charCodeAt(i)\n    hi = c >> 8\n    lo = c % 256\n    byteArray.push(lo)\n    byteArray.push(hi)\n  }\n\n  return byteArray\n}\n\nfunction base64ToBytes (str) {\n  return base64.toByteArray(base64clean(str))\n}\n\nfunction blitBuffer (src, dst, offset, length) {\n  for (var i = 0; i < length; i++) {\n    if ((i + offset >= dst.length) || (i >= src.length)) break\n    dst[i + offset] = src[i]\n  }\n  return i\n}\n","(function(f){if(typeof exports===\"object\"&&typeof module!==\"undefined\"){module.exports=f()}else if(typeof define===\"function\"&&define.amd){define([],f)}else{var g;if(typeof window!==\"undefined\"){g=window}else if(typeof global!==\"undefined\"){g=global}else if(typeof self!==\"undefined\"){g=self}else{g=this}g.acorn = f()}})(function(){var define,module,exports;return (function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require==\"function\"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error(\"Cannot find module '\"+o+\"'\");throw f.code=\"MODULE_NOT_FOUND\",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require==\"function\"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(_dereq_,module,exports){\n// A recursive descent parser operates by defining functions for all\n// syntactic elements, and recursively calling those, each function\n// advancing the input stream and returning an AST node. Precedence\n// of constructs (for example, the fact that `!x[1]` means `!(x[1])`\n// instead of `(!x)[1]` is handled by the fact that the parser\n// function that parses unary prefix operators is called first, and\n// in turn calls the function that parses `[]` subscripts  that\n// way, it'll receive the node for `x[1]` already parsed, and wraps\n// *that* in the unary operator node.\n//\n// Acorn uses an [operator precedence parser][opp] to handle binary\n// operator precedence, because it is much more compact than using\n// the technique outlined above, which uses different, nesting\n// functions to specify precedence, for all of the ten binary\n// precedence levels that JavaScript defines.\n//\n// [opp]: http://en.wikipedia.org/wiki/Operator-precedence_parser\n\n\"use strict\";\n\nvar _tokentype = _dereq_(\"./tokentype\");\n\nvar _state = _dereq_(\"./state\");\n\nvar _identifier = _dereq_(\"./identifier\");\n\nvar _util = _dereq_(\"./util\");\n\nvar pp = _state.Parser.prototype;\n\n// Check if property name clashes with already added.\n// Object/class getters and setters are not allowed to clash \n// either with each other or with an init property  and in\n// strict mode, init properties are also not allowed to be repeated.\n\npp.checkPropClash = function (prop, propHash) {\n  if (this.options.ecmaVersion >= 6 && (prop.computed || prop.method || prop.shorthand)) return;\n  var key = prop.key,\n      name = undefined;\n  switch (key.type) {\n    case \"Identifier\":\n      name = key.name;break;\n    case \"Literal\":\n      name = String(key.value);break;\n    default:\n      return;\n  }\n  var kind = prop.kind;\n  if (this.options.ecmaVersion >= 6) {\n    if (name === \"__proto__\" && kind === \"init\") {\n      if (propHash.proto) this.raise(key.start, \"Redefinition of __proto__ property\");\n      propHash.proto = true;\n    }\n    return;\n  }\n  var other = undefined;\n  if (_util.has(propHash, name)) {\n    other = propHash[name];\n    var isGetSet = kind !== \"init\";\n    if ((this.strict || isGetSet) && other[kind] || !(isGetSet ^ other.init)) this.raise(key.start, \"Redefinition of property\");\n  } else {\n    other = propHash[name] = {\n      init: false,\n      get: false,\n      set: false\n    };\n  }\n  other[kind] = true;\n};\n\n// ### Expression parsing\n\n// These nest, from the most general expression type at the top to\n// 'atomic', nondivisible expression types at the bottom. Most of\n// the functions will simply let the function(s) below them parse,\n// and, *if* the syntactic construct they handle is present, wrap\n// the AST node that the inner parser gave them in another node.\n\n// Parse a full expression. The optional arguments are used to\n// forbid the `in` operator (in for loops initalization expressions)\n// and provide reference for storing '=' operator inside shorthand\n// property assignment in contexts where both object expression\n// and object pattern might appear (so it's possible to raise\n// delayed syntax error at correct position).\n\npp.parseExpression = function (noIn, refShorthandDefaultPos) {\n  var startPos = this.start,\n      startLoc = this.startLoc;\n  var expr = this.parseMaybeAssign(noIn, refShorthandDefaultPos);\n  if (this.type === _tokentype.types.comma) {\n    var node = this.startNodeAt(startPos, startLoc);\n    node.expressions = [expr];\n    while (this.eat(_tokentype.types.comma)) node.expressions.push(this.parseMaybeAssign(noIn, refShorthandDefaultPos));\n    return this.finishNode(node, \"SequenceExpression\");\n  }\n  return expr;\n};\n\n// Parse an assignment expression. This includes applications of\n// operators like `+=`.\n\npp.parseMaybeAssign = function (noIn, refShorthandDefaultPos, afterLeftParse) {\n  if (this.type == _tokentype.types._yield && this.inGenerator) return this.parseYield();\n\n  var failOnShorthandAssign = undefined;\n  if (!refShorthandDefaultPos) {\n    refShorthandDefaultPos = { start: 0 };\n    failOnShorthandAssign = true;\n  } else {\n    failOnShorthandAssign = false;\n  }\n  var startPos = this.start,\n      startLoc = this.startLoc;\n  if (this.type == _tokentype.types.parenL || this.type == _tokentype.types.name) this.potentialArrowAt = this.start;\n  var left = this.parseMaybeConditional(noIn, refShorthandDefaultPos);\n  if (afterLeftParse) left = afterLeftParse.call(this, left, startPos, startLoc);\n  if (this.type.isAssign) {\n    var node = this.startNodeAt(startPos, startLoc);\n    node.operator = this.value;\n    node.left = this.type === _tokentype.types.eq ? this.toAssignable(left) : left;\n    refShorthandDefaultPos.start = 0; // reset because shorthand default was used correctly\n    this.checkLVal(left);\n    this.next();\n    node.right = this.parseMaybeAssign(noIn);\n    return this.finishNode(node, \"AssignmentExpression\");\n  } else if (failOnShorthandAssign && refShorthandDefaultPos.start) {\n    this.unexpected(refShorthandDefaultPos.start);\n  }\n  return left;\n};\n\n// Parse a ternary conditional (`?:`) operator.\n\npp.parseMaybeConditional = function (noIn, refShorthandDefaultPos) {\n  var startPos = this.start,\n      startLoc = this.startLoc;\n  var expr = this.parseExprOps(noIn, refShorthandDefaultPos);\n  if (refShorthandDefaultPos && refShorthandDefaultPos.start) return expr;\n  if (this.eat(_tokentype.types.question)) {\n    var node = this.startNodeAt(startPos, startLoc);\n    node.test = expr;\n    node.consequent = this.parseMaybeAssign();\n    this.expect(_tokentype.types.colon);\n    node.alternate = this.parseMaybeAssign(noIn);\n    return this.finishNode(node, \"ConditionalExpression\");\n  }\n  return expr;\n};\n\n// Start the precedence parser.\n\npp.parseExprOps = function (noIn, refShorthandDefaultPos) {\n  var startPos = this.start,\n      startLoc = this.startLoc;\n  var expr = this.parseMaybeUnary(refShorthandDefaultPos);\n  if (refShorthandDefaultPos && refShorthandDefaultPos.start) return expr;\n  return this.parseExprOp(expr, startPos, startLoc, -1, noIn);\n};\n\n// Parse binary operators with the operator precedence parsing\n// algorithm. `left` is the left-hand side of the operator.\n// `minPrec` provides context that allows the function to stop and\n// defer further parser to one of its callers when it encounters an\n// operator that has a lower precedence than the set it is parsing.\n\npp.parseExprOp = function (left, leftStartPos, leftStartLoc, minPrec, noIn) {\n  var prec = this.type.binop;\n  if (prec != null && (!noIn || this.type !== _tokentype.types._in)) {\n    if (prec > minPrec) {\n      var node = this.startNodeAt(leftStartPos, leftStartLoc);\n      node.left = left;\n      node.operator = this.value;\n      var op = this.type;\n      this.next();\n      var startPos = this.start,\n          startLoc = this.startLoc;\n      node.right = this.parseExprOp(this.parseMaybeUnary(), startPos, startLoc, prec, noIn);\n      this.finishNode(node, op === _tokentype.types.logicalOR || op === _tokentype.types.logicalAND ? \"LogicalExpression\" : \"BinaryExpression\");\n      return this.parseExprOp(node, leftStartPos, leftStartLoc, minPrec, noIn);\n    }\n  }\n  return left;\n};\n\n// Parse unary operators, both prefix and postfix.\n\npp.parseMaybeUnary = function (refShorthandDefaultPos) {\n  if (this.type.prefix) {\n    var node = this.startNode(),\n        update = this.type === _tokentype.types.incDec;\n    node.operator = this.value;\n    node.prefix = true;\n    this.next();\n    node.argument = this.parseMaybeUnary();\n    if (refShorthandDefaultPos && refShorthandDefaultPos.start) this.unexpected(refShorthandDefaultPos.start);\n    if (update) this.checkLVal(node.argument);else if (this.strict && node.operator === \"delete\" && node.argument.type === \"Identifier\") this.raise(node.start, \"Deleting local variable in strict mode\");\n    return this.finishNode(node, update ? \"UpdateExpression\" : \"UnaryExpression\");\n  }\n  var startPos = this.start,\n      startLoc = this.startLoc;\n  var expr = this.parseExprSubscripts(refShorthandDefaultPos);\n  if (refShorthandDefaultPos && refShorthandDefaultPos.start) return expr;\n  while (this.type.postfix && !this.canInsertSemicolon()) {\n    var node = this.startNodeAt(startPos, startLoc);\n    node.operator = this.value;\n    node.prefix = false;\n    node.argument = expr;\n    this.checkLVal(expr);\n    this.next();\n    expr = this.finishNode(node, \"UpdateExpression\");\n  }\n  return expr;\n};\n\n// Parse call, dot, and `[]`-subscript expressions.\n\npp.parseExprSubscripts = function (refShorthandDefaultPos) {\n  var startPos = this.start,\n      startLoc = this.startLoc;\n  var expr = this.parseExprAtom(refShorthandDefaultPos);\n  if (refShorthandDefaultPos && refShorthandDefaultPos.start) return expr;\n  return this.parseSubscripts(expr, startPos, startLoc);\n};\n\npp.parseSubscripts = function (base, startPos, startLoc, noCalls) {\n  for (;;) {\n    if (this.eat(_tokentype.types.dot)) {\n      var node = this.startNodeAt(startPos, startLoc);\n      node.object = base;\n      node.property = this.parseIdent(true);\n      node.computed = false;\n      base = this.finishNode(node, \"MemberExpression\");\n    } else if (this.eat(_tokentype.types.bracketL)) {\n      var node = this.startNodeAt(startPos, startLoc);\n      node.object = base;\n      node.property = this.parseExpression();\n      node.computed = true;\n      this.expect(_tokentype.types.bracketR);\n      base = this.finishNode(node, \"MemberExpression\");\n    } else if (!noCalls && this.eat(_tokentype.types.parenL)) {\n      var node = this.startNodeAt(startPos, startLoc);\n      node.callee = base;\n      node.arguments = this.parseExprList(_tokentype.types.parenR, false);\n      base = this.finishNode(node, \"CallExpression\");\n    } else if (this.type === _tokentype.types.backQuote) {\n      var node = this.startNodeAt(startPos, startLoc);\n      node.tag = base;\n      node.quasi = this.parseTemplate();\n      base = this.finishNode(node, \"TaggedTemplateExpression\");\n    } else {\n      return base;\n    }\n  }\n};\n\n// Parse an atomic expression  either a single token that is an\n// expression, an expression started by a keyword like `function` or\n// `new`, or an expression wrapped in punctuation like `()`, `[]`,\n// or `{}`.\n\npp.parseExprAtom = function (refShorthandDefaultPos) {\n  var node = undefined,\n      canBeArrow = this.potentialArrowAt == this.start;\n  switch (this.type) {\n    case _tokentype.types._super:\n      if (!this.inFunction) this.raise(this.start, \"'super' outside of function or class\");\n    case _tokentype.types._this:\n      var type = this.type === _tokentype.types._this ? \"ThisExpression\" : \"Super\";\n      node = this.startNode();\n      this.next();\n      return this.finishNode(node, type);\n\n    case _tokentype.types._yield:\n      if (this.inGenerator) this.unexpected();\n\n    case _tokentype.types.name:\n      var startPos = this.start,\n          startLoc = this.startLoc;\n      var id = this.parseIdent(this.type !== _tokentype.types.name);\n      if (canBeArrow && !this.canInsertSemicolon() && this.eat(_tokentype.types.arrow)) return this.parseArrowExpression(this.startNodeAt(startPos, startLoc), [id]);\n      return id;\n\n    case _tokentype.types.regexp:\n      var value = this.value;\n      node = this.parseLiteral(value.value);\n      node.regex = { pattern: value.pattern, flags: value.flags };\n      return node;\n\n    case _tokentype.types.num:case _tokentype.types.string:\n      return this.parseLiteral(this.value);\n\n    case _tokentype.types._null:case _tokentype.types._true:case _tokentype.types._false:\n      node = this.startNode();\n      node.value = this.type === _tokentype.types._null ? null : this.type === _tokentype.types._true;\n      node.raw = this.type.keyword;\n      this.next();\n      return this.finishNode(node, \"Literal\");\n\n    case _tokentype.types.parenL:\n      return this.parseParenAndDistinguishExpression(canBeArrow);\n\n    case _tokentype.types.bracketL:\n      node = this.startNode();\n      this.next();\n      // check whether this is array comprehension or regular array\n      if (this.options.ecmaVersion >= 7 && this.type === _tokentype.types._for) {\n        return this.parseComprehension(node, false);\n      }\n      node.elements = this.parseExprList(_tokentype.types.bracketR, true, true, refShorthandDefaultPos);\n      return this.finishNode(node, \"ArrayExpression\");\n\n    case _tokentype.types.braceL:\n      return this.parseObj(false, refShorthandDefaultPos);\n\n    case _tokentype.types._function:\n      node = this.startNode();\n      this.next();\n      return this.parseFunction(node, false);\n\n    case _tokentype.types._class:\n      return this.parseClass(this.startNode(), false);\n\n    case _tokentype.types._new:\n      return this.parseNew();\n\n    case _tokentype.types.backQuote:\n      return this.parseTemplate();\n\n    default:\n      this.unexpected();\n  }\n};\n\npp.parseLiteral = function (value) {\n  var node = this.startNode();\n  node.value = value;\n  node.raw = this.input.slice(this.start, this.end);\n  this.next();\n  return this.finishNode(node, \"Literal\");\n};\n\npp.parseParenExpression = function () {\n  this.expect(_tokentype.types.parenL);\n  var val = this.parseExpression();\n  this.expect(_tokentype.types.parenR);\n  return val;\n};\n\npp.parseParenAndDistinguishExpression = function (canBeArrow) {\n  var startPos = this.start,\n      startLoc = this.startLoc,\n      val = undefined;\n  if (this.options.ecmaVersion >= 6) {\n    this.next();\n\n    if (this.options.ecmaVersion >= 7 && this.type === _tokentype.types._for) {\n      return this.parseComprehension(this.startNodeAt(startPos, startLoc), true);\n    }\n\n    var innerStartPos = this.start,\n        innerStartLoc = this.startLoc;\n    var exprList = [],\n        first = true;\n    var refShorthandDefaultPos = { start: 0 },\n        spreadStart = undefined,\n        innerParenStart = undefined;\n    while (this.type !== _tokentype.types.parenR) {\n      first ? first = false : this.expect(_tokentype.types.comma);\n      if (this.type === _tokentype.types.ellipsis) {\n        spreadStart = this.start;\n        exprList.push(this.parseParenItem(this.parseRest()));\n        break;\n      } else {\n        if (this.type === _tokentype.types.parenL && !innerParenStart) {\n          innerParenStart = this.start;\n        }\n        exprList.push(this.parseMaybeAssign(false, refShorthandDefaultPos, this.parseParenItem));\n      }\n    }\n    var innerEndPos = this.start,\n        innerEndLoc = this.startLoc;\n    this.expect(_tokentype.types.parenR);\n\n    if (canBeArrow && !this.canInsertSemicolon() && this.eat(_tokentype.types.arrow)) {\n      if (innerParenStart) this.unexpected(innerParenStart);\n      return this.parseParenArrowList(startPos, startLoc, exprList);\n    }\n\n    if (!exprList.length) this.unexpected(this.lastTokStart);\n    if (spreadStart) this.unexpected(spreadStart);\n    if (refShorthandDefaultPos.start) this.unexpected(refShorthandDefaultPos.start);\n\n    if (exprList.length > 1) {\n      val = this.startNodeAt(innerStartPos, innerStartLoc);\n      val.expressions = exprList;\n      this.finishNodeAt(val, \"SequenceExpression\", innerEndPos, innerEndLoc);\n    } else {\n      val = exprList[0];\n    }\n  } else {\n    val = this.parseParenExpression();\n  }\n\n  if (this.options.preserveParens) {\n    var par = this.startNodeAt(startPos, startLoc);\n    par.expression = val;\n    return this.finishNode(par, \"ParenthesizedExpression\");\n  } else {\n    return val;\n  }\n};\n\npp.parseParenItem = function (item) {\n  return item;\n};\n\npp.parseParenArrowList = function (startPos, startLoc, exprList) {\n  return this.parseArrowExpression(this.startNodeAt(startPos, startLoc), exprList);\n};\n\n// New's precedence is slightly tricky. It must allow its argument\n// to be a `[]` or dot subscript expression, but not a call  at\n// least, not without wrapping it in parentheses. Thus, it uses the\n\nvar empty = [];\n\npp.parseNew = function () {\n  var node = this.startNode();\n  var meta = this.parseIdent(true);\n  if (this.options.ecmaVersion >= 6 && this.eat(_tokentype.types.dot)) {\n    node.meta = meta;\n    node.property = this.parseIdent(true);\n    if (node.property.name !== \"target\") this.raise(node.property.start, \"The only valid meta property for new is new.target\");\n    return this.finishNode(node, \"MetaProperty\");\n  }\n  var startPos = this.start,\n      startLoc = this.startLoc;\n  node.callee = this.parseSubscripts(this.parseExprAtom(), startPos, startLoc, true);\n  if (this.eat(_tokentype.types.parenL)) node.arguments = this.parseExprList(_tokentype.types.parenR, false);else node.arguments = empty;\n  return this.finishNode(node, \"NewExpression\");\n};\n\n// Parse template expression.\n\npp.parseTemplateElement = function () {\n  var elem = this.startNode();\n  elem.value = {\n    raw: this.input.slice(this.start, this.end).replace(/\\r\\n?/g, \"\\n\"),\n    cooked: this.value\n  };\n  this.next();\n  elem.tail = this.type === _tokentype.types.backQuote;\n  return this.finishNode(elem, \"TemplateElement\");\n};\n\npp.parseTemplate = function () {\n  var node = this.startNode();\n  this.next();\n  node.expressions = [];\n  var curElt = this.parseTemplateElement();\n  node.quasis = [curElt];\n  while (!curElt.tail) {\n    this.expect(_tokentype.types.dollarBraceL);\n    node.expressions.push(this.parseExpression());\n    this.expect(_tokentype.types.braceR);\n    node.quasis.push(curElt = this.parseTemplateElement());\n  }\n  this.next();\n  return this.finishNode(node, \"TemplateLiteral\");\n};\n\n// Parse an object literal or binding pattern.\n\npp.parseObj = function (isPattern, refShorthandDefaultPos) {\n  var node = this.startNode(),\n      first = true,\n      propHash = {};\n  node.properties = [];\n  this.next();\n  while (!this.eat(_tokentype.types.braceR)) {\n    if (!first) {\n      this.expect(_tokentype.types.comma);\n      if (this.afterTrailingComma(_tokentype.types.braceR)) break;\n    } else first = false;\n\n    var prop = this.startNode(),\n        isGenerator = undefined,\n        startPos = undefined,\n        startLoc = undefined;\n    if (this.options.ecmaVersion >= 6) {\n      prop.method = false;\n      prop.shorthand = false;\n      if (isPattern || refShorthandDefaultPos) {\n        startPos = this.start;\n        startLoc = this.startLoc;\n      }\n      if (!isPattern) isGenerator = this.eat(_tokentype.types.star);\n    }\n    this.parsePropertyName(prop);\n    this.parsePropertyValue(prop, isPattern, isGenerator, startPos, startLoc, refShorthandDefaultPos);\n    this.checkPropClash(prop, propHash);\n    node.properties.push(this.finishNode(prop, \"Property\"));\n  }\n  return this.finishNode(node, isPattern ? \"ObjectPattern\" : \"ObjectExpression\");\n};\n\npp.parsePropertyValue = function (prop, isPattern, isGenerator, startPos, startLoc, refShorthandDefaultPos) {\n  if (this.eat(_tokentype.types.colon)) {\n    prop.value = isPattern ? this.parseMaybeDefault(this.start, this.startLoc) : this.parseMaybeAssign(false, refShorthandDefaultPos);\n    prop.kind = \"init\";\n  } else if (this.options.ecmaVersion >= 6 && this.type === _tokentype.types.parenL) {\n    if (isPattern) this.unexpected();\n    prop.kind = \"init\";\n    prop.method = true;\n    prop.value = this.parseMethod(isGenerator);\n  } else if (this.options.ecmaVersion >= 5 && !prop.computed && prop.key.type === \"Identifier\" && (prop.key.name === \"get\" || prop.key.name === \"set\") && (this.type != _tokentype.types.comma && this.type != _tokentype.types.braceR)) {\n    if (isGenerator || isPattern) this.unexpected();\n    prop.kind = prop.key.name;\n    this.parsePropertyName(prop);\n    prop.value = this.parseMethod(false);\n    var paramCount = prop.kind === \"get\" ? 0 : 1;\n    if (prop.value.params.length !== paramCount) {\n      var start = prop.value.start;\n      if (prop.kind === \"get\") this.raise(start, \"getter should have no params\");else this.raise(start, \"setter should have exactly one param\");\n    }\n  } else if (this.options.ecmaVersion >= 6 && !prop.computed && prop.key.type === \"Identifier\") {\n    prop.kind = \"init\";\n    if (isPattern) {\n      if (this.isKeyword(prop.key.name) || this.strict && (_identifier.reservedWords.strictBind(prop.key.name) || _identifier.reservedWords.strict(prop.key.name)) || !this.options.allowReserved && this.isReservedWord(prop.key.name)) this.raise(prop.key.start, \"Binding \" + prop.key.name);\n      prop.value = this.parseMaybeDefault(startPos, startLoc, prop.key);\n    } else if (this.type === _tokentype.types.eq && refShorthandDefaultPos) {\n      if (!refShorthandDefaultPos.start) refShorthandDefaultPos.start = this.start;\n      prop.value = this.parseMaybeDefault(startPos, startLoc, prop.key);\n    } else {\n      prop.value = prop.key;\n    }\n    prop.shorthand = true;\n  } else this.unexpected();\n};\n\npp.parsePropertyName = function (prop) {\n  if (this.options.ecmaVersion >= 6) {\n    if (this.eat(_tokentype.types.bracketL)) {\n      prop.computed = true;\n      prop.key = this.parseMaybeAssign();\n      this.expect(_tokentype.types.bracketR);\n      return prop.key;\n    } else {\n      prop.computed = false;\n    }\n  }\n  return prop.key = this.type === _tokentype.types.num || this.type === _tokentype.types.string ? this.parseExprAtom() : this.parseIdent(true);\n};\n\n// Initialize empty function node.\n\npp.initFunction = function (node) {\n  node.id = null;\n  if (this.options.ecmaVersion >= 6) {\n    node.generator = false;\n    node.expression = false;\n  }\n};\n\n// Parse object or class method.\n\npp.parseMethod = function (isGenerator) {\n  var node = this.startNode();\n  this.initFunction(node);\n  this.expect(_tokentype.types.parenL);\n  node.params = this.parseBindingList(_tokentype.types.parenR, false, false);\n  var allowExpressionBody = undefined;\n  if (this.options.ecmaVersion >= 6) {\n    node.generator = isGenerator;\n  }\n  this.parseFunctionBody(node, false);\n  return this.finishNode(node, \"FunctionExpression\");\n};\n\n// Parse arrow function expression with given parameters.\n\npp.parseArrowExpression = function (node, params) {\n  this.initFunction(node);\n  node.params = this.toAssignableList(params, true);\n  this.parseFunctionBody(node, true);\n  return this.finishNode(node, \"ArrowFunctionExpression\");\n};\n\n// Parse function body and check parameters.\n\npp.parseFunctionBody = function (node, allowExpression) {\n  var isExpression = allowExpression && this.type !== _tokentype.types.braceL;\n\n  if (isExpression) {\n    node.body = this.parseMaybeAssign();\n    node.expression = true;\n  } else {\n    // Start a new scope with regard to labels and the `inFunction`\n    // flag (restore them to their old value afterwards).\n    var oldInFunc = this.inFunction,\n        oldInGen = this.inGenerator,\n        oldLabels = this.labels;\n    this.inFunction = true;this.inGenerator = node.generator;this.labels = [];\n    node.body = this.parseBlock(true);\n    node.expression = false;\n    this.inFunction = oldInFunc;this.inGenerator = oldInGen;this.labels = oldLabels;\n  }\n\n  // If this is a strict mode function, verify that argument names\n  // are not repeated, and it does not try to bind the words `eval`\n  // or `arguments`.\n  if (this.strict || !isExpression && node.body.body.length && this.isUseStrict(node.body.body[0])) {\n    var nameHash = {},\n        oldStrict = this.strict;\n    this.strict = true;\n    if (node.id) this.checkLVal(node.id, true);\n    for (var i = 0; i < node.params.length; i++) {\n      this.checkLVal(node.params[i], true, nameHash);\n    }this.strict = oldStrict;\n  }\n};\n\n// Parses a comma-separated list of expressions, and returns them as\n// an array. `close` is the token type that ends the list, and\n// `allowEmpty` can be turned on to allow subsequent commas with\n// nothing in between them to be parsed as `null` (which is needed\n// for array literals).\n\npp.parseExprList = function (close, allowTrailingComma, allowEmpty, refShorthandDefaultPos) {\n  var elts = [],\n      first = true;\n  while (!this.eat(close)) {\n    if (!first) {\n      this.expect(_tokentype.types.comma);\n      if (allowTrailingComma && this.afterTrailingComma(close)) break;\n    } else first = false;\n\n    var elt = undefined;\n    if (allowEmpty && this.type === _tokentype.types.comma) elt = null;else if (this.type === _tokentype.types.ellipsis) elt = this.parseSpread(refShorthandDefaultPos);else elt = this.parseMaybeAssign(false, refShorthandDefaultPos);\n    elts.push(elt);\n  }\n  return elts;\n};\n\n// Parse the next token as an identifier. If `liberal` is true (used\n// when parsing properties), it will also convert keywords into\n// identifiers.\n\npp.parseIdent = function (liberal) {\n  var node = this.startNode();\n  if (liberal && this.options.allowReserved == \"never\") liberal = false;\n  if (this.type === _tokentype.types.name) {\n    if (!liberal && (!this.options.allowReserved && this.isReservedWord(this.value) || this.strict && _identifier.reservedWords.strict(this.value) && (this.options.ecmaVersion >= 6 || this.input.slice(this.start, this.end).indexOf(\"\\\\\") == -1))) this.raise(this.start, \"The keyword '\" + this.value + \"' is reserved\");\n    node.name = this.value;\n  } else if (liberal && this.type.keyword) {\n    node.name = this.type.keyword;\n  } else {\n    this.unexpected();\n  }\n  this.next();\n  return this.finishNode(node, \"Identifier\");\n};\n\n// Parses yield expression inside generator.\n\npp.parseYield = function () {\n  var node = this.startNode();\n  this.next();\n  if (this.type == _tokentype.types.semi || this.canInsertSemicolon() || this.type != _tokentype.types.star && !this.type.startsExpr) {\n    node.delegate = false;\n    node.argument = null;\n  } else {\n    node.delegate = this.eat(_tokentype.types.star);\n    node.argument = this.parseMaybeAssign();\n  }\n  return this.finishNode(node, \"YieldExpression\");\n};\n\n// Parses array and generator comprehensions.\n\npp.parseComprehension = function (node, isGenerator) {\n  node.blocks = [];\n  while (this.type === _tokentype.types._for) {\n    var block = this.startNode();\n    this.next();\n    this.expect(_tokentype.types.parenL);\n    block.left = this.parseBindingAtom();\n    this.checkLVal(block.left, true);\n    this.expectContextual(\"of\");\n    block.right = this.parseExpression();\n    this.expect(_tokentype.types.parenR);\n    node.blocks.push(this.finishNode(block, \"ComprehensionBlock\"));\n  }\n  node.filter = this.eat(_tokentype.types._if) ? this.parseParenExpression() : null;\n  node.body = this.parseExpression();\n  this.expect(isGenerator ? _tokentype.types.parenR : _tokentype.types.bracketR);\n  node.generator = isGenerator;\n  return this.finishNode(node, \"ComprehensionExpression\");\n};\n\n},{\"./identifier\":2,\"./state\":10,\"./tokentype\":14,\"./util\":15}],2:[function(_dereq_,module,exports){\n// This is a trick taken from Esprima. It turns out that, on\n// non-Chrome browsers, to check whether a string is in a set, a\n// predicate containing a big ugly `switch` statement is faster than\n// a regular expression, and on Chrome the two are about on par.\n// This function uses `eval` (non-lexical) to produce such a\n// predicate from a space-separated string of words.\n//\n// It starts by sorting the words by length.\n\n\"use strict\";\n\nexports.__esModule = true;\nexports.isIdentifierStart = isIdentifierStart;\nexports.isIdentifierChar = isIdentifierChar;\nfunction makePredicate(words) {\n  words = words.split(\" \");\n  var f = \"\",\n      cats = [];\n  out: for (var i = 0; i < words.length; ++i) {\n    for (var j = 0; j < cats.length; ++j) {\n      if (cats[j][0].length == words[i].length) {\n        cats[j].push(words[i]);\n        continue out;\n      }\n    }cats.push([words[i]]);\n  }\n  function compareTo(arr) {\n    if (arr.length == 1) return f += \"return str === \" + JSON.stringify(arr[0]) + \";\";\n    f += \"switch(str){\";\n    for (var i = 0; i < arr.length; ++i) {\n      f += \"case \" + JSON.stringify(arr[i]) + \":\";\n    }f += \"return true}return false;\";\n  }\n\n  // When there are more than three length categories, an outer\n  // switch first dispatches on the lengths, to save on comparisons.\n\n  if (cats.length > 3) {\n    cats.sort(function (a, b) {\n      return b.length - a.length;\n    });\n    f += \"switch(str.length){\";\n    for (var i = 0; i < cats.length; ++i) {\n      var cat = cats[i];\n      f += \"case \" + cat[0].length + \":\";\n      compareTo(cat);\n    }\n    f += \"}\"\n\n    // Otherwise, simply generate a flat `switch` statement.\n\n    ;\n  } else {\n    compareTo(words);\n  }\n  return new Function(\"str\", f);\n}\n\n// Reserved word lists for various dialects of the language\n\nvar reservedWords = {\n  3: makePredicate(\"abstract boolean byte char class double enum export extends final float goto implements import int interface long native package private protected public short static super synchronized throws transient volatile\"),\n  5: makePredicate(\"class enum extends super const export import\"),\n  6: makePredicate(\"enum await\"),\n  strict: makePredicate(\"implements interface let package private protected public static yield\"),\n  strictBind: makePredicate(\"eval arguments\")\n};\n\nexports.reservedWords = reservedWords;\n// And the keywords\n\nvar ecma5AndLessKeywords = \"break case catch continue debugger default do else finally for function if return switch throw try var while with null true false instanceof typeof void delete new in this\";\n\nvar keywords = {\n  5: makePredicate(ecma5AndLessKeywords),\n  6: makePredicate(ecma5AndLessKeywords + \" let const class extends export import yield super\")\n};\n\nexports.keywords = keywords;\n// ## Character categories\n\n// Big ugly regular expressions that match characters in the\n// whitespace, identifier, and identifier-start categories. These\n// are only applied when a character is found to actually have a\n// code point above 128.\n// Generated by `tools/generate-identifier-regex.js`.\n\nvar nonASCIIidentifierStartChars = \"-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------\";\nvar nonASCIIidentifierChars = \"-------------------------------------------------------------------------------------------------------------------------------------------------\";\n\nvar nonASCIIidentifierStart = new RegExp(\"[\" + nonASCIIidentifierStartChars + \"]\");\nvar nonASCIIidentifier = new RegExp(\"[\" + nonASCIIidentifierStartChars + nonASCIIidentifierChars + \"]\");\n\nnonASCIIidentifierStartChars = nonASCIIidentifierChars = null;\n\n// These are a run-length and offset encoded representation of the\n// >0xffff code points that are a valid part of identifiers. The\n// offset starts at 0x10000, and each pair of numbers represents an\n// offset to the next range, and then a size of the range. They were\n// generated by tools/generate-identifier-regex.js\nvar astralIdentifierStartCodes = [0, 11, 2, 25, 2, 18, 2, 1, 2, 14, 3, 13, 35, 122, 70, 52, 268, 28, 4, 48, 48, 31, 17, 26, 6, 37, 11, 29, 3, 35, 5, 7, 2, 4, 43, 157, 99, 39, 9, 51, 157, 310, 10, 21, 11, 7, 153, 5, 3, 0, 2, 43, 2, 1, 4, 0, 3, 22, 11, 22, 10, 30, 98, 21, 11, 25, 71, 55, 7, 1, 65, 0, 16, 3, 2, 2, 2, 26, 45, 28, 4, 28, 36, 7, 2, 27, 28, 53, 11, 21, 11, 18, 14, 17, 111, 72, 955, 52, 76, 44, 33, 24, 27, 35, 42, 34, 4, 0, 13, 47, 15, 3, 22, 0, 38, 17, 2, 24, 133, 46, 39, 7, 3, 1, 3, 21, 2, 6, 2, 1, 2, 4, 4, 0, 32, 4, 287, 47, 21, 1, 2, 0, 185, 46, 82, 47, 21, 0, 60, 42, 502, 63, 32, 0, 449, 56, 1288, 920, 104, 110, 2962, 1070, 13266, 568, 8, 30, 114, 29, 19, 47, 17, 3, 32, 20, 6, 18, 881, 68, 12, 0, 67, 12, 16481, 1, 3071, 106, 6, 12, 4, 8, 8, 9, 5991, 84, 2, 70, 2, 1, 3, 0, 3, 1, 3, 3, 2, 11, 2, 0, 2, 6, 2, 64, 2, 3, 3, 7, 2, 6, 2, 27, 2, 3, 2, 4, 2, 0, 4, 6, 2, 339, 3, 24, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 7, 4149, 196, 1340, 3, 2, 26, 2, 1, 2, 0, 3, 0, 2, 9, 2, 3, 2, 0, 2, 0, 7, 0, 5, 0, 2, 0, 2, 0, 2, 2, 2, 1, 2, 0, 3, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 1, 2, 0, 3, 3, 2, 6, 2, 3, 2, 3, 2, 0, 2, 9, 2, 16, 6, 2, 2, 4, 2, 16, 4421, 42710, 42, 4148, 12, 221, 16355, 541];\nvar astralIdentifierCodes = [509, 0, 227, 0, 150, 4, 294, 9, 1368, 2, 2, 1, 6, 3, 41, 2, 5, 0, 166, 1, 1306, 2, 54, 14, 32, 9, 16, 3, 46, 10, 54, 9, 7, 2, 37, 13, 2, 9, 52, 0, 13, 2, 49, 13, 16, 9, 83, 11, 168, 11, 6, 9, 8, 2, 57, 0, 2, 6, 3, 1, 3, 2, 10, 0, 11, 1, 3, 6, 4, 4, 316, 19, 13, 9, 214, 6, 3, 8, 112, 16, 16, 9, 82, 12, 9, 9, 535, 9, 20855, 9, 135, 4, 60, 6, 26, 9, 1016, 45, 17, 3, 19723, 1, 5319, 4, 4, 5, 9, 7, 3, 6, 31, 3, 149, 2, 1418, 49, 4305, 6, 792618, 239];\n\n// This has a complexity linear to the value of the code. The\n// assumption is that looking up astral identifier characters is\n// rare.\nfunction isInAstralSet(code, set) {\n  var pos = 0x10000;\n  for (var i = 0; i < set.length; i += 2) {\n    pos += set[i];\n    if (pos > code) return false;\n    pos += set[i + 1];\n    if (pos >= code) return true;\n  }\n}\n\n// Test whether a given character code starts an identifier.\n\nfunction isIdentifierStart(code, astral) {\n  if (code < 65) return code === 36;\n  if (code < 91) return true;\n  if (code < 97) return code === 95;\n  if (code < 123) return true;\n  if (code <= 0xffff) return code >= 0xaa && nonASCIIidentifierStart.test(String.fromCharCode(code));\n  if (astral === false) return false;\n  return isInAstralSet(code, astralIdentifierStartCodes);\n}\n\n// Test whether a given character is part of an identifier.\n\nfunction isIdentifierChar(code, astral) {\n  if (code < 48) return code === 36;\n  if (code < 58) return true;\n  if (code < 65) return false;\n  if (code < 91) return true;\n  if (code < 97) return code === 95;\n  if (code < 123) return true;\n  if (code <= 0xffff) return code >= 0xaa && nonASCIIidentifier.test(String.fromCharCode(code));\n  if (astral === false) return false;\n  return isInAstralSet(code, astralIdentifierStartCodes) || isInAstralSet(code, astralIdentifierCodes);\n}\n\n},{}],3:[function(_dereq_,module,exports){\n// Acorn is a tiny, fast JavaScript parser written in JavaScript.\n//\n// Acorn was written by Marijn Haverbeke, Ingvar Stepanyan, and\n// various contributors and released under an MIT license.\n//\n// Git repositories for Acorn are available at\n//\n//     http://marijnhaverbeke.nl/git/acorn\n//     https://github.com/marijnh/acorn.git\n//\n// Please use the [github bug tracker][ghbt] to report issues.\n//\n// [ghbt]: https://github.com/marijnh/acorn/issues\n//\n// This file defines the main parser interface. The library also comes\n// with a [error-tolerant parser][dammit] and an\n// [abstract syntax tree walker][walk], defined in other files.\n//\n// [dammit]: acorn_loose.js\n// [walk]: util/walk.js\n\n\"use strict\";\n\nexports.__esModule = true;\nexports.parse = parse;\nexports.parseExpressionAt = parseExpressionAt;\nexports.tokenizer = tokenizer;\n\nvar _state = _dereq_(\"./state\");\n\nvar _options = _dereq_(\"./options\");\n\n_dereq_(\"./parseutil\");\n\n_dereq_(\"./statement\");\n\n_dereq_(\"./lval\");\n\n_dereq_(\"./expression\");\n\n_dereq_(\"./location\");\n\nexports.Parser = _state.Parser;\nexports.plugins = _state.plugins;\nexports.defaultOptions = _options.defaultOptions;\n\nvar _locutil = _dereq_(\"./locutil\");\n\nexports.Position = _locutil.Position;\nexports.SourceLocation = _locutil.SourceLocation;\nexports.getLineInfo = _locutil.getLineInfo;\n\nvar _node = _dereq_(\"./node\");\n\nexports.Node = _node.Node;\n\nvar _tokentype = _dereq_(\"./tokentype\");\n\nexports.TokenType = _tokentype.TokenType;\nexports.tokTypes = _tokentype.types;\n\nvar _tokencontext = _dereq_(\"./tokencontext\");\n\nexports.TokContext = _tokencontext.TokContext;\nexports.tokContexts = _tokencontext.types;\n\nvar _identifier = _dereq_(\"./identifier\");\n\nexports.isIdentifierChar = _identifier.isIdentifierChar;\nexports.isIdentifierStart = _identifier.isIdentifierStart;\n\nvar _tokenize = _dereq_(\"./tokenize\");\n\nexports.Token = _tokenize.Token;\n\nvar _whitespace = _dereq_(\"./whitespace\");\n\nexports.isNewLine = _whitespace.isNewLine;\nexports.lineBreak = _whitespace.lineBreak;\nexports.lineBreakG = _whitespace.lineBreakG;\nvar version = \"2.4.0\";\n\nexports.version = version;\n// The main exported interface (under `self.acorn` when in the\n// browser) is a `parse` function that takes a code string and\n// returns an abstract syntax tree as specified by [Mozilla parser\n// API][api].\n//\n// [api]: https://developer.mozilla.org/en-US/docs/SpiderMonkey/Parser_API\n\nfunction parse(input, options) {\n  return new _state.Parser(options, input).parse();\n}\n\n// This function tries to parse a single expression at a given\n// offset in a string. Useful for parsing mixed-language formats\n// that embed JavaScript expressions.\n\nfunction parseExpressionAt(input, pos, options) {\n  var p = new _state.Parser(options, input, pos);\n  p.nextToken();\n  return p.parseExpression();\n}\n\n// Acorn is organized as a tokenizer and a recursive-descent parser.\n// The `tokenize` export provides an interface to the tokenizer.\n\nfunction tokenizer(input, options) {\n  return new _state.Parser(options, input);\n}\n\n},{\"./expression\":1,\"./identifier\":2,\"./location\":4,\"./locutil\":5,\"./lval\":6,\"./node\":7,\"./options\":8,\"./parseutil\":9,\"./state\":10,\"./statement\":11,\"./tokencontext\":12,\"./tokenize\":13,\"./tokentype\":14,\"./whitespace\":16}],4:[function(_dereq_,module,exports){\n\"use strict\";\n\nvar _state = _dereq_(\"./state\");\n\nvar _locutil = _dereq_(\"./locutil\");\n\nvar pp = _state.Parser.prototype;\n\n// This function is used to raise exceptions on parse errors. It\n// takes an offset integer (into the current `input`) to indicate\n// the location of the error, attaches the position to the end\n// of the error message, and then raises a `SyntaxError` with that\n// message.\n\npp.raise = function (pos, message) {\n  var loc = _locutil.getLineInfo(this.input, pos);\n  message += \" (\" + loc.line + \":\" + loc.column + \")\";\n  var err = new SyntaxError(message);\n  err.pos = pos;err.loc = loc;err.raisedAt = this.pos;\n  throw err;\n};\n\npp.curPosition = function () {\n  if (this.options.locations) {\n    return new _locutil.Position(this.curLine, this.pos - this.lineStart);\n  }\n};\n\n},{\"./locutil\":5,\"./state\":10}],5:[function(_dereq_,module,exports){\n\"use strict\";\n\nexports.__esModule = true;\nexports.getLineInfo = getLineInfo;\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar _whitespace = _dereq_(\"./whitespace\");\n\n// These are used when `options.locations` is on, for the\n// `startLoc` and `endLoc` properties.\n\nvar Position = (function () {\n  function Position(line, col) {\n    _classCallCheck(this, Position);\n\n    this.line = line;\n    this.column = col;\n  }\n\n  Position.prototype.offset = function offset(n) {\n    return new Position(this.line, this.column + n);\n  };\n\n  return Position;\n})();\n\nexports.Position = Position;\n\nvar SourceLocation = function SourceLocation(p, start, end) {\n  _classCallCheck(this, SourceLocation);\n\n  this.start = start;\n  this.end = end;\n  if (p.sourceFile !== null) this.source = p.sourceFile;\n};\n\nexports.SourceLocation = SourceLocation;\n\n// The `getLineInfo` function is mostly useful when the\n// `locations` option is off (for performance reasons) and you\n// want to find the line/column position for a given character\n// offset. `input` should be the code string that the offset refers\n// into.\n\nfunction getLineInfo(input, offset) {\n  for (var line = 1, cur = 0;;) {\n    _whitespace.lineBreakG.lastIndex = cur;\n    var match = _whitespace.lineBreakG.exec(input);\n    if (match && match.index < offset) {\n      ++line;\n      cur = match.index + match[0].length;\n    } else {\n      return new Position(line, offset - cur);\n    }\n  }\n}\n\n},{\"./whitespace\":16}],6:[function(_dereq_,module,exports){\n\"use strict\";\n\nvar _tokentype = _dereq_(\"./tokentype\");\n\nvar _state = _dereq_(\"./state\");\n\nvar _identifier = _dereq_(\"./identifier\");\n\nvar _util = _dereq_(\"./util\");\n\nvar pp = _state.Parser.prototype;\n\n// Convert existing expression atom to assignable pattern\n// if possible.\n\npp.toAssignable = function (node, isBinding) {\n  if (this.options.ecmaVersion >= 6 && node) {\n    switch (node.type) {\n      case \"Identifier\":\n      case \"ObjectPattern\":\n      case \"ArrayPattern\":\n      case \"AssignmentPattern\":\n        break;\n\n      case \"ObjectExpression\":\n        node.type = \"ObjectPattern\";\n        for (var i = 0; i < node.properties.length; i++) {\n          var prop = node.properties[i];\n          if (prop.kind !== \"init\") this.raise(prop.key.start, \"Object pattern can't contain getter or setter\");\n          this.toAssignable(prop.value, isBinding);\n        }\n        break;\n\n      case \"ArrayExpression\":\n        node.type = \"ArrayPattern\";\n        this.toAssignableList(node.elements, isBinding);\n        break;\n\n      case \"AssignmentExpression\":\n        if (node.operator === \"=\") {\n          node.type = \"AssignmentPattern\";\n          delete node.operator;\n        } else {\n          this.raise(node.left.end, \"Only '=' operator can be used for specifying default value.\");\n        }\n        break;\n\n      case \"ParenthesizedExpression\":\n        node.expression = this.toAssignable(node.expression, isBinding);\n        break;\n\n      case \"MemberExpression\":\n        if (!isBinding) break;\n\n      default:\n        this.raise(node.start, \"Assigning to rvalue\");\n    }\n  }\n  return node;\n};\n\n// Convert list of expression atoms to binding list.\n\npp.toAssignableList = function (exprList, isBinding) {\n  var end = exprList.length;\n  if (end) {\n    var last = exprList[end - 1];\n    if (last && last.type == \"RestElement\") {\n      --end;\n    } else if (last && last.type == \"SpreadElement\") {\n      last.type = \"RestElement\";\n      var arg = last.argument;\n      this.toAssignable(arg, isBinding);\n      if (arg.type !== \"Identifier\" && arg.type !== \"MemberExpression\" && arg.type !== \"ArrayPattern\") this.unexpected(arg.start);\n      --end;\n    }\n  }\n  for (var i = 0; i < end; i++) {\n    var elt = exprList[i];\n    if (elt) this.toAssignable(elt, isBinding);\n  }\n  return exprList;\n};\n\n// Parses spread element.\n\npp.parseSpread = function (refShorthandDefaultPos) {\n  var node = this.startNode();\n  this.next();\n  node.argument = this.parseMaybeAssign(refShorthandDefaultPos);\n  return this.finishNode(node, \"SpreadElement\");\n};\n\npp.parseRest = function () {\n  var node = this.startNode();\n  this.next();\n  node.argument = this.type === _tokentype.types.name || this.type === _tokentype.types.bracketL ? this.parseBindingAtom() : this.unexpected();\n  return this.finishNode(node, \"RestElement\");\n};\n\n// Parses lvalue (assignable) atom.\n\npp.parseBindingAtom = function () {\n  if (this.options.ecmaVersion < 6) return this.parseIdent();\n  switch (this.type) {\n    case _tokentype.types.name:\n      return this.parseIdent();\n\n    case _tokentype.types.bracketL:\n      var node = this.startNode();\n      this.next();\n      node.elements = this.parseBindingList(_tokentype.types.bracketR, true, true);\n      return this.finishNode(node, \"ArrayPattern\");\n\n    case _tokentype.types.braceL:\n      return this.parseObj(true);\n\n    default:\n      this.unexpected();\n  }\n};\n\npp.parseBindingList = function (close, allowEmpty, allowTrailingComma) {\n  var elts = [],\n      first = true;\n  while (!this.eat(close)) {\n    if (first) first = false;else this.expect(_tokentype.types.comma);\n    if (allowEmpty && this.type === _tokentype.types.comma) {\n      elts.push(null);\n    } else if (allowTrailingComma && this.afterTrailingComma(close)) {\n      break;\n    } else if (this.type === _tokentype.types.ellipsis) {\n      var rest = this.parseRest();\n      this.parseBindingListItem(rest);\n      elts.push(rest);\n      this.expect(close);\n      break;\n    } else {\n      var elem = this.parseMaybeDefault(this.start, this.startLoc);\n      this.parseBindingListItem(elem);\n      elts.push(elem);\n    }\n  }\n  return elts;\n};\n\npp.parseBindingListItem = function (param) {\n  return param;\n};\n\n// Parses assignment pattern around given atom if possible.\n\npp.parseMaybeDefault = function (startPos, startLoc, left) {\n  left = left || this.parseBindingAtom();\n  if (this.options.ecmaVersion < 6 || !this.eat(_tokentype.types.eq)) return left;\n  var node = this.startNodeAt(startPos, startLoc);\n  node.left = left;\n  node.right = this.parseMaybeAssign();\n  return this.finishNode(node, \"AssignmentPattern\");\n};\n\n// Verify that a node is an lval  something that can be assigned\n// to.\n\npp.checkLVal = function (expr, isBinding, checkClashes) {\n  switch (expr.type) {\n    case \"Identifier\":\n      if (this.strict && (_identifier.reservedWords.strictBind(expr.name) || _identifier.reservedWords.strict(expr.name))) this.raise(expr.start, (isBinding ? \"Binding \" : \"Assigning to \") + expr.name + \" in strict mode\");\n      if (checkClashes) {\n        if (_util.has(checkClashes, expr.name)) this.raise(expr.start, \"Argument name clash in strict mode\");\n        checkClashes[expr.name] = true;\n      }\n      break;\n\n    case \"MemberExpression\":\n      if (isBinding) this.raise(expr.start, (isBinding ? \"Binding\" : \"Assigning to\") + \" member expression\");\n      break;\n\n    case \"ObjectPattern\":\n      for (var i = 0; i < expr.properties.length; i++) {\n        this.checkLVal(expr.properties[i].value, isBinding, checkClashes);\n      }break;\n\n    case \"ArrayPattern\":\n      for (var i = 0; i < expr.elements.length; i++) {\n        var elem = expr.elements[i];\n        if (elem) this.checkLVal(elem, isBinding, checkClashes);\n      }\n      break;\n\n    case \"AssignmentPattern\":\n      this.checkLVal(expr.left, isBinding, checkClashes);\n      break;\n\n    case \"RestElement\":\n      this.checkLVal(expr.argument, isBinding, checkClashes);\n      break;\n\n    case \"ParenthesizedExpression\":\n      this.checkLVal(expr.expression, isBinding, checkClashes);\n      break;\n\n    default:\n      this.raise(expr.start, (isBinding ? \"Binding\" : \"Assigning to\") + \" rvalue\");\n  }\n};\n\n},{\"./identifier\":2,\"./state\":10,\"./tokentype\":14,\"./util\":15}],7:[function(_dereq_,module,exports){\n\"use strict\";\n\nexports.__esModule = true;\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar _state = _dereq_(\"./state\");\n\nvar _locutil = _dereq_(\"./locutil\");\n\nvar Node = function Node(parser, pos, loc) {\n  _classCallCheck(this, Node);\n\n  this.type = \"\";\n  this.start = pos;\n  this.end = 0;\n  if (parser.options.locations) this.loc = new _locutil.SourceLocation(parser, loc);\n  if (parser.options.directSourceFile) this.sourceFile = parser.options.directSourceFile;\n  if (parser.options.ranges) this.range = [pos, 0];\n};\n\nexports.Node = Node;\n\n// Start an AST node, attaching a start offset.\n\nvar pp = _state.Parser.prototype;\n\npp.startNode = function () {\n  return new Node(this, this.start, this.startLoc);\n};\n\npp.startNodeAt = function (pos, loc) {\n  return new Node(this, pos, loc);\n};\n\n// Finish an AST node, adding `type` and `end` properties.\n\nfunction finishNodeAt(node, type, pos, loc) {\n  node.type = type;\n  node.end = pos;\n  if (this.options.locations) node.loc.end = loc;\n  if (this.options.ranges) node.range[1] = pos;\n  return node;\n}\n\npp.finishNode = function (node, type) {\n  return finishNodeAt.call(this, node, type, this.lastTokEnd, this.lastTokEndLoc);\n};\n\n// Finish node at given position\n\npp.finishNodeAt = function (node, type, pos, loc) {\n  return finishNodeAt.call(this, node, type, pos, loc);\n};\n\n},{\"./locutil\":5,\"./state\":10}],8:[function(_dereq_,module,exports){\n\"use strict\";\n\nexports.__esModule = true;\nexports.getOptions = getOptions;\n\nvar _util = _dereq_(\"./util\");\n\nvar _locutil = _dereq_(\"./locutil\");\n\n// A second optional argument can be given to further configure\n// the parser process. These options are recognized:\n\nvar defaultOptions = {\n  // `ecmaVersion` indicates the ECMAScript version to parse. Must\n  // be either 3, or 5, or 6. This influences support for strict\n  // mode, the set of reserved words, support for getters and\n  // setters and other features.\n  ecmaVersion: 5,\n  // Source type (\"script\" or \"module\") for different semantics\n  sourceType: \"script\",\n  // `onInsertedSemicolon` can be a callback that will be called\n  // when a semicolon is automatically inserted. It will be passed\n  // th position of the comma as an offset, and if `locations` is\n  // enabled, it is given the location as a `{line, column}` object\n  // as second argument.\n  onInsertedSemicolon: null,\n  // `onTrailingComma` is similar to `onInsertedSemicolon`, but for\n  // trailing commas.\n  onTrailingComma: null,\n  // By default, reserved words are not enforced. Disable\n  // `allowReserved` to enforce them. When this option has the\n  // value \"never\", reserved words and keywords can also not be\n  // used as property names.\n  allowReserved: true,\n  // When enabled, a return at the top level is not considered an\n  // error.\n  allowReturnOutsideFunction: false,\n  // When enabled, import/export statements are not constrained to\n  // appearing at the top of the program.\n  allowImportExportEverywhere: false,\n  // When enabled, hashbang directive in the beginning of file\n  // is allowed and treated as a line comment.\n  allowHashBang: false,\n  // When `locations` is on, `loc` properties holding objects with\n  // `start` and `end` properties in `{line, column}` form (with\n  // line being 1-based and column 0-based) will be attached to the\n  // nodes.\n  locations: false,\n  // A function can be passed as `onToken` option, which will\n  // cause Acorn to call that function with object in the same\n  // format as tokenize() returns. Note that you are not\n  // allowed to call the parser from the callbackthat will\n  // corrupt its internal state.\n  onToken: null,\n  // A function can be passed as `onComment` option, which will\n  // cause Acorn to call that function with `(block, text, start,\n  // end)` parameters whenever a comment is skipped. `block` is a\n  // boolean indicating whether this is a block (`/* */`) comment,\n  // `text` is the content of the comment, and `start` and `end` are\n  // character offsets that denote the start and end of the comment.\n  // When the `locations` option is on, two more parameters are\n  // passed, the full `{line, column}` locations of the start and\n  // end of the comments. Note that you are not allowed to call the\n  // parser from the callbackthat will corrupt its internal state.\n  onComment: null,\n  // Nodes have their start and end characters offsets recorded in\n  // `start` and `end` properties (directly on the node, rather than\n  // the `loc` object, which holds line/column data. To also add a\n  // [semi-standardized][range] `range` property holding a `[start,\n  // end]` array with the same numbers, set the `ranges` option to\n  // `true`.\n  //\n  // [range]: https://bugzilla.mozilla.org/show_bug.cgi?id=745678\n  ranges: false,\n  // It is possible to parse multiple files into a single AST by\n  // passing the tree produced by parsing the first file as\n  // `program` option in subsequent parses. This will add the\n  // toplevel forms of the parsed file to the `Program` (top) node\n  // of an existing parse tree.\n  program: null,\n  // When `locations` is on, you can pass this to record the source\n  // file in every node's `loc` object.\n  sourceFile: null,\n  // This value, if given, is stored in every node, whether\n  // `locations` is on or off.\n  directSourceFile: null,\n  // When enabled, parenthesized expressions are represented by\n  // (non-standard) ParenthesizedExpression nodes\n  preserveParens: false,\n  plugins: {}\n};\n\nexports.defaultOptions = defaultOptions;\n// Interpret and default an options object\n\nfunction getOptions(opts) {\n  var options = {};\n  for (var opt in defaultOptions) {\n    options[opt] = opts && _util.has(opts, opt) ? opts[opt] : defaultOptions[opt];\n  }if (_util.isArray(options.onToken)) {\n    (function () {\n      var tokens = options.onToken;\n      options.onToken = function (token) {\n        return tokens.push(token);\n      };\n    })();\n  }\n  if (_util.isArray(options.onComment)) options.onComment = pushComment(options, options.onComment);\n\n  return options;\n}\n\nfunction pushComment(options, array) {\n  return function (block, text, start, end, startLoc, endLoc) {\n    var comment = {\n      type: block ? \"Block\" : \"Line\",\n      value: text,\n      start: start,\n      end: end\n    };\n    if (options.locations) comment.loc = new _locutil.SourceLocation(this, startLoc, endLoc);\n    if (options.ranges) comment.range = [start, end];\n    array.push(comment);\n  };\n}\n\n},{\"./locutil\":5,\"./util\":15}],9:[function(_dereq_,module,exports){\n\"use strict\";\n\nvar _tokentype = _dereq_(\"./tokentype\");\n\nvar _state = _dereq_(\"./state\");\n\nvar _whitespace = _dereq_(\"./whitespace\");\n\nvar pp = _state.Parser.prototype;\n\n// ## Parser utilities\n\n// Test whether a statement node is the string literal `\"use strict\"`.\n\npp.isUseStrict = function (stmt) {\n  return this.options.ecmaVersion >= 5 && stmt.type === \"ExpressionStatement\" && stmt.expression.type === \"Literal\" && stmt.expression.raw.slice(1, -1) === \"use strict\";\n};\n\n// Predicate that tests whether the next token is of the given\n// type, and if yes, consumes it as a side effect.\n\npp.eat = function (type) {\n  if (this.type === type) {\n    this.next();\n    return true;\n  } else {\n    return false;\n  }\n};\n\n// Tests whether parsed token is a contextual keyword.\n\npp.isContextual = function (name) {\n  return this.type === _tokentype.types.name && this.value === name;\n};\n\n// Consumes contextual keyword if possible.\n\npp.eatContextual = function (name) {\n  return this.value === name && this.eat(_tokentype.types.name);\n};\n\n// Asserts that following token is given contextual keyword.\n\npp.expectContextual = function (name) {\n  if (!this.eatContextual(name)) this.unexpected();\n};\n\n// Test whether a semicolon can be inserted at the current position.\n\npp.canInsertSemicolon = function () {\n  return this.type === _tokentype.types.eof || this.type === _tokentype.types.braceR || _whitespace.lineBreak.test(this.input.slice(this.lastTokEnd, this.start));\n};\n\npp.insertSemicolon = function () {\n  if (this.canInsertSemicolon()) {\n    if (this.options.onInsertedSemicolon) this.options.onInsertedSemicolon(this.lastTokEnd, this.lastTokEndLoc);\n    return true;\n  }\n};\n\n// Consume a semicolon, or, failing that, see if we are allowed to\n// pretend that there is a semicolon at this position.\n\npp.semicolon = function () {\n  if (!this.eat(_tokentype.types.semi) && !this.insertSemicolon()) this.unexpected();\n};\n\npp.afterTrailingComma = function (tokType) {\n  if (this.type == tokType) {\n    if (this.options.onTrailingComma) this.options.onTrailingComma(this.lastTokStart, this.lastTokStartLoc);\n    this.next();\n    return true;\n  }\n};\n\n// Expect a token of a given type. If found, consume it, otherwise,\n// raise an unexpected token error.\n\npp.expect = function (type) {\n  this.eat(type) || this.unexpected();\n};\n\n// Raise an unexpected token error.\n\npp.unexpected = function (pos) {\n  this.raise(pos != null ? pos : this.start, \"Unexpected token\");\n};\n\n},{\"./state\":10,\"./tokentype\":14,\"./whitespace\":16}],10:[function(_dereq_,module,exports){\n\"use strict\";\n\nexports.__esModule = true;\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar _identifier = _dereq_(\"./identifier\");\n\nvar _tokentype = _dereq_(\"./tokentype\");\n\nvar _whitespace = _dereq_(\"./whitespace\");\n\nvar _options = _dereq_(\"./options\");\n\n// Registered plugins\nvar plugins = {};\n\nexports.plugins = plugins;\n\nvar Parser = (function () {\n  function Parser(options, input, startPos) {\n    _classCallCheck(this, Parser);\n\n    this.options = _options.getOptions(options);\n    this.sourceFile = this.options.sourceFile;\n    this.isKeyword = _identifier.keywords[this.options.ecmaVersion >= 6 ? 6 : 5];\n    this.isReservedWord = _identifier.reservedWords[this.options.ecmaVersion];\n    this.input = String(input);\n\n    // Used to signal to callers of `readWord1` whether the word\n    // contained any escape sequences. This is needed because words with\n    // escape sequences must not be interpreted as keywords.\n    this.containsEsc = false;\n\n    // Load plugins\n    this.loadPlugins(this.options.plugins);\n\n    // Set up token state\n\n    // The current position of the tokenizer in the input.\n    if (startPos) {\n      this.pos = startPos;\n      this.lineStart = Math.max(0, this.input.lastIndexOf(\"\\n\", startPos));\n      this.curLine = this.input.slice(0, this.lineStart).split(_whitespace.lineBreak).length;\n    } else {\n      this.pos = this.lineStart = 0;\n      this.curLine = 1;\n    }\n\n    // Properties of the current token:\n    // Its type\n    this.type = _tokentype.types.eof;\n    // For tokens that include more information than their type, the value\n    this.value = null;\n    // Its start and end offset\n    this.start = this.end = this.pos;\n    // And, if locations are used, the {line, column} object\n    // corresponding to those offsets\n    this.startLoc = this.endLoc = this.curPosition();\n\n    // Position information for the previous token\n    this.lastTokEndLoc = this.lastTokStartLoc = null;\n    this.lastTokStart = this.lastTokEnd = this.pos;\n\n    // The context stack is used to superficially track syntactic\n    // context to predict whether a regular expression is allowed in a\n    // given position.\n    this.context = this.initialContext();\n    this.exprAllowed = true;\n\n    // Figure out if it's a module code.\n    this.strict = this.inModule = this.options.sourceType === \"module\";\n\n    // Used to signify the start of a potential arrow function\n    this.potentialArrowAt = -1;\n\n    // Flags to track whether we are in a function, a generator.\n    this.inFunction = this.inGenerator = false;\n    // Labels in scope.\n    this.labels = [];\n\n    // If enabled, skip leading hashbang line.\n    if (this.pos === 0 && this.options.allowHashBang && this.input.slice(0, 2) === \"#!\") this.skipLineComment(2);\n  }\n\n  Parser.prototype.extend = function extend(name, f) {\n    this[name] = f(this[name]);\n  };\n\n  Parser.prototype.loadPlugins = function loadPlugins(pluginConfigs) {\n    for (var _name in pluginConfigs) {\n      var plugin = plugins[_name];\n      if (!plugin) throw new Error(\"Plugin '\" + _name + \"' not found\");\n      plugin(this, pluginConfigs[_name]);\n    }\n  };\n\n  Parser.prototype.parse = function parse() {\n    var node = this.options.program || this.startNode();\n    this.nextToken();\n    return this.parseTopLevel(node);\n  };\n\n  return Parser;\n})();\n\nexports.Parser = Parser;\n\n},{\"./identifier\":2,\"./options\":8,\"./tokentype\":14,\"./whitespace\":16}],11:[function(_dereq_,module,exports){\n\"use strict\";\n\nvar _tokentype = _dereq_(\"./tokentype\");\n\nvar _state = _dereq_(\"./state\");\n\nvar _whitespace = _dereq_(\"./whitespace\");\n\nvar pp = _state.Parser.prototype;\n\n// ### Statement parsing\n\n// Parse a program. Initializes the parser, reads any number of\n// statements, and wraps them in a Program node.  Optionally takes a\n// `program` argument.  If present, the statements will be appended\n// to its body instead of creating a new node.\n\npp.parseTopLevel = function (node) {\n  var first = true;\n  if (!node.body) node.body = [];\n  while (this.type !== _tokentype.types.eof) {\n    var stmt = this.parseStatement(true, true);\n    node.body.push(stmt);\n    if (first) {\n      if (this.isUseStrict(stmt)) this.setStrict(true);\n      first = false;\n    }\n  }\n  this.next();\n  if (this.options.ecmaVersion >= 6) {\n    node.sourceType = this.options.sourceType;\n  }\n  return this.finishNode(node, \"Program\");\n};\n\nvar loopLabel = { kind: \"loop\" },\n    switchLabel = { kind: \"switch\" };\n\n// Parse a single statement.\n//\n// If expecting a statement and finding a slash operator, parse a\n// regular expression literal. This is to handle cases like\n// `if (foo) /blah/.exec(foo)`, where looking at the previous token\n// does not help.\n\npp.parseStatement = function (declaration, topLevel) {\n  var starttype = this.type,\n      node = this.startNode();\n\n  // Most types of statements are recognized by the keyword they\n  // start with. Many are trivial to parse, some require a bit of\n  // complexity.\n\n  switch (starttype) {\n    case _tokentype.types._break:case _tokentype.types._continue:\n      return this.parseBreakContinueStatement(node, starttype.keyword);\n    case _tokentype.types._debugger:\n      return this.parseDebuggerStatement(node);\n    case _tokentype.types._do:\n      return this.parseDoStatement(node);\n    case _tokentype.types._for:\n      return this.parseForStatement(node);\n    case _tokentype.types._function:\n      if (!declaration && this.options.ecmaVersion >= 6) this.unexpected();\n      return this.parseFunctionStatement(node);\n    case _tokentype.types._class:\n      if (!declaration) this.unexpected();\n      return this.parseClass(node, true);\n    case _tokentype.types._if:\n      return this.parseIfStatement(node);\n    case _tokentype.types._return:\n      return this.parseReturnStatement(node);\n    case _tokentype.types._switch:\n      return this.parseSwitchStatement(node);\n    case _tokentype.types._throw:\n      return this.parseThrowStatement(node);\n    case _tokentype.types._try:\n      return this.parseTryStatement(node);\n    case _tokentype.types._let:case _tokentype.types._const:\n      if (!declaration) this.unexpected(); // NOTE: falls through to _var\n    case _tokentype.types._var:\n      return this.parseVarStatement(node, starttype);\n    case _tokentype.types._while:\n      return this.parseWhileStatement(node);\n    case _tokentype.types._with:\n      return this.parseWithStatement(node);\n    case _tokentype.types.braceL:\n      return this.parseBlock();\n    case _tokentype.types.semi:\n      return this.parseEmptyStatement(node);\n    case _tokentype.types._export:\n    case _tokentype.types._import:\n      if (!this.options.allowImportExportEverywhere) {\n        if (!topLevel) this.raise(this.start, \"'import' and 'export' may only appear at the top level\");\n        if (!this.inModule) this.raise(this.start, \"'import' and 'export' may appear only with 'sourceType: module'\");\n      }\n      return starttype === _tokentype.types._import ? this.parseImport(node) : this.parseExport(node);\n\n    // If the statement does not start with a statement keyword or a\n    // brace, it's an ExpressionStatement or LabeledStatement. We\n    // simply start parsing an expression, and afterwards, if the\n    // next token is a colon and the expression was a simple\n    // Identifier node, we switch to interpreting it as a label.\n    default:\n      var maybeName = this.value,\n          expr = this.parseExpression();\n      if (starttype === _tokentype.types.name && expr.type === \"Identifier\" && this.eat(_tokentype.types.colon)) return this.parseLabeledStatement(node, maybeName, expr);else return this.parseExpressionStatement(node, expr);\n  }\n};\n\npp.parseBreakContinueStatement = function (node, keyword) {\n  var isBreak = keyword == \"break\";\n  this.next();\n  if (this.eat(_tokentype.types.semi) || this.insertSemicolon()) node.label = null;else if (this.type !== _tokentype.types.name) this.unexpected();else {\n    node.label = this.parseIdent();\n    this.semicolon();\n  }\n\n  // Verify that there is an actual destination to break or\n  // continue to.\n  for (var i = 0; i < this.labels.length; ++i) {\n    var lab = this.labels[i];\n    if (node.label == null || lab.name === node.label.name) {\n      if (lab.kind != null && (isBreak || lab.kind === \"loop\")) break;\n      if (node.label && isBreak) break;\n    }\n  }\n  if (i === this.labels.length) this.raise(node.start, \"Unsyntactic \" + keyword);\n  return this.finishNode(node, isBreak ? \"BreakStatement\" : \"ContinueStatement\");\n};\n\npp.parseDebuggerStatement = function (node) {\n  this.next();\n  this.semicolon();\n  return this.finishNode(node, \"DebuggerStatement\");\n};\n\npp.parseDoStatement = function (node) {\n  this.next();\n  this.labels.push(loopLabel);\n  node.body = this.parseStatement(false);\n  this.labels.pop();\n  this.expect(_tokentype.types._while);\n  node.test = this.parseParenExpression();\n  if (this.options.ecmaVersion >= 6) this.eat(_tokentype.types.semi);else this.semicolon();\n  return this.finishNode(node, \"DoWhileStatement\");\n};\n\n// Disambiguating between a `for` and a `for`/`in` or `for`/`of`\n// loop is non-trivial. Basically, we have to parse the init `var`\n// statement or expression, disallowing the `in` operator (see\n// the second parameter to `parseExpression`), and then check\n// whether the next token is `in` or `of`. When there is no init\n// part (semicolon immediately after the opening parenthesis), it\n// is a regular `for` loop.\n\npp.parseForStatement = function (node) {\n  this.next();\n  this.labels.push(loopLabel);\n  this.expect(_tokentype.types.parenL);\n  if (this.type === _tokentype.types.semi) return this.parseFor(node, null);\n  if (this.type === _tokentype.types._var || this.type === _tokentype.types._let || this.type === _tokentype.types._const) {\n    var _init = this.startNode(),\n        varKind = this.type;\n    this.next();\n    this.parseVar(_init, true, varKind);\n    this.finishNode(_init, \"VariableDeclaration\");\n    if ((this.type === _tokentype.types._in || this.options.ecmaVersion >= 6 && this.isContextual(\"of\")) && _init.declarations.length === 1 && !(varKind !== _tokentype.types._var && _init.declarations[0].init)) return this.parseForIn(node, _init);\n    return this.parseFor(node, _init);\n  }\n  var refShorthandDefaultPos = { start: 0 };\n  var init = this.parseExpression(true, refShorthandDefaultPos);\n  if (this.type === _tokentype.types._in || this.options.ecmaVersion >= 6 && this.isContextual(\"of\")) {\n    this.toAssignable(init);\n    this.checkLVal(init);\n    return this.parseForIn(node, init);\n  } else if (refShorthandDefaultPos.start) {\n    this.unexpected(refShorthandDefaultPos.start);\n  }\n  return this.parseFor(node, init);\n};\n\npp.parseFunctionStatement = function (node) {\n  this.next();\n  return this.parseFunction(node, true);\n};\n\npp.parseIfStatement = function (node) {\n  this.next();\n  node.test = this.parseParenExpression();\n  node.consequent = this.parseStatement(false);\n  node.alternate = this.eat(_tokentype.types._else) ? this.parseStatement(false) : null;\n  return this.finishNode(node, \"IfStatement\");\n};\n\npp.parseReturnStatement = function (node) {\n  if (!this.inFunction && !this.options.allowReturnOutsideFunction) this.raise(this.start, \"'return' outside of function\");\n  this.next();\n\n  // In `return` (and `break`/`continue`), the keywords with\n  // optional arguments, we eagerly look for a semicolon or the\n  // possibility to insert one.\n\n  if (this.eat(_tokentype.types.semi) || this.insertSemicolon()) node.argument = null;else {\n    node.argument = this.parseExpression();this.semicolon();\n  }\n  return this.finishNode(node, \"ReturnStatement\");\n};\n\npp.parseSwitchStatement = function (node) {\n  this.next();\n  node.discriminant = this.parseParenExpression();\n  node.cases = [];\n  this.expect(_tokentype.types.braceL);\n  this.labels.push(switchLabel);\n\n  // Statements under must be grouped (by label) in SwitchCase\n  // nodes. `cur` is used to keep the node that we are currently\n  // adding statements to.\n\n  for (var cur, sawDefault = false; this.type != _tokentype.types.braceR;) {\n    if (this.type === _tokentype.types._case || this.type === _tokentype.types._default) {\n      var isCase = this.type === _tokentype.types._case;\n      if (cur) this.finishNode(cur, \"SwitchCase\");\n      node.cases.push(cur = this.startNode());\n      cur.consequent = [];\n      this.next();\n      if (isCase) {\n        cur.test = this.parseExpression();\n      } else {\n        if (sawDefault) this.raise(this.lastTokStart, \"Multiple default clauses\");\n        sawDefault = true;\n        cur.test = null;\n      }\n      this.expect(_tokentype.types.colon);\n    } else {\n      if (!cur) this.unexpected();\n      cur.consequent.push(this.parseStatement(true));\n    }\n  }\n  if (cur) this.finishNode(cur, \"SwitchCase\");\n  this.next(); // Closing brace\n  this.labels.pop();\n  return this.finishNode(node, \"SwitchStatement\");\n};\n\npp.parseThrowStatement = function (node) {\n  this.next();\n  if (_whitespace.lineBreak.test(this.input.slice(this.lastTokEnd, this.start))) this.raise(this.lastTokEnd, \"Illegal newline after throw\");\n  node.argument = this.parseExpression();\n  this.semicolon();\n  return this.finishNode(node, \"ThrowStatement\");\n};\n\n// Reused empty array added for node fields that are always empty.\n\nvar empty = [];\n\npp.parseTryStatement = function (node) {\n  this.next();\n  node.block = this.parseBlock();\n  node.handler = null;\n  if (this.type === _tokentype.types._catch) {\n    var clause = this.startNode();\n    this.next();\n    this.expect(_tokentype.types.parenL);\n    clause.param = this.parseBindingAtom();\n    this.checkLVal(clause.param, true);\n    this.expect(_tokentype.types.parenR);\n    clause.guard = null;\n    clause.body = this.parseBlock();\n    node.handler = this.finishNode(clause, \"CatchClause\");\n  }\n  node.guardedHandlers = empty;\n  node.finalizer = this.eat(_tokentype.types._finally) ? this.parseBlock() : null;\n  if (!node.handler && !node.finalizer) this.raise(node.start, \"Missing catch or finally clause\");\n  return this.finishNode(node, \"TryStatement\");\n};\n\npp.parseVarStatement = function (node, kind) {\n  this.next();\n  this.parseVar(node, false, kind);\n  this.semicolon();\n  return this.finishNode(node, \"VariableDeclaration\");\n};\n\npp.parseWhileStatement = function (node) {\n  this.next();\n  node.test = this.parseParenExpression();\n  this.labels.push(loopLabel);\n  node.body = this.parseStatement(false);\n  this.labels.pop();\n  return this.finishNode(node, \"WhileStatement\");\n};\n\npp.parseWithStatement = function (node) {\n  if (this.strict) this.raise(this.start, \"'with' in strict mode\");\n  this.next();\n  node.object = this.parseParenExpression();\n  node.body = this.parseStatement(false);\n  return this.finishNode(node, \"WithStatement\");\n};\n\npp.parseEmptyStatement = function (node) {\n  this.next();\n  return this.finishNode(node, \"EmptyStatement\");\n};\n\npp.parseLabeledStatement = function (node, maybeName, expr) {\n  for (var i = 0; i < this.labels.length; ++i) {\n    if (this.labels[i].name === maybeName) this.raise(expr.start, \"Label '\" + maybeName + \"' is already declared\");\n  }var kind = this.type.isLoop ? \"loop\" : this.type === _tokentype.types._switch ? \"switch\" : null;\n  for (var i = this.labels.length - 1; i >= 0; i--) {\n    var label = this.labels[i];\n    if (label.statementStart == node.start) {\n      label.statementStart = this.start;\n      label.kind = kind;\n    } else break;\n  }\n  this.labels.push({ name: maybeName, kind: kind, statementStart: this.start });\n  node.body = this.parseStatement(true);\n  this.labels.pop();\n  node.label = expr;\n  return this.finishNode(node, \"LabeledStatement\");\n};\n\npp.parseExpressionStatement = function (node, expr) {\n  node.expression = expr;\n  this.semicolon();\n  return this.finishNode(node, \"ExpressionStatement\");\n};\n\n// Parse a semicolon-enclosed block of statements, handling `\"use\n// strict\"` declarations when `allowStrict` is true (used for\n// function bodies).\n\npp.parseBlock = function (allowStrict) {\n  var node = this.startNode(),\n      first = true,\n      oldStrict = undefined;\n  node.body = [];\n  this.expect(_tokentype.types.braceL);\n  while (!this.eat(_tokentype.types.braceR)) {\n    var stmt = this.parseStatement(true);\n    node.body.push(stmt);\n    if (first && allowStrict && this.isUseStrict(stmt)) {\n      oldStrict = this.strict;\n      this.setStrict(this.strict = true);\n    }\n    first = false;\n  }\n  if (oldStrict === false) this.setStrict(false);\n  return this.finishNode(node, \"BlockStatement\");\n};\n\n// Parse a regular `for` loop. The disambiguation code in\n// `parseStatement` will already have parsed the init statement or\n// expression.\n\npp.parseFor = function (node, init) {\n  node.init = init;\n  this.expect(_tokentype.types.semi);\n  node.test = this.type === _tokentype.types.semi ? null : this.parseExpression();\n  this.expect(_tokentype.types.semi);\n  node.update = this.type === _tokentype.types.parenR ? null : this.parseExpression();\n  this.expect(_tokentype.types.parenR);\n  node.body = this.parseStatement(false);\n  this.labels.pop();\n  return this.finishNode(node, \"ForStatement\");\n};\n\n// Parse a `for`/`in` and `for`/`of` loop, which are almost\n// same from parser's perspective.\n\npp.parseForIn = function (node, init) {\n  var type = this.type === _tokentype.types._in ? \"ForInStatement\" : \"ForOfStatement\";\n  this.next();\n  node.left = init;\n  node.right = this.parseExpression();\n  this.expect(_tokentype.types.parenR);\n  node.body = this.parseStatement(false);\n  this.labels.pop();\n  return this.finishNode(node, type);\n};\n\n// Parse a list of variable declarations.\n\npp.parseVar = function (node, isFor, kind) {\n  node.declarations = [];\n  node.kind = kind.keyword;\n  for (;;) {\n    var decl = this.startNode();\n    this.parseVarId(decl);\n    if (this.eat(_tokentype.types.eq)) {\n      decl.init = this.parseMaybeAssign(isFor);\n    } else if (kind === _tokentype.types._const && !(this.type === _tokentype.types._in || this.options.ecmaVersion >= 6 && this.isContextual(\"of\"))) {\n      this.unexpected();\n    } else if (decl.id.type != \"Identifier\" && !(isFor && (this.type === _tokentype.types._in || this.isContextual(\"of\")))) {\n      this.raise(this.lastTokEnd, \"Complex binding patterns require an initialization value\");\n    } else {\n      decl.init = null;\n    }\n    node.declarations.push(this.finishNode(decl, \"VariableDeclarator\"));\n    if (!this.eat(_tokentype.types.comma)) break;\n  }\n  return node;\n};\n\npp.parseVarId = function (decl) {\n  decl.id = this.parseBindingAtom();\n  this.checkLVal(decl.id, true);\n};\n\n// Parse a function declaration or literal (depending on the\n// `isStatement` parameter).\n\npp.parseFunction = function (node, isStatement, allowExpressionBody) {\n  this.initFunction(node);\n  if (this.options.ecmaVersion >= 6) node.generator = this.eat(_tokentype.types.star);\n  if (isStatement || this.type === _tokentype.types.name) node.id = this.parseIdent();\n  this.parseFunctionParams(node);\n  this.parseFunctionBody(node, allowExpressionBody);\n  return this.finishNode(node, isStatement ? \"FunctionDeclaration\" : \"FunctionExpression\");\n};\n\npp.parseFunctionParams = function (node) {\n  this.expect(_tokentype.types.parenL);\n  node.params = this.parseBindingList(_tokentype.types.parenR, false, false);\n};\n\n// Parse a class declaration or literal (depending on the\n// `isStatement` parameter).\n\npp.parseClass = function (node, isStatement) {\n  this.next();\n  this.parseClassId(node, isStatement);\n  this.parseClassSuper(node);\n  var classBody = this.startNode();\n  var hadConstructor = false;\n  classBody.body = [];\n  this.expect(_tokentype.types.braceL);\n  while (!this.eat(_tokentype.types.braceR)) {\n    if (this.eat(_tokentype.types.semi)) continue;\n    var method = this.startNode();\n    var isGenerator = this.eat(_tokentype.types.star);\n    var isMaybeStatic = this.type === _tokentype.types.name && this.value === \"static\";\n    this.parsePropertyName(method);\n    method[\"static\"] = isMaybeStatic && this.type !== _tokentype.types.parenL;\n    if (method[\"static\"]) {\n      if (isGenerator) this.unexpected();\n      isGenerator = this.eat(_tokentype.types.star);\n      this.parsePropertyName(method);\n    }\n    method.kind = \"method\";\n    var isGetSet = false;\n    if (!method.computed) {\n      var key = method.key;\n\n      if (!isGenerator && key.type === \"Identifier\" && this.type !== _tokentype.types.parenL && (key.name === \"get\" || key.name === \"set\")) {\n        isGetSet = true;\n        method.kind = key.name;\n        key = this.parsePropertyName(method);\n      }\n      if (!method[\"static\"] && (key.type === \"Identifier\" && key.name === \"constructor\" || key.type === \"Literal\" && key.value === \"constructor\")) {\n        if (hadConstructor) this.raise(key.start, \"Duplicate constructor in the same class\");\n        if (isGetSet) this.raise(key.start, \"Constructor can't have get/set modifier\");\n        if (isGenerator) this.raise(key.start, \"Constructor can't be a generator\");\n        method.kind = \"constructor\";\n        hadConstructor = true;\n      }\n    }\n    this.parseClassMethod(classBody, method, isGenerator);\n    if (isGetSet) {\n      var paramCount = method.kind === \"get\" ? 0 : 1;\n      if (method.value.params.length !== paramCount) {\n        var start = method.value.start;\n        if (method.kind === \"get\") this.raise(start, \"getter should have no params\");else this.raise(start, \"setter should have exactly one param\");\n      }\n    }\n  }\n  node.body = this.finishNode(classBody, \"ClassBody\");\n  return this.finishNode(node, isStatement ? \"ClassDeclaration\" : \"ClassExpression\");\n};\n\npp.parseClassMethod = function (classBody, method, isGenerator) {\n  method.value = this.parseMethod(isGenerator);\n  classBody.body.push(this.finishNode(method, \"MethodDefinition\"));\n};\n\npp.parseClassId = function (node, isStatement) {\n  node.id = this.type === _tokentype.types.name ? this.parseIdent() : isStatement ? this.unexpected() : null;\n};\n\npp.parseClassSuper = function (node) {\n  node.superClass = this.eat(_tokentype.types._extends) ? this.parseExprSubscripts() : null;\n};\n\n// Parses module export declaration.\n\npp.parseExport = function (node) {\n  this.next();\n  // export * from '...'\n  if (this.eat(_tokentype.types.star)) {\n    this.expectContextual(\"from\");\n    node.source = this.type === _tokentype.types.string ? this.parseExprAtom() : this.unexpected();\n    this.semicolon();\n    return this.finishNode(node, \"ExportAllDeclaration\");\n  }\n  if (this.eat(_tokentype.types._default)) {\n    // export default ...\n    var expr = this.parseMaybeAssign();\n    var needsSemi = true;\n    if (expr.type == \"FunctionExpression\" || expr.type == \"ClassExpression\") {\n      needsSemi = false;\n      if (expr.id) {\n        expr.type = expr.type == \"FunctionExpression\" ? \"FunctionDeclaration\" : \"ClassDeclaration\";\n      }\n    }\n    node.declaration = expr;\n    if (needsSemi) this.semicolon();\n    return this.finishNode(node, \"ExportDefaultDeclaration\");\n  }\n  // export var|const|let|function|class ...\n  if (this.shouldParseExportStatement()) {\n    node.declaration = this.parseStatement(true);\n    node.specifiers = [];\n    node.source = null;\n  } else {\n    // export { x, y as z } [from '...']\n    node.declaration = null;\n    node.specifiers = this.parseExportSpecifiers();\n    if (this.eatContextual(\"from\")) {\n      node.source = this.type === _tokentype.types.string ? this.parseExprAtom() : this.unexpected();\n    } else {\n      node.source = null;\n    }\n    this.semicolon();\n  }\n  return this.finishNode(node, \"ExportNamedDeclaration\");\n};\n\npp.shouldParseExportStatement = function () {\n  return this.type.keyword;\n};\n\n// Parses a comma-separated list of module exports.\n\npp.parseExportSpecifiers = function () {\n  var nodes = [],\n      first = true;\n  // export { x, y as z } [from '...']\n  this.expect(_tokentype.types.braceL);\n  while (!this.eat(_tokentype.types.braceR)) {\n    if (!first) {\n      this.expect(_tokentype.types.comma);\n      if (this.afterTrailingComma(_tokentype.types.braceR)) break;\n    } else first = false;\n\n    var node = this.startNode();\n    node.local = this.parseIdent(this.type === _tokentype.types._default);\n    node.exported = this.eatContextual(\"as\") ? this.parseIdent(true) : node.local;\n    nodes.push(this.finishNode(node, \"ExportSpecifier\"));\n  }\n  return nodes;\n};\n\n// Parses import declaration.\n\npp.parseImport = function (node) {\n  this.next();\n  // import '...'\n  if (this.type === _tokentype.types.string) {\n    node.specifiers = empty;\n    node.source = this.parseExprAtom();\n  } else {\n    node.specifiers = this.parseImportSpecifiers();\n    this.expectContextual(\"from\");\n    node.source = this.type === _tokentype.types.string ? this.parseExprAtom() : this.unexpected();\n  }\n  this.semicolon();\n  return this.finishNode(node, \"ImportDeclaration\");\n};\n\n// Parses a comma-separated list of module imports.\n\npp.parseImportSpecifiers = function () {\n  var nodes = [],\n      first = true;\n  if (this.type === _tokentype.types.name) {\n    // import defaultObj, { x, y as z } from '...'\n    var node = this.startNode();\n    node.local = this.parseIdent();\n    this.checkLVal(node.local, true);\n    nodes.push(this.finishNode(node, \"ImportDefaultSpecifier\"));\n    if (!this.eat(_tokentype.types.comma)) return nodes;\n  }\n  if (this.type === _tokentype.types.star) {\n    var node = this.startNode();\n    this.next();\n    this.expectContextual(\"as\");\n    node.local = this.parseIdent();\n    this.checkLVal(node.local, true);\n    nodes.push(this.finishNode(node, \"ImportNamespaceSpecifier\"));\n    return nodes;\n  }\n  this.expect(_tokentype.types.braceL);\n  while (!this.eat(_tokentype.types.braceR)) {\n    if (!first) {\n      this.expect(_tokentype.types.comma);\n      if (this.afterTrailingComma(_tokentype.types.braceR)) break;\n    } else first = false;\n\n    var node = this.startNode();\n    node.imported = this.parseIdent(true);\n    node.local = this.eatContextual(\"as\") ? this.parseIdent() : node.imported;\n    this.checkLVal(node.local, true);\n    nodes.push(this.finishNode(node, \"ImportSpecifier\"));\n  }\n  return nodes;\n};\n\n},{\"./state\":10,\"./tokentype\":14,\"./whitespace\":16}],12:[function(_dereq_,module,exports){\n// The algorithm used to determine whether a regexp can appear at a\n// given point in the program is loosely based on sweet.js' approach.\n// See https://github.com/mozilla/sweet.js/wiki/design\n\n\"use strict\";\n\nexports.__esModule = true;\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar _state = _dereq_(\"./state\");\n\nvar _tokentype = _dereq_(\"./tokentype\");\n\nvar _whitespace = _dereq_(\"./whitespace\");\n\nvar TokContext = function TokContext(token, isExpr, preserveSpace, override) {\n  _classCallCheck(this, TokContext);\n\n  this.token = token;\n  this.isExpr = !!isExpr;\n  this.preserveSpace = !!preserveSpace;\n  this.override = override;\n};\n\nexports.TokContext = TokContext;\nvar types = {\n  b_stat: new TokContext(\"{\", false),\n  b_expr: new TokContext(\"{\", true),\n  b_tmpl: new TokContext(\"${\", true),\n  p_stat: new TokContext(\"(\", false),\n  p_expr: new TokContext(\"(\", true),\n  q_tmpl: new TokContext(\"`\", true, true, function (p) {\n    return p.readTmplToken();\n  }),\n  f_expr: new TokContext(\"function\", true)\n};\n\nexports.types = types;\nvar pp = _state.Parser.prototype;\n\npp.initialContext = function () {\n  return [types.b_stat];\n};\n\npp.braceIsBlock = function (prevType) {\n  if (prevType === _tokentype.types.colon) {\n    var _parent = this.curContext();\n    if (_parent === types.b_stat || _parent === types.b_expr) return !_parent.isExpr;\n  }\n  if (prevType === _tokentype.types._return) return _whitespace.lineBreak.test(this.input.slice(this.lastTokEnd, this.start));\n  if (prevType === _tokentype.types._else || prevType === _tokentype.types.semi || prevType === _tokentype.types.eof || prevType === _tokentype.types.parenR) return true;\n  if (prevType == _tokentype.types.braceL) return this.curContext() === types.b_stat;\n  return !this.exprAllowed;\n};\n\npp.updateContext = function (prevType) {\n  var update = undefined,\n      type = this.type;\n  if (type.keyword && prevType == _tokentype.types.dot) this.exprAllowed = false;else if (update = type.updateContext) update.call(this, prevType);else this.exprAllowed = type.beforeExpr;\n};\n\n// Token-specific context update code\n\n_tokentype.types.parenR.updateContext = _tokentype.types.braceR.updateContext = function () {\n  if (this.context.length == 1) {\n    this.exprAllowed = true;\n    return;\n  }\n  var out = this.context.pop();\n  if (out === types.b_stat && this.curContext() === types.f_expr) {\n    this.context.pop();\n    this.exprAllowed = false;\n  } else if (out === types.b_tmpl) {\n    this.exprAllowed = true;\n  } else {\n    this.exprAllowed = !out.isExpr;\n  }\n};\n\n_tokentype.types.braceL.updateContext = function (prevType) {\n  this.context.push(this.braceIsBlock(prevType) ? types.b_stat : types.b_expr);\n  this.exprAllowed = true;\n};\n\n_tokentype.types.dollarBraceL.updateContext = function () {\n  this.context.push(types.b_tmpl);\n  this.exprAllowed = true;\n};\n\n_tokentype.types.parenL.updateContext = function (prevType) {\n  var statementParens = prevType === _tokentype.types._if || prevType === _tokentype.types._for || prevType === _tokentype.types._with || prevType === _tokentype.types._while;\n  this.context.push(statementParens ? types.p_stat : types.p_expr);\n  this.exprAllowed = true;\n};\n\n_tokentype.types.incDec.updateContext = function () {};\n\n_tokentype.types._function.updateContext = function () {\n  if (this.curContext() !== types.b_stat) this.context.push(types.f_expr);\n  this.exprAllowed = false;\n};\n\n_tokentype.types.backQuote.updateContext = function () {\n  if (this.curContext() === types.q_tmpl) this.context.pop();else this.context.push(types.q_tmpl);\n  this.exprAllowed = false;\n};\n\n// tokExprAllowed stays unchanged\n\n},{\"./state\":10,\"./tokentype\":14,\"./whitespace\":16}],13:[function(_dereq_,module,exports){\n\"use strict\";\n\nexports.__esModule = true;\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar _identifier = _dereq_(\"./identifier\");\n\nvar _tokentype = _dereq_(\"./tokentype\");\n\nvar _state = _dereq_(\"./state\");\n\nvar _locutil = _dereq_(\"./locutil\");\n\nvar _whitespace = _dereq_(\"./whitespace\");\n\n// Object type used to represent tokens. Note that normally, tokens\n// simply exist as properties on the parser object. This is only\n// used for the onToken callback and the external tokenizer.\n\nvar Token = function Token(p) {\n  _classCallCheck(this, Token);\n\n  this.type = p.type;\n  this.value = p.value;\n  this.start = p.start;\n  this.end = p.end;\n  if (p.options.locations) this.loc = new _locutil.SourceLocation(p, p.startLoc, p.endLoc);\n  if (p.options.ranges) this.range = [p.start, p.end];\n};\n\nexports.Token = Token;\n\n// ## Tokenizer\n\nvar pp = _state.Parser.prototype;\n\n// Are we running under Rhino?\nvar isRhino = typeof Packages == \"object\" && Object.prototype.toString.call(Packages) == \"[object JavaPackage]\";\n\n// Move to the next token\n\npp.next = function () {\n  if (this.options.onToken) this.options.onToken(new Token(this));\n\n  this.lastTokEnd = this.end;\n  this.lastTokStart = this.start;\n  this.lastTokEndLoc = this.endLoc;\n  this.lastTokStartLoc = this.startLoc;\n  this.nextToken();\n};\n\npp.getToken = function () {\n  this.next();\n  return new Token(this);\n};\n\n// If we're in an ES6 environment, make parsers iterable\nif (typeof Symbol !== \"undefined\") pp[Symbol.iterator] = function () {\n  var self = this;\n  return { next: function next() {\n      var token = self.getToken();\n      return {\n        done: token.type === _tokentype.types.eof,\n        value: token\n      };\n    } };\n};\n\n// Toggle strict mode. Re-reads the next number or string to please\n// pedantic tests (`\"use strict\"; 010;` should fail).\n\npp.setStrict = function (strict) {\n  this.strict = strict;\n  if (this.type !== _tokentype.types.num && this.type !== _tokentype.types.string) return;\n  this.pos = this.start;\n  if (this.options.locations) {\n    while (this.pos < this.lineStart) {\n      this.lineStart = this.input.lastIndexOf(\"\\n\", this.lineStart - 2) + 1;\n      --this.curLine;\n    }\n  }\n  this.nextToken();\n};\n\npp.curContext = function () {\n  return this.context[this.context.length - 1];\n};\n\n// Read a single token, updating the parser object's token-related\n// properties.\n\npp.nextToken = function () {\n  var curContext = this.curContext();\n  if (!curContext || !curContext.preserveSpace) this.skipSpace();\n\n  this.start = this.pos;\n  if (this.options.locations) this.startLoc = this.curPosition();\n  if (this.pos >= this.input.length) return this.finishToken(_tokentype.types.eof);\n\n  if (curContext.override) return curContext.override(this);else this.readToken(this.fullCharCodeAtPos());\n};\n\npp.readToken = function (code) {\n  // Identifier or keyword. '\\uXXXX' sequences are allowed in\n  // identifiers, so '\\' also dispatches to that.\n  if (_identifier.isIdentifierStart(code, this.options.ecmaVersion >= 6) || code === 92 /* '\\' */) return this.readWord();\n\n  return this.getTokenFromCode(code);\n};\n\npp.fullCharCodeAtPos = function () {\n  var code = this.input.charCodeAt(this.pos);\n  if (code <= 0xd7ff || code >= 0xe000) return code;\n  var next = this.input.charCodeAt(this.pos + 1);\n  return (code << 10) + next - 0x35fdc00;\n};\n\npp.skipBlockComment = function () {\n  var startLoc = this.options.onComment && this.curPosition();\n  var start = this.pos,\n      end = this.input.indexOf(\"*/\", this.pos += 2);\n  if (end === -1) this.raise(this.pos - 2, \"Unterminated comment\");\n  this.pos = end + 2;\n  if (this.options.locations) {\n    _whitespace.lineBreakG.lastIndex = start;\n    var match = undefined;\n    while ((match = _whitespace.lineBreakG.exec(this.input)) && match.index < this.pos) {\n      ++this.curLine;\n      this.lineStart = match.index + match[0].length;\n    }\n  }\n  if (this.options.onComment) this.options.onComment(true, this.input.slice(start + 2, end), start, this.pos, startLoc, this.curPosition());\n};\n\npp.skipLineComment = function (startSkip) {\n  var start = this.pos;\n  var startLoc = this.options.onComment && this.curPosition();\n  var ch = this.input.charCodeAt(this.pos += startSkip);\n  while (this.pos < this.input.length && ch !== 10 && ch !== 13 && ch !== 8232 && ch !== 8233) {\n    ++this.pos;\n    ch = this.input.charCodeAt(this.pos);\n  }\n  if (this.options.onComment) this.options.onComment(false, this.input.slice(start + startSkip, this.pos), start, this.pos, startLoc, this.curPosition());\n};\n\n// Called at the start of the parse and after every token. Skips\n// whitespace and comments, and.\n\npp.skipSpace = function () {\n  loop: while (this.pos < this.input.length) {\n    var ch = this.input.charCodeAt(this.pos);\n    switch (ch) {\n      case 32:case 160:\n        // ' '\n        ++this.pos;\n        break;\n      case 13:\n        if (this.input.charCodeAt(this.pos + 1) === 10) {\n          ++this.pos;\n        }\n      case 10:case 8232:case 8233:\n        ++this.pos;\n        if (this.options.locations) {\n          ++this.curLine;\n          this.lineStart = this.pos;\n        }\n        break;\n      case 47:\n        // '/'\n        switch (this.input.charCodeAt(this.pos + 1)) {\n          case 42:\n            // '*'\n            this.skipBlockComment();\n            break;\n          case 47:\n            this.skipLineComment(2);\n            break;\n          default:\n            break loop;\n        }\n        break;\n      default:\n        if (ch > 8 && ch < 14 || ch >= 5760 && _whitespace.nonASCIIwhitespace.test(String.fromCharCode(ch))) {\n          ++this.pos;\n        } else {\n          break loop;\n        }\n    }\n  }\n};\n\n// Called at the end of every token. Sets `end`, `val`, and\n// maintains `context` and `exprAllowed`, and skips the space after\n// the token, so that the next one's `start` will point at the\n// right position.\n\npp.finishToken = function (type, val) {\n  this.end = this.pos;\n  if (this.options.locations) this.endLoc = this.curPosition();\n  var prevType = this.type;\n  this.type = type;\n  this.value = val;\n\n  this.updateContext(prevType);\n};\n\n// ### Token reading\n\n// This is the function that is called to fetch the next token. It\n// is somewhat obscure, because it works in character codes rather\n// than characters, and because operator parsing has been inlined\n// into it.\n//\n// All in the name of speed.\n//\npp.readToken_dot = function () {\n  var next = this.input.charCodeAt(this.pos + 1);\n  if (next >= 48 && next <= 57) return this.readNumber(true);\n  var next2 = this.input.charCodeAt(this.pos + 2);\n  if (this.options.ecmaVersion >= 6 && next === 46 && next2 === 46) {\n    // 46 = dot '.'\n    this.pos += 3;\n    return this.finishToken(_tokentype.types.ellipsis);\n  } else {\n    ++this.pos;\n    return this.finishToken(_tokentype.types.dot);\n  }\n};\n\npp.readToken_slash = function () {\n  // '/'\n  var next = this.input.charCodeAt(this.pos + 1);\n  if (this.exprAllowed) {\n    ++this.pos;return this.readRegexp();\n  }\n  if (next === 61) return this.finishOp(_tokentype.types.assign, 2);\n  return this.finishOp(_tokentype.types.slash, 1);\n};\n\npp.readToken_mult_modulo = function (code) {\n  // '%*'\n  var next = this.input.charCodeAt(this.pos + 1);\n  if (next === 61) return this.finishOp(_tokentype.types.assign, 2);\n  return this.finishOp(code === 42 ? _tokentype.types.star : _tokentype.types.modulo, 1);\n};\n\npp.readToken_pipe_amp = function (code) {\n  // '|&'\n  var next = this.input.charCodeAt(this.pos + 1);\n  if (next === code) return this.finishOp(code === 124 ? _tokentype.types.logicalOR : _tokentype.types.logicalAND, 2);\n  if (next === 61) return this.finishOp(_tokentype.types.assign, 2);\n  return this.finishOp(code === 124 ? _tokentype.types.bitwiseOR : _tokentype.types.bitwiseAND, 1);\n};\n\npp.readToken_caret = function () {\n  // '^'\n  var next = this.input.charCodeAt(this.pos + 1);\n  if (next === 61) return this.finishOp(_tokentype.types.assign, 2);\n  return this.finishOp(_tokentype.types.bitwiseXOR, 1);\n};\n\npp.readToken_plus_min = function (code) {\n  // '+-'\n  var next = this.input.charCodeAt(this.pos + 1);\n  if (next === code) {\n    if (next == 45 && this.input.charCodeAt(this.pos + 2) == 62 && _whitespace.lineBreak.test(this.input.slice(this.lastTokEnd, this.pos))) {\n      // A `-->` line comment\n      this.skipLineComment(3);\n      this.skipSpace();\n      return this.nextToken();\n    }\n    return this.finishOp(_tokentype.types.incDec, 2);\n  }\n  if (next === 61) return this.finishOp(_tokentype.types.assign, 2);\n  return this.finishOp(_tokentype.types.plusMin, 1);\n};\n\npp.readToken_lt_gt = function (code) {\n  // '<>'\n  var next = this.input.charCodeAt(this.pos + 1);\n  var size = 1;\n  if (next === code) {\n    size = code === 62 && this.input.charCodeAt(this.pos + 2) === 62 ? 3 : 2;\n    if (this.input.charCodeAt(this.pos + size) === 61) return this.finishOp(_tokentype.types.assign, size + 1);\n    return this.finishOp(_tokentype.types.bitShift, size);\n  }\n  if (next == 33 && code == 60 && this.input.charCodeAt(this.pos + 2) == 45 && this.input.charCodeAt(this.pos + 3) == 45) {\n    if (this.inModule) this.unexpected();\n    // `<!--`, an XML-style comment that should be interpreted as a line comment\n    this.skipLineComment(4);\n    this.skipSpace();\n    return this.nextToken();\n  }\n  if (next === 61) size = this.input.charCodeAt(this.pos + 2) === 61 ? 3 : 2;\n  return this.finishOp(_tokentype.types.relational, size);\n};\n\npp.readToken_eq_excl = function (code) {\n  // '=!'\n  var next = this.input.charCodeAt(this.pos + 1);\n  if (next === 61) return this.finishOp(_tokentype.types.equality, this.input.charCodeAt(this.pos + 2) === 61 ? 3 : 2);\n  if (code === 61 && next === 62 && this.options.ecmaVersion >= 6) {\n    // '=>'\n    this.pos += 2;\n    return this.finishToken(_tokentype.types.arrow);\n  }\n  return this.finishOp(code === 61 ? _tokentype.types.eq : _tokentype.types.prefix, 1);\n};\n\npp.getTokenFromCode = function (code) {\n  switch (code) {\n    // The interpretation of a dot depends on whether it is followed\n    // by a digit or another two dots.\n    case 46:\n      // '.'\n      return this.readToken_dot();\n\n    // Punctuation tokens.\n    case 40:\n      ++this.pos;return this.finishToken(_tokentype.types.parenL);\n    case 41:\n      ++this.pos;return this.finishToken(_tokentype.types.parenR);\n    case 59:\n      ++this.pos;return this.finishToken(_tokentype.types.semi);\n    case 44:\n      ++this.pos;return this.finishToken(_tokentype.types.comma);\n    case 91:\n      ++this.pos;return this.finishToken(_tokentype.types.bracketL);\n    case 93:\n      ++this.pos;return this.finishToken(_tokentype.types.bracketR);\n    case 123:\n      ++this.pos;return this.finishToken(_tokentype.types.braceL);\n    case 125:\n      ++this.pos;return this.finishToken(_tokentype.types.braceR);\n    case 58:\n      ++this.pos;return this.finishToken(_tokentype.types.colon);\n    case 63:\n      ++this.pos;return this.finishToken(_tokentype.types.question);\n\n    case 96:\n      // '`'\n      if (this.options.ecmaVersion < 6) break;\n      ++this.pos;\n      return this.finishToken(_tokentype.types.backQuote);\n\n    case 48:\n      // '0'\n      var next = this.input.charCodeAt(this.pos + 1);\n      if (next === 120 || next === 88) return this.readRadixNumber(16); // '0x', '0X' - hex number\n      if (this.options.ecmaVersion >= 6) {\n        if (next === 111 || next === 79) return this.readRadixNumber(8); // '0o', '0O' - octal number\n        if (next === 98 || next === 66) return this.readRadixNumber(2); // '0b', '0B' - binary number\n      }\n    // Anything else beginning with a digit is an integer, octal\n    // number, or float.\n    case 49:case 50:case 51:case 52:case 53:case 54:case 55:case 56:case 57:\n      // 1-9\n      return this.readNumber(false);\n\n    // Quotes produce strings.\n    case 34:case 39:\n      // '\"', \"'\"\n      return this.readString(code);\n\n    // Operators are parsed inline in tiny state machines. '=' (61) is\n    // often referred to. `finishOp` simply skips the amount of\n    // characters it is given as second argument, and returns a token\n    // of the type given by its first argument.\n\n    case 47:\n      // '/'\n      return this.readToken_slash();\n\n    case 37:case 42:\n      // '%*'\n      return this.readToken_mult_modulo(code);\n\n    case 124:case 38:\n      // '|&'\n      return this.readToken_pipe_amp(code);\n\n    case 94:\n      // '^'\n      return this.readToken_caret();\n\n    case 43:case 45:\n      // '+-'\n      return this.readToken_plus_min(code);\n\n    case 60:case 62:\n      // '<>'\n      return this.readToken_lt_gt(code);\n\n    case 61:case 33:\n      // '=!'\n      return this.readToken_eq_excl(code);\n\n    case 126:\n      // '~'\n      return this.finishOp(_tokentype.types.prefix, 1);\n  }\n\n  this.raise(this.pos, \"Unexpected character '\" + codePointToString(code) + \"'\");\n};\n\npp.finishOp = function (type, size) {\n  var str = this.input.slice(this.pos, this.pos + size);\n  this.pos += size;\n  return this.finishToken(type, str);\n};\n\n// Parse a regular expression. Some context-awareness is necessary,\n// since a '/' inside a '[]' set does not end the expression.\n\nfunction tryCreateRegexp(src, flags, throwErrorAt) {\n  try {\n    return new RegExp(src, flags);\n  } catch (e) {\n    if (throwErrorAt !== undefined) {\n      if (e instanceof SyntaxError) this.raise(throwErrorAt, \"Error parsing regular expression: \" + e.message);\n      this.raise(e);\n    }\n  }\n}\n\nvar regexpUnicodeSupport = !!tryCreateRegexp(\"\", \"u\");\n\npp.readRegexp = function () {\n  var _this = this;\n\n  var escaped = undefined,\n      inClass = undefined,\n      start = this.pos;\n  for (;;) {\n    if (this.pos >= this.input.length) this.raise(start, \"Unterminated regular expression\");\n    var ch = this.input.charAt(this.pos);\n    if (_whitespace.lineBreak.test(ch)) this.raise(start, \"Unterminated regular expression\");\n    if (!escaped) {\n      if (ch === \"[\") inClass = true;else if (ch === \"]\" && inClass) inClass = false;else if (ch === \"/\" && !inClass) break;\n      escaped = ch === \"\\\\\";\n    } else escaped = false;\n    ++this.pos;\n  }\n  var content = this.input.slice(start, this.pos);\n  ++this.pos;\n  // Need to use `readWord1` because '\\uXXXX' sequences are allowed\n  // here (don't ask).\n  var mods = this.readWord1();\n  var tmp = content;\n  if (mods) {\n    var validFlags = /^[gmsiy]*$/;\n    if (this.options.ecmaVersion >= 6) validFlags = /^[gmsiyu]*$/;\n    if (!validFlags.test(mods)) this.raise(start, \"Invalid regular expression flag\");\n    if (mods.indexOf(\"u\") >= 0 && !regexpUnicodeSupport) {\n      // Replace each astral symbol and every Unicode escape sequence that\n      // possibly represents an astral symbol or a paired surrogate with a\n      // single ASCII symbol to avoid throwing on regular expressions that\n      // are only valid in combination with the `/u` flag.\n      // Note: replacing with the ASCII symbol `x` might cause false\n      // negatives in unlikely scenarios. For example, `[\\u{61}-b]` is a\n      // perfectly valid pattern that is equivalent to `[a-b]`, but it would\n      // be replaced by `[x-b]` which throws an error.\n      tmp = tmp.replace(/\\\\u\\{([0-9a-fA-F]+)\\}/g, function (match, code, offset) {\n        code = Number(\"0x\" + code);\n        if (code > 0x10FFFF) _this.raise(start + offset + 3, \"Code point out of bounds\");\n        return \"x\";\n      });\n      tmp = tmp.replace(/\\\\u([a-fA-F0-9]{4})|[\\uD800-\\uDBFF][\\uDC00-\\uDFFF]/g, \"x\");\n    }\n  }\n  // Detect invalid regular expressions.\n  var value = null;\n  // Rhino's regular expression parser is flaky and throws uncatchable exceptions,\n  // so don't do detection if we are running under Rhino\n  if (!isRhino) {\n    tryCreateRegexp(tmp, undefined, start);\n    // Get a regular expression object for this pattern-flag pair, or `null` in\n    // case the current environment doesn't support the flags it uses.\n    value = tryCreateRegexp(content, mods);\n  }\n  return this.finishToken(_tokentype.types.regexp, { pattern: content, flags: mods, value: value });\n};\n\n// Read an integer in the given radix. Return null if zero digits\n// were read, the integer value otherwise. When `len` is given, this\n// will return `null` unless the integer has exactly `len` digits.\n\npp.readInt = function (radix, len) {\n  var start = this.pos,\n      total = 0;\n  for (var i = 0, e = len == null ? Infinity : len; i < e; ++i) {\n    var code = this.input.charCodeAt(this.pos),\n        val = undefined;\n    if (code >= 97) val = code - 97 + 10; // a\n    else if (code >= 65) val = code - 65 + 10; // A\n    else if (code >= 48 && code <= 57) val = code - 48; // 0-9\n    else val = Infinity;\n    if (val >= radix) break;\n    ++this.pos;\n    total = total * radix + val;\n  }\n  if (this.pos === start || len != null && this.pos - start !== len) return null;\n\n  return total;\n};\n\npp.readRadixNumber = function (radix) {\n  this.pos += 2; // 0x\n  var val = this.readInt(radix);\n  if (val == null) this.raise(this.start + 2, \"Expected number in radix \" + radix);\n  if (_identifier.isIdentifierStart(this.fullCharCodeAtPos())) this.raise(this.pos, \"Identifier directly after number\");\n  return this.finishToken(_tokentype.types.num, val);\n};\n\n// Read an integer, octal integer, or floating-point number.\n\npp.readNumber = function (startsWithDot) {\n  var start = this.pos,\n      isFloat = false,\n      octal = this.input.charCodeAt(this.pos) === 48;\n  if (!startsWithDot && this.readInt(10) === null) this.raise(start, \"Invalid number\");\n  var next = this.input.charCodeAt(this.pos);\n  if (next === 46) {\n    // '.'\n    ++this.pos;\n    this.readInt(10);\n    isFloat = true;\n    next = this.input.charCodeAt(this.pos);\n  }\n  if (next === 69 || next === 101) {\n    // 'eE'\n    next = this.input.charCodeAt(++this.pos);\n    if (next === 43 || next === 45) ++this.pos; // '+-'\n    if (this.readInt(10) === null) this.raise(start, \"Invalid number\");\n    isFloat = true;\n  }\n  if (_identifier.isIdentifierStart(this.fullCharCodeAtPos())) this.raise(this.pos, \"Identifier directly after number\");\n\n  var str = this.input.slice(start, this.pos),\n      val = undefined;\n  if (isFloat) val = parseFloat(str);else if (!octal || str.length === 1) val = parseInt(str, 10);else if (/[89]/.test(str) || this.strict) this.raise(start, \"Invalid number\");else val = parseInt(str, 8);\n  return this.finishToken(_tokentype.types.num, val);\n};\n\n// Read a string value, interpreting backslash-escapes.\n\npp.readCodePoint = function () {\n  var ch = this.input.charCodeAt(this.pos),\n      code = undefined;\n\n  if (ch === 123) {\n    if (this.options.ecmaVersion < 6) this.unexpected();\n    var codePos = ++this.pos;\n    code = this.readHexChar(this.input.indexOf(\"}\", this.pos) - this.pos);\n    ++this.pos;\n    if (code > 0x10FFFF) this.raise(codePos, \"Code point out of bounds\");\n  } else {\n    code = this.readHexChar(4);\n  }\n  return code;\n};\n\nfunction codePointToString(code) {\n  // UTF-16 Decoding\n  if (code <= 0xFFFF) return String.fromCharCode(code);\n  code -= 0x10000;\n  return String.fromCharCode((code >> 10) + 0xD800, (code & 1023) + 0xDC00);\n}\n\npp.readString = function (quote) {\n  var out = \"\",\n      chunkStart = ++this.pos;\n  for (;;) {\n    if (this.pos >= this.input.length) this.raise(this.start, \"Unterminated string constant\");\n    var ch = this.input.charCodeAt(this.pos);\n    if (ch === quote) break;\n    if (ch === 92) {\n      // '\\'\n      out += this.input.slice(chunkStart, this.pos);\n      out += this.readEscapedChar(false);\n      chunkStart = this.pos;\n    } else {\n      if (_whitespace.isNewLine(ch)) this.raise(this.start, \"Unterminated string constant\");\n      ++this.pos;\n    }\n  }\n  out += this.input.slice(chunkStart, this.pos++);\n  return this.finishToken(_tokentype.types.string, out);\n};\n\n// Reads template string tokens.\n\npp.readTmplToken = function () {\n  var out = \"\",\n      chunkStart = this.pos;\n  for (;;) {\n    if (this.pos >= this.input.length) this.raise(this.start, \"Unterminated template\");\n    var ch = this.input.charCodeAt(this.pos);\n    if (ch === 96 || ch === 36 && this.input.charCodeAt(this.pos + 1) === 123) {\n      // '`', '${'\n      if (this.pos === this.start && this.type === _tokentype.types.template) {\n        if (ch === 36) {\n          this.pos += 2;\n          return this.finishToken(_tokentype.types.dollarBraceL);\n        } else {\n          ++this.pos;\n          return this.finishToken(_tokentype.types.backQuote);\n        }\n      }\n      out += this.input.slice(chunkStart, this.pos);\n      return this.finishToken(_tokentype.types.template, out);\n    }\n    if (ch === 92) {\n      // '\\'\n      out += this.input.slice(chunkStart, this.pos);\n      out += this.readEscapedChar(true);\n      chunkStart = this.pos;\n    } else if (_whitespace.isNewLine(ch)) {\n      out += this.input.slice(chunkStart, this.pos);\n      ++this.pos;\n      switch (ch) {\n        case 13:\n          if (this.input.charCodeAt(this.pos) === 10) ++this.pos;\n        case 10:\n          out += \"\\n\";\n          break;\n        default:\n          out += String.fromCharCode(ch);\n          break;\n      }\n      if (this.options.locations) {\n        ++this.curLine;\n        this.lineStart = this.pos;\n      }\n      chunkStart = this.pos;\n    } else {\n      ++this.pos;\n    }\n  }\n};\n\n// Used to read escaped characters\n\npp.readEscapedChar = function (inTemplate) {\n  var ch = this.input.charCodeAt(++this.pos);\n  ++this.pos;\n  switch (ch) {\n    case 110:\n      return \"\\n\"; // 'n' -> '\\n'\n    case 114:\n      return \"\\r\"; // 'r' -> '\\r'\n    case 120:\n      return String.fromCharCode(this.readHexChar(2)); // 'x'\n    case 117:\n      return codePointToString(this.readCodePoint()); // 'u'\n    case 116:\n      return \"\\t\"; // 't' -> '\\t'\n    case 98:\n      return \"\\b\"; // 'b' -> '\\b'\n    case 118:\n      return \"\\u000b\"; // 'v' -> '\\u000b'\n    case 102:\n      return \"\\f\"; // 'f' -> '\\f'\n    case 13:\n      if (this.input.charCodeAt(this.pos) === 10) ++this.pos; // '\\r\\n'\n    case 10:\n      // ' \\n'\n      if (this.options.locations) {\n        this.lineStart = this.pos;++this.curLine;\n      }\n      return \"\";\n    default:\n      if (ch >= 48 && ch <= 55) {\n        var octalStr = this.input.substr(this.pos - 1, 3).match(/^[0-7]+/)[0];\n        var octal = parseInt(octalStr, 8);\n        if (octal > 255) {\n          octalStr = octalStr.slice(0, -1);\n          octal = parseInt(octalStr, 8);\n        }\n        if (octal > 0 && (this.strict || inTemplate)) {\n          this.raise(this.pos - 2, \"Octal literal in strict mode\");\n        }\n        this.pos += octalStr.length - 1;\n        return String.fromCharCode(octal);\n      }\n      return String.fromCharCode(ch);\n  }\n};\n\n// Used to read character escape sequences ('\\x', '\\u', '\\U').\n\npp.readHexChar = function (len) {\n  var codePos = this.pos;\n  var n = this.readInt(16, len);\n  if (n === null) this.raise(codePos, \"Bad character escape sequence\");\n  return n;\n};\n\n// Read an identifier, and return it as a string. Sets `this.containsEsc`\n// to whether the word contained a '\\u' escape.\n//\n// Incrementally adds only escaped chars, adding other chunks as-is\n// as a micro-optimization.\n\npp.readWord1 = function () {\n  this.containsEsc = false;\n  var word = \"\",\n      first = true,\n      chunkStart = this.pos;\n  var astral = this.options.ecmaVersion >= 6;\n  while (this.pos < this.input.length) {\n    var ch = this.fullCharCodeAtPos();\n    if (_identifier.isIdentifierChar(ch, astral)) {\n      this.pos += ch <= 0xffff ? 1 : 2;\n    } else if (ch === 92) {\n      // \"\\\"\n      this.containsEsc = true;\n      word += this.input.slice(chunkStart, this.pos);\n      var escStart = this.pos;\n      if (this.input.charCodeAt(++this.pos) != 117) // \"u\"\n        this.raise(this.pos, \"Expecting Unicode escape sequence \\\\uXXXX\");\n      ++this.pos;\n      var esc = this.readCodePoint();\n      if (!(first ? _identifier.isIdentifierStart : _identifier.isIdentifierChar)(esc, astral)) this.raise(escStart, \"Invalid Unicode escape\");\n      word += codePointToString(esc);\n      chunkStart = this.pos;\n    } else {\n      break;\n    }\n    first = false;\n  }\n  return word + this.input.slice(chunkStart, this.pos);\n};\n\n// Read an identifier or keyword token. Will check for reserved\n// words when necessary.\n\npp.readWord = function () {\n  var word = this.readWord1();\n  var type = _tokentype.types.name;\n  if ((this.options.ecmaVersion >= 6 || !this.containsEsc) && this.isKeyword(word)) type = _tokentype.keywords[word];\n  return this.finishToken(type, word);\n};\n\n},{\"./identifier\":2,\"./locutil\":5,\"./state\":10,\"./tokentype\":14,\"./whitespace\":16}],14:[function(_dereq_,module,exports){\n// ## Token types\n\n// The assignment of fine-grained, information-carrying type objects\n// allows the tokenizer to store the information it has about a\n// token in a way that is very cheap for the parser to look up.\n\n// All token type variables start with an underscore, to make them\n// easy to recognize.\n\n// The `beforeExpr` property is used to disambiguate between regular\n// expressions and divisions. It is set on all token types that can\n// be followed by an expression (thus, a slash after them would be a\n// regular expression).\n//\n// `isLoop` marks a keyword as starting a loop, which is important\n// to know when parsing a label, in order to allow or disallow\n// continue jumps to that label.\n\n\"use strict\";\n\nexports.__esModule = true;\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar TokenType = function TokenType(label) {\n  var conf = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];\n\n  _classCallCheck(this, TokenType);\n\n  this.label = label;\n  this.keyword = conf.keyword;\n  this.beforeExpr = !!conf.beforeExpr;\n  this.startsExpr = !!conf.startsExpr;\n  this.isLoop = !!conf.isLoop;\n  this.isAssign = !!conf.isAssign;\n  this.prefix = !!conf.prefix;\n  this.postfix = !!conf.postfix;\n  this.binop = conf.binop || null;\n  this.updateContext = null;\n};\n\nexports.TokenType = TokenType;\n\nfunction binop(name, prec) {\n  return new TokenType(name, { beforeExpr: true, binop: prec });\n}\nvar beforeExpr = { beforeExpr: true },\n    startsExpr = { startsExpr: true };\n\nvar types = {\n  num: new TokenType(\"num\", startsExpr),\n  regexp: new TokenType(\"regexp\", startsExpr),\n  string: new TokenType(\"string\", startsExpr),\n  name: new TokenType(\"name\", startsExpr),\n  eof: new TokenType(\"eof\"),\n\n  // Punctuation token types.\n  bracketL: new TokenType(\"[\", { beforeExpr: true, startsExpr: true }),\n  bracketR: new TokenType(\"]\"),\n  braceL: new TokenType(\"{\", { beforeExpr: true, startsExpr: true }),\n  braceR: new TokenType(\"}\"),\n  parenL: new TokenType(\"(\", { beforeExpr: true, startsExpr: true }),\n  parenR: new TokenType(\")\"),\n  comma: new TokenType(\",\", beforeExpr),\n  semi: new TokenType(\";\", beforeExpr),\n  colon: new TokenType(\":\", beforeExpr),\n  dot: new TokenType(\".\"),\n  question: new TokenType(\"?\", beforeExpr),\n  arrow: new TokenType(\"=>\", beforeExpr),\n  template: new TokenType(\"template\"),\n  ellipsis: new TokenType(\"...\", beforeExpr),\n  backQuote: new TokenType(\"`\", startsExpr),\n  dollarBraceL: new TokenType(\"${\", { beforeExpr: true, startsExpr: true }),\n\n  // Operators. These carry several kinds of properties to help the\n  // parser use them properly (the presence of these properties is\n  // what categorizes them as operators).\n  //\n  // `binop`, when present, specifies that this operator is a binary\n  // operator, and will refer to its precedence.\n  //\n  // `prefix` and `postfix` mark the operator as a prefix or postfix\n  // unary operator.\n  //\n  // `isAssign` marks all of `=`, `+=`, `-=` etcetera, which act as\n  // binary operators with a very low precedence, that should result\n  // in AssignmentExpression nodes.\n\n  eq: new TokenType(\"=\", { beforeExpr: true, isAssign: true }),\n  assign: new TokenType(\"_=\", { beforeExpr: true, isAssign: true }),\n  incDec: new TokenType(\"++/--\", { prefix: true, postfix: true, startsExpr: true }),\n  prefix: new TokenType(\"prefix\", { beforeExpr: true, prefix: true, startsExpr: true }),\n  logicalOR: binop(\"||\", 1),\n  logicalAND: binop(\"&&\", 2),\n  bitwiseOR: binop(\"|\", 3),\n  bitwiseXOR: binop(\"^\", 4),\n  bitwiseAND: binop(\"&\", 5),\n  equality: binop(\"==/!=\", 6),\n  relational: binop(\"</>\", 7),\n  bitShift: binop(\"<</>>\", 8),\n  plusMin: new TokenType(\"+/-\", { beforeExpr: true, binop: 9, prefix: true, startsExpr: true }),\n  modulo: binop(\"%\", 10),\n  star: binop(\"*\", 10),\n  slash: binop(\"/\", 10)\n};\n\nexports.types = types;\n// Map keyword names to token types.\n\nvar keywords = {};\n\nexports.keywords = keywords;\n// Succinct definitions of keyword token types\nfunction kw(name) {\n  var options = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];\n\n  options.keyword = name;\n  keywords[name] = types[\"_\" + name] = new TokenType(name, options);\n}\n\nkw(\"break\");\nkw(\"case\", beforeExpr);\nkw(\"catch\");\nkw(\"continue\");\nkw(\"debugger\");\nkw(\"default\", beforeExpr);\nkw(\"do\", { isLoop: true });\nkw(\"else\", beforeExpr);\nkw(\"finally\");\nkw(\"for\", { isLoop: true });\nkw(\"function\", startsExpr);\nkw(\"if\");\nkw(\"return\", beforeExpr);\nkw(\"switch\");\nkw(\"throw\", beforeExpr);\nkw(\"try\");\nkw(\"var\");\nkw(\"let\");\nkw(\"const\");\nkw(\"while\", { isLoop: true });\nkw(\"with\");\nkw(\"new\", { beforeExpr: true, startsExpr: true });\nkw(\"this\", startsExpr);\nkw(\"super\", startsExpr);\nkw(\"class\");\nkw(\"extends\", beforeExpr);\nkw(\"export\");\nkw(\"import\");\nkw(\"yield\", { beforeExpr: true, startsExpr: true });\nkw(\"null\", startsExpr);\nkw(\"true\", startsExpr);\nkw(\"false\", startsExpr);\nkw(\"in\", { beforeExpr: true, binop: 7 });\nkw(\"instanceof\", { beforeExpr: true, binop: 7 });\nkw(\"typeof\", { beforeExpr: true, prefix: true, startsExpr: true });\nkw(\"void\", { beforeExpr: true, prefix: true, startsExpr: true });\nkw(\"delete\", { beforeExpr: true, prefix: true, startsExpr: true });\n\n},{}],15:[function(_dereq_,module,exports){\n\"use strict\";\n\nexports.__esModule = true;\nexports.isArray = isArray;\nexports.has = has;\n\nfunction isArray(obj) {\n  return Object.prototype.toString.call(obj) === \"[object Array]\";\n}\n\n// Checks if an object has a property.\n\nfunction has(obj, propName) {\n  return Object.prototype.hasOwnProperty.call(obj, propName);\n}\n\n},{}],16:[function(_dereq_,module,exports){\n// Matches a whole line break (where CRLF is considered a single\n// line break). Used to count lines.\n\n\"use strict\";\n\nexports.__esModule = true;\nexports.isNewLine = isNewLine;\nvar lineBreak = /\\r\\n?|\\n|\\u2028|\\u2029/;\nexports.lineBreak = lineBreak;\nvar lineBreakG = new RegExp(lineBreak.source, \"g\");\n\nexports.lineBreakG = lineBreakG;\n\nfunction isNewLine(code) {\n  return code === 10 || code === 13 || code === 0x2028 || code == 0x2029;\n}\n\nvar nonASCIIwhitespace = /[\\u1680\\u180e\\u2000-\\u200a\\u202f\\u205f\\u3000\\ufeff]/;\nexports.nonASCIIwhitespace = nonASCIIwhitespace;\n\n},{}]},{},[3])(3)\n});","'use strict';\n\nvar acorn = require('acorn');\n\nfunction readdirSync() {\n\tthrow new Error('Cannot use sander.readdirSync inside browser');\n}\n\nfunction readFileSync() {\n\tthrow new Error('Cannot use sander.readFileSync inside browser');\n}\n\nfunction writeFile() {\n\tthrow new Error('Cannot use sander.writeFile inside browser');\n}\n\nvar _Promise = window.Promise;\n\n// this looks ridiculous, but it prevents sourcemap tooling from mistaking\n// this for an actual sourceMappingURL\nvar SOURCEMAPPING_URL = 'sourceMa';\nSOURCEMAPPING_URL += 'ppingURL';\n\n// TODO does this all work on windows?\n\nvar absolutePath = /^(?:\\/|(?:[A-Za-z]:)?[\\\\|\\/])/;\n\nfunction isAbsolute(path) {\n\treturn absolutePath.test(path);\n}\n\nfunction basename(path) {\n\treturn path.split(/(\\/|\\\\)/).pop();\n}\n\nfunction dirname(path) {\n\tvar match = /(\\/|\\\\)[^\\/\\\\]*$/.exec(path);\n\tif (!match) return '.';\n\n\tvar dir = path.slice(0, -match[0].length);\n\n\t// If `dir` is the empty string, we're at root.\n\treturn dir ? dir : '/';\n}\n\nfunction extname(path) {\n\tvar match = /\\.[^\\.]+$/.exec(path);\n\tif (!match) return '';\n\treturn match[0];\n}\n\nfunction resolve() {\n\tfor (var _len = arguments.length, paths = Array(_len), _key = 0; _key < _len; _key++) {\n\t\tpaths[_key] = arguments[_key];\n\t}\n\n\tvar resolvedParts = paths.shift().split(/[\\/\\\\]/);\n\n\tpaths.forEach(function (path) {\n\t\tif (isAbsolute(path)) {\n\t\t\tresolvedParts = path.split(/[\\/\\\\]/);\n\t\t} else {\n\t\t\tvar parts = path.split(/[\\/\\\\]/);\n\n\t\t\twhile (parts[0] && parts[0][0] === '.') {\n\t\t\t\tvar part = parts.shift();\n\t\t\t\tif (part === '..') {\n\t\t\t\t\tresolvedParts.pop();\n\t\t\t\t} else if (part !== '.') {\n\t\t\t\t\tthrow new Error('Unexpected path part (' + part + ')');\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tresolvedParts.push.apply(resolvedParts, parts);\n\t\t}\n\t});\n\n\treturn resolvedParts.join('/'); // TODO windows...\n}\n\nvar keys = Object.keys;\n\nfunction _blank() {\n\treturn Object.create(null);\n}\n\nfunction unixizePath(path) {\n\treturn path.split(/[\\/\\\\]/).join('/');\n}\n\nfunction wrapAccess(id) {\n\treturn id.originalName !== 'default' && id.module && id.module.isExternal ? id.module.name + propertyAccess(id.originalName) : id.name;\n}\n\nfunction propertyAccess(name) {\n\treturn name === 'default' ? '[\\'default\\']' : '.' + name;\n}\nfunction getExportBlock(bundle, exportMode) {\n\tvar mechanism = arguments.length <= 2 || arguments[2] === undefined ? 'return' : arguments[2];\n\n\tif (exportMode === 'default') {\n\t\tvar id = bundle.exports.lookup('default');\n\n\t\treturn mechanism + ' ' + wrapAccess(id) + ';';\n\t}\n\n\treturn bundle.toExport.map(function (name) {\n\t\tvar id = bundle.exports.lookup(name);\n\n\t\treturn 'exports' + propertyAccess(name) + ' = ' + wrapAccess(id) + ';';\n\t}).join('\\n');\n}\n\nfunction getInteropBlock(bundle) {\n\treturn bundle.externalModules.map(function (module) {\n\t\tvar def = module.exports.lookup('default');\n\n\t\tif (!def) return;\n\n\t\treturn (module.needsNamed ? 'var ' : '') + (def.name + ' = \\'default\\' in ' + module.name + ' ? ' + module.name + '[\\'default\\'] : ' + module.name + ';');\n\t}).filter(Boolean).join('\\n');\n}\n\nfunction getName(x) {\n\treturn x.name;\n}\n\nfunction quoteId(x) {\n\treturn \"'\" + x.id + \"'\";\n}\n\nfunction req(x) {\n\treturn \"require('\" + x.id + \"')\";\n}\n\nfunction umd(bundle, magicString, _ref, options) {\n\tvar exportMode = _ref.exportMode;\n\tvar indentString = _ref.indentString;\n\n\tif (exportMode !== 'none' && !options.moduleName) {\n\t\tthrow new Error('You must supply options.moduleName for UMD bundles');\n\t}\n\n\tvar globalNames = options.globals || _blank();\n\n\tvar amdDeps = bundle.externalModules.map(quoteId);\n\tvar cjsDeps = bundle.externalModules.map(req);\n\tvar globalDeps = bundle.externalModules.map(function (module) {\n\t\treturn 'global.' + (globalNames[module.id] || module.name);\n\t});\n\n\tvar args = bundle.externalModules.map(getName);\n\n\tif (exportMode === 'named') {\n\t\tamdDeps.unshift('\\'exports\\'');\n\t\tcjsDeps.unshift('exports');\n\t\tglobalDeps.unshift('(global.' + options.moduleName + ' = {})');\n\n\t\targs.unshift('exports');\n\t}\n\n\tvar amdParams = (options.moduleId ? '\\'' + options.moduleId + '\\', ' : '') + (amdDeps.length ? '[' + amdDeps.join(', ') + '], ' : '');\n\n\tvar cjsExport = exportMode === 'default' ? 'module.exports = ' : '';\n\tvar defaultExport = exportMode === 'default' ? 'global.' + options.moduleName + ' = ' : '';\n\n\tvar useStrict = options.useStrict !== false ? ' \\'use strict\\';' : '';\n\n\tvar intro = ('(function (global, factory) {\\n\\t\\t\\ttypeof exports === \\'object\\' && typeof module !== \\'undefined\\' ? ' + cjsExport + 'factory(' + cjsDeps.join(', ') + ') :\\n\\t\\t\\ttypeof define === \\'function\\' && define.amd ? define(' + amdParams + 'factory) :\\n\\t\\t\\t' + defaultExport + 'factory(' + globalDeps + ');\\n\\t\\t}(this, function (' + args + ') {' + useStrict + '\\n\\n\\t\\t').replace(/^\\t\\t/gm, '').replace(/^\\t/gm, magicString.getIndentString());\n\n\t// var foo__default = 'default' in foo ? foo['default'] : foo;\n\tvar interopBlock = getInteropBlock(bundle);\n\tif (interopBlock) magicString.prepend(interopBlock + '\\n\\n');\n\n\tvar exportBlock = getExportBlock(bundle, exportMode);\n\tif (exportBlock) magicString.append('\\n\\n' + exportBlock);\n\n\treturn magicString.trim().indent(indentString).append('\\n\\n}));').prepend(intro);\n}\n\nfunction iife(bundle, magicString, _ref, options) {\n\tvar exportMode = _ref.exportMode;\n\tvar indentString = _ref.indentString;\n\n\tvar globalNames = options.globals || _blank();\n\n\tvar dependencies = bundle.externalModules.map(function (module) {\n\t\treturn globalNames[module.id] || module.name;\n\t});\n\n\tvar args = bundle.externalModules.map(getName);\n\n\tif (exportMode !== 'none' && !options.moduleName) {\n\t\tthrow new Error('You must supply options.moduleName for IIFE bundles');\n\t}\n\n\tif (exportMode === 'named') {\n\t\tdependencies.unshift('(this.' + options.moduleName + ' = {})');\n\t\targs.unshift('exports');\n\t}\n\n\tvar useStrict = options.useStrict !== false ? ' \\'use strict\\';' : '';\n\tvar intro = '(function (' + args + ') {' + useStrict + '\\n\\n';\n\tvar outro = '\\n\\n})(' + dependencies + ');';\n\n\tif (exportMode === 'default') {\n\t\tintro = 'var ' + options.moduleName + ' = ' + intro;\n\t}\n\n\t// var foo__default = 'default' in foo ? foo['default'] : foo;\n\tvar interopBlock = getInteropBlock(bundle);\n\tif (interopBlock) magicString.prepend(interopBlock + '\\n\\n');\n\n\tvar exportBlock = getExportBlock(bundle, exportMode);\n\tif (exportBlock) magicString.append('\\n\\n' + exportBlock);\n\n\treturn magicString.indent(indentString).prepend(intro).append(outro);\n}\n\nfunction specifiersFor(externalModule) {\n\treturn keys(externalModule.importedByBundle).filter(notDefault).sort().map(function (name) {\n\t\tvar id = externalModule.exports.lookup(name);\n\n\t\treturn name !== id.name ? name + ' as ' + id.name : name;\n\t});\n}\n\nfunction notDefault(name) {\n\treturn name !== 'default';\n}\nfunction es6(bundle, magicString) {\n\tvar importBlock = bundle.externalModules.map(function (module) {\n\t\tvar specifiers = [];\n\n\t\tvar id = module.exports.lookup('default');\n\n\t\tif (id) {\n\t\t\tspecifiers.push(id.name);\n\t\t}\n\n\t\tif (module.needsAll) {\n\t\t\tspecifiers.push('* as ' + module.name);\n\t\t}\n\n\t\tif (module.needsNamed) {\n\t\t\tspecifiers.push('{ ' + specifiersFor(module).join(', ') + ' }');\n\t\t}\n\n\t\treturn specifiers.length ? 'import ' + specifiers.join(', ') + ' from \\'' + module.id + '\\';' : 'import \\'' + module.id + '\\';';\n\t}).join('\\n');\n\n\tif (importBlock) {\n\t\tmagicString.prepend(importBlock + '\\n\\n');\n\t}\n\n\tvar module = bundle.entryModule;\n\n\tvar specifiers = bundle.toExport.filter(notDefault).map(function (name) {\n\t\tvar id = bundle.exports.lookup(name);\n\n\t\treturn id.name === name ? name : id.name + ' as ' + name;\n\t});\n\n\tvar exportBlock = specifiers.length ? 'export { ' + specifiers.join(', ') + ' };' : '';\n\n\tvar defaultExport = module.exports.lookup('default');\n\tif (defaultExport) {\n\t\texportBlock += '\\nexport default ' + defaultExport.name + ';';\n\t}\n\n\tif (exportBlock) {\n\t\tmagicString.append('\\n\\n' + exportBlock.trim());\n\t}\n\n\treturn magicString.trim();\n}\n\nfunction cjs(bundle, magicString, _ref, options) {\n\tvar exportMode = _ref.exportMode;\n\n\tvar intro = options.useStrict === false ? '' : '\\'use strict\\';\\n\\n';\n\n\t// TODO handle empty imports, once they're supported\n\tvar importBlock = bundle.externalModules.map(function (module) {\n\t\treturn 'var ' + module.name + ' = require(\\'' + module.id + '\\');';\n\t}).join('\\n');\n\n\tvar interopBlock = getInteropBlock(bundle);\n\n\tif (interopBlock) {\n\t\timportBlock += '\\n' + interopBlock;\n\t}\n\n\tif (importBlock) {\n\t\tintro += importBlock + '\\n\\n';\n\t}\n\n\tmagicString.prepend(intro);\n\n\tvar exportBlock = getExportBlock(bundle, exportMode, 'module.exports =');\n\tif (exportBlock) magicString.append('\\n\\n' + exportBlock);\n\n\treturn magicString;\n}\n\nfunction amd(bundle, magicString, _ref, options) {\n\tvar exportMode = _ref.exportMode;\n\tvar indentString = _ref.indentString;\n\n\tvar deps = bundle.externalModules.map(quoteId);\n\tvar args = bundle.externalModules.map(getName);\n\n\tif (exportMode === 'named') {\n\t\targs.unshift('exports');\n\t\tdeps.unshift('\\'exports\\'');\n\t}\n\n\tvar params = (options.moduleId ? '\\'' + options.moduleId + '\\', ' : '') + (deps.length ? '[' + deps.join(', ') + '], ' : '');\n\n\tvar useStrict = options.useStrict !== false ? ' \\'use strict\\';' : '';\n\tvar intro = 'define(' + params + 'function (' + args.join(', ') + ') {' + useStrict + '\\n\\n';\n\n\t// var foo__default = 'default' in foo ? foo['default'] : foo;\n\tvar interopBlock = getInteropBlock(bundle);\n\tif (interopBlock) magicString.prepend(interopBlock + '\\n\\n');\n\n\tvar exportBlock = getExportBlock(bundle, exportMode);\n\tif (exportBlock) magicString.append('\\n\\n' + exportBlock);\n\n\treturn magicString.indent(indentString).append('\\n\\n});').prepend(intro);\n}\n\nvar finalisers = { amd: amd, cjs: cjs, es6: es6, iife: iife, umd: umd };\n\nfunction getIndentString(magicString, options) {\n\tif (!('indent' in options) || options.indent === true) {\n\t\treturn magicString.getIndentString();\n\t}\n\n\treturn options.indent || '';\n}\n\nfunction getRelativePath(from, to) {\n\tvar fromParts = from.split(/[\\/\\\\]/);\n\tvar toParts = to.split(/[\\/\\\\]/);\n\n\tfromParts.pop(); // get dirname\n\n\twhile (fromParts[0] === toParts[0]) {\n\t\tfromParts.shift();\n\t\ttoParts.shift();\n\t}\n\n\tif (fromParts.length) {\n\t\tvar i = fromParts.length;\n\t\twhile (i--) fromParts[i] = '..';\n\t}\n\n\treturn fromParts.concat(toParts).join('/');\n}\n\nvar _btoa;\n\nif (typeof window !== 'undefined' && typeof window.btoa === 'function') {\n\t_btoa = window.btoa;\n} else if (typeof Buffer === 'function') {\n\t_btoa = function (str) {\n\t\treturn new Buffer(str).toString('base64');\n\t};\n} else {\n\tthrow new Error('Unsupported environment: `window.btoa` or `Buffer` should be supported.');\n}\n\nvar toConsumableArray = function (arr) {\n  if (Array.isArray(arr)) {\n    for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) arr2[i] = arr[i];\n\n    return arr2;\n  } else {\n    return Array.from(arr);\n  }\n};\n\nvar classCallCheck = function (instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n};\n\nvar SourceMap = (function () {\n\tfunction SourceMap(properties) {\n\t\tclassCallCheck(this, SourceMap);\n\n\t\tthis.version = 3;\n\n\t\tthis.file = properties.file;\n\t\tthis.sources = properties.sources;\n\t\tthis.sourcesContent = properties.sourcesContent;\n\t\tthis.names = properties.names;\n\t\tthis.mappings = properties.mappings;\n\t}\n\n\tSourceMap.prototype.toString = function toString() {\n\t\treturn JSON.stringify(this);\n\t};\n\n\tSourceMap.prototype.toUrl = function toUrl() {\n\t\treturn 'data:application/json;charset=utf-8;base64,' + _btoa(this.toString());\n\t};\n\n\treturn SourceMap;\n})();\n\nvar charToInteger = {};\nvar integerToChar = {};\n\n'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/='.split('').forEach(function (char, i) {\n\tcharToInteger[char] = i;\n\tintegerToChar[i] = char;\n});\n\nfunction encode(value) {\n\tvar result, i;\n\n\tif (typeof value === 'number') {\n\t\tresult = encodeInteger(value);\n\t} else {\n\t\tresult = '';\n\t\tfor (i = 0; i < value.length; i += 1) {\n\t\t\tresult += encodeInteger(value[i]);\n\t\t}\n\t}\n\n\treturn result;\n}\n\nfunction encodeInteger(num) {\n\tvar result = '',\n\t    clamped;\n\n\tif (num < 0) {\n\t\tnum = -num << 1 | 1;\n\t} else {\n\t\tnum <<= 1;\n\t}\n\n\tdo {\n\t\tclamped = num & 31;\n\t\tnum >>= 5;\n\n\t\tif (num > 0) {\n\t\t\tclamped |= 32;\n\t\t}\n\n\t\tresult += integerToChar[clamped];\n\t} while (num > 0);\n\n\treturn result;\n}\n\nfunction encodeMappings(original, str, mappings, hires, sourcemapLocations, sourceIndex, offsets, names, nameLocations) {\n\t// store locations, for fast lookup\n\tvar lineStart = 0;\n\tvar locations = original.split('\\n').map(function (line) {\n\t\tvar start = lineStart;\n\t\tlineStart += line.length + 1; // +1 for the newline\n\n\t\treturn start;\n\t});\n\n\tvar inverseMappings = invert(str, mappings);\n\n\tvar charOffset = 0;\n\tvar lines = str.split('\\n').map(function (line) {\n\t\tvar segments = [];\n\n\t\tvar char = undefined; // TODO put these inside loop, once we've determined it's safe to do so transpilation-wise\n\t\tvar origin = undefined;\n\t\tvar lastOrigin = -1;\n\t\tvar location = undefined;\n\t\tvar nameIndex = undefined;\n\n\t\tvar i = undefined;\n\n\t\tvar len = line.length;\n\t\tfor (i = 0; i < len; i += 1) {\n\t\t\tchar = i + charOffset;\n\t\t\torigin = inverseMappings[char];\n\n\t\t\tnameIndex = -1;\n\t\t\tlocation = null;\n\n\t\t\t// if this character has no mapping, but the last one did,\n\t\t\t// create a new segment\n\t\t\tif (! ~origin && ~lastOrigin) {\n\t\t\t\tlocation = _getLocation(locations, lastOrigin + 1);\n\n\t\t\t\tif (lastOrigin + 1 in nameLocations) nameIndex = names.indexOf(nameLocations[lastOrigin + 1]);\n\t\t\t} else if (~origin && (hires || ~lastOrigin && origin !== lastOrigin + 1 || sourcemapLocations[origin])) {\n\t\t\t\tlocation = _getLocation(locations, origin);\n\t\t\t}\n\n\t\t\tif (location) {\n\t\t\t\tsegments.push({\n\t\t\t\t\tgeneratedCodeColumn: i,\n\t\t\t\t\tsourceIndex: sourceIndex,\n\t\t\t\t\tsourceCodeLine: location.line,\n\t\t\t\t\tsourceCodeColumn: location.column,\n\t\t\t\t\tsourceCodeName: nameIndex\n\t\t\t\t});\n\t\t\t}\n\n\t\t\tlastOrigin = origin;\n\t\t}\n\n\t\tcharOffset += line.length + 1;\n\t\treturn segments;\n\t});\n\n\toffsets.sourceIndex = offsets.sourceIndex || 0;\n\toffsets.sourceCodeLine = offsets.sourceCodeLine || 0;\n\toffsets.sourceCodeColumn = offsets.sourceCodeColumn || 0;\n\toffsets.sourceCodeName = offsets.sourceCodeName || 0;\n\n\tvar encoded = lines.map(function (segments) {\n\t\tvar generatedCodeColumn = 0;\n\n\t\treturn segments.map(function (segment) {\n\t\t\tvar arr = [segment.generatedCodeColumn - generatedCodeColumn, segment.sourceIndex - offsets.sourceIndex, segment.sourceCodeLine - offsets.sourceCodeLine, segment.sourceCodeColumn - offsets.sourceCodeColumn];\n\n\t\t\tgeneratedCodeColumn = segment.generatedCodeColumn;\n\t\t\toffsets.sourceIndex = segment.sourceIndex;\n\t\t\toffsets.sourceCodeLine = segment.sourceCodeLine;\n\t\t\toffsets.sourceCodeColumn = segment.sourceCodeColumn;\n\n\t\t\tif (~segment.sourceCodeName) {\n\t\t\t\tarr.push(segment.sourceCodeName - offsets.sourceCodeName);\n\t\t\t\toffsets.sourceCodeName = segment.sourceCodeName;\n\t\t\t}\n\n\t\t\treturn encode(arr);\n\t\t}).join(',');\n\t}).join(';');\n\n\treturn encoded;\n}\n\nfunction invert(str, mappings) {\n\tvar inverted = new Uint32Array(str.length),\n\t    i;\n\n\t// initialise everything to -1\n\ti = str.length;\n\twhile (i--) {\n\t\tinverted[i] = -1;\n\t}\n\n\t// then apply the actual mappings\n\ti = mappings.length;\n\twhile (i--) {\n\t\tif (~mappings[i]) {\n\t\t\tinverted[mappings[i]] = i;\n\t\t}\n\t}\n\n\treturn inverted;\n}\n\nfunction _getLocation(locations, char) {\n\tvar i;\n\n\ti = locations.length;\n\twhile (i--) {\n\t\tif (locations[i] <= char) {\n\t\t\treturn {\n\t\t\t\tline: i,\n\t\t\t\tcolumn: char - locations[i]\n\t\t\t};\n\t\t}\n\t}\n\n\tthrow new Error('Character out of bounds');\n}\n\nfunction guessIndent(code) {\n\tvar lines = code.split('\\n');\n\n\tvar tabbed = lines.filter(function (line) {\n\t\treturn (/^\\t+/.test(line)\n\t\t);\n\t});\n\tvar spaced = lines.filter(function (line) {\n\t\treturn (/^ {2,}/.test(line)\n\t\t);\n\t});\n\n\tif (tabbed.length === 0 && spaced.length === 0) {\n\t\treturn null;\n\t}\n\n\t// More lines tabbed than spaced? Assume tabs, and\n\t// default to tabs in the case of a tie (or nothing\n\t// to go on)\n\tif (tabbed.length >= spaced.length) {\n\t\treturn '\\t';\n\t}\n\n\t// Otherwise, we need to guess the multiple\n\tvar min = spaced.reduce(function (previous, current) {\n\t\tvar numSpaces = /^ +/.exec(current)[0].length;\n\t\treturn Math.min(numSpaces, previous);\n\t}, Infinity);\n\n\treturn new Array(min + 1).join(' ');\n}\n\nvar warned = false;\n\nvar MagicString = (function () {\n\tfunction MagicString(string) {\n\t\tvar options = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];\n\t\tclassCallCheck(this, MagicString);\n\n\t\tthis.original = this.str = string;\n\t\tthis.mappings = initMappings(string.length);\n\n\t\tthis.filename = options.filename;\n\t\tthis.indentExclusionRanges = options.indentExclusionRanges;\n\n\t\tthis.sourcemapLocations = {};\n\t\tthis.nameLocations = {};\n\n\t\tthis.indentStr = guessIndent(string);\n\t}\n\n\tMagicString.prototype.addSourcemapLocation = function addSourcemapLocation(char) {\n\t\tthis.sourcemapLocations[char] = true;\n\t};\n\n\tMagicString.prototype.append = function append(content) {\n\t\tif (typeof content !== 'string') {\n\t\t\tthrow new TypeError('appended content must be a string');\n\t\t}\n\n\t\tthis.str += content;\n\t\treturn this;\n\t};\n\n\tMagicString.prototype.clone = function clone() {\n\t\tvar clone, i;\n\n\t\tclone = new MagicString(this.original, { filename: this.filename });\n\t\tclone.str = this.str;\n\n\t\ti = clone.mappings.length;\n\t\twhile (i--) {\n\t\t\tclone.mappings[i] = this.mappings[i];\n\t\t}\n\n\t\tif (this.indentExclusionRanges) {\n\t\t\tclone.indentExclusionRanges = typeof this.indentExclusionRanges[0] === 'number' ? [this.indentExclusionRanges[0], this.indentExclusionRanges[1]] : this.indentExclusionRanges.map(function (_ref) {\n\t\t\t\tvar start = _ref[0];\n\t\t\t\tvar end = _ref[1];\n\t\t\t\treturn [start, end];\n\t\t\t});\n\t\t}\n\n\t\tObject.keys(this.sourcemapLocations).forEach(function (loc) {\n\t\t\tclone.sourcemapLocations[loc] = true;\n\t\t});\n\n\t\treturn clone;\n\t};\n\n\tMagicString.prototype.generateMap = function generateMap(options) {\n\t\tvar _this = this;\n\n\t\toptions = options || {};\n\n\t\tvar names = [];\n\t\tObject.keys(this.nameLocations).forEach(function (location) {\n\t\t\tvar name = _this.nameLocations[location];\n\t\t\tif (! ~names.indexOf(name)) names.push(name);\n\t\t});\n\n\t\treturn new SourceMap({\n\t\t\tfile: options.file ? options.file.split(/[\\/\\\\]/).pop() : null,\n\t\t\tsources: [options.source ? getRelativePath(options.file || '', options.source) : null],\n\t\t\tsourcesContent: options.includeContent ? [this.original] : [null],\n\t\t\tnames: names,\n\t\t\tmappings: this.getMappings(options.hires, 0, {}, names)\n\t\t});\n\t};\n\n\tMagicString.prototype.getIndentString = function getIndentString() {\n\t\treturn this.indentStr === null ? '\\t' : this.indentStr;\n\t};\n\n\tMagicString.prototype.getMappings = function getMappings(hires, sourceIndex, offsets, names) {\n\t\treturn encodeMappings(this.original, this.str, this.mappings, hires, this.sourcemapLocations, sourceIndex, offsets, names, this.nameLocations);\n\t};\n\n\tMagicString.prototype.indent = function indent(indentStr, options) {\n\t\tvar self = this,\n\t\t    mappings = this.mappings,\n\t\t    reverseMappings = reverse(mappings, this.str.length),\n\t\t    pattern = /^[^\\r\\n]/gm,\n\t\t    match,\n\t\t    inserts = [],\n\t\t    adjustments,\n\t\t    exclusions,\n\t\t    lastEnd,\n\t\t    i;\n\n\t\tif (typeof indentStr === 'object') {\n\t\t\toptions = indentStr;\n\t\t\tindentStr = undefined;\n\t\t}\n\n\t\tindentStr = indentStr !== undefined ? indentStr : this.indentStr || '\\t';\n\n\t\tif (indentStr === '') return this; // noop\n\n\t\toptions = options || {};\n\n\t\t// Process exclusion ranges\n\t\tif (options.exclude) {\n\t\t\texclusions = typeof options.exclude[0] === 'number' ? [options.exclude] : options.exclude;\n\n\t\t\texclusions = exclusions.map(function (range) {\n\t\t\t\tvar rangeStart, rangeEnd;\n\n\t\t\t\trangeStart = self.locate(range[0]);\n\t\t\t\trangeEnd = self.locate(range[1]);\n\n\t\t\t\tif (rangeStart === null || rangeEnd === null) {\n\t\t\t\t\tthrow new Error('Cannot use indices of replaced characters as exclusion ranges');\n\t\t\t\t}\n\n\t\t\t\treturn [rangeStart, rangeEnd];\n\t\t\t});\n\n\t\t\texclusions.sort(function (a, b) {\n\t\t\t\treturn a[0] - b[0];\n\t\t\t});\n\n\t\t\t// check for overlaps\n\t\t\tlastEnd = -1;\n\t\t\texclusions.forEach(function (range) {\n\t\t\t\tif (range[0] < lastEnd) {\n\t\t\t\t\tthrow new Error('Exclusion ranges cannot overlap');\n\t\t\t\t}\n\n\t\t\t\tlastEnd = range[1];\n\t\t\t});\n\t\t}\n\n\t\tvar indentStart = options.indentStart !== false;\n\n\t\tif (!exclusions) {\n\t\t\tthis.str = this.str.replace(pattern, function (match, index) {\n\t\t\t\tif (!indentStart && index === 0) {\n\t\t\t\t\treturn match;\n\t\t\t\t}\n\n\t\t\t\tinserts.push(index);\n\t\t\t\treturn indentStr + match;\n\t\t\t});\n\t\t} else {\n\t\t\tthis.str = this.str.replace(pattern, function (match, index) {\n\t\t\t\tif (!indentStart && index === 0 || isExcluded(index - 1)) {\n\t\t\t\t\treturn match;\n\t\t\t\t}\n\n\t\t\t\tinserts.push(index);\n\t\t\t\treturn indentStr + match;\n\t\t\t});\n\t\t}\n\n\t\tadjustments = inserts.map(function (index) {\n\t\t\tvar origin;\n\n\t\t\tdo {\n\t\t\t\torigin = reverseMappings[index++];\n\t\t\t} while (! ~origin && index < self.str.length);\n\n\t\t\treturn origin;\n\t\t});\n\n\t\ti = adjustments.length;\n\t\tlastEnd = this.mappings.length;\n\t\twhile (i--) {\n\t\t\tadjust(self.mappings, adjustments[i], lastEnd, (i + 1) * indentStr.length);\n\t\t\tlastEnd = adjustments[i];\n\t\t}\n\n\t\treturn this;\n\n\t\tfunction isExcluded(index) {\n\t\t\tvar i = exclusions.length,\n\t\t\t    range;\n\n\t\t\twhile (i--) {\n\t\t\t\trange = exclusions[i];\n\n\t\t\t\tif (range[1] < index) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\n\t\t\t\tif (range[0] <= index) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t};\n\n\tMagicString.prototype.insert = function insert(index, content) {\n\t\tif (typeof content !== 'string') {\n\t\t\tthrow new TypeError('inserted content must be a string');\n\t\t}\n\n\t\tif (index === this.original.length) {\n\t\t\tthis.append(content);\n\t\t} else {\n\t\t\tvar mapped = this.locate(index);\n\n\t\t\tif (mapped === null) {\n\t\t\t\tthrow new Error('Cannot insert at replaced character index: ' + index);\n\t\t\t}\n\n\t\t\tthis.str = this.str.substr(0, mapped) + content + this.str.substr(mapped);\n\t\t\tadjust(this.mappings, index, this.mappings.length, content.length);\n\t\t}\n\n\t\treturn this;\n\t};\n\n\t// get current location of character in original string\n\n\tMagicString.prototype.locate = function locate(character) {\n\t\tvar loc;\n\n\t\tif (character < 0 || character > this.mappings.length) {\n\t\t\tthrow new Error('Character is out of bounds');\n\t\t}\n\n\t\tloc = this.mappings[character];\n\t\treturn ~loc ? loc : null;\n\t};\n\n\tMagicString.prototype.locateOrigin = function locateOrigin(character) {\n\t\tvar i;\n\n\t\tif (character < 0 || character >= this.str.length) {\n\t\t\tthrow new Error('Character is out of bounds');\n\t\t}\n\n\t\ti = this.mappings.length;\n\t\twhile (i--) {\n\t\t\tif (this.mappings[i] === character) {\n\t\t\t\treturn i;\n\t\t\t}\n\t\t}\n\n\t\treturn null;\n\t};\n\n\tMagicString.prototype.overwrite = function overwrite(start, end, content, storeName) {\n\t\tif (typeof content !== 'string') {\n\t\t\tthrow new TypeError('replacement content must be a string');\n\t\t}\n\n\t\tvar firstChar, lastChar, d;\n\n\t\tfirstChar = this.locate(start);\n\t\tlastChar = this.locate(end - 1);\n\n\t\tif (firstChar === null || lastChar === null) {\n\t\t\tthrow new Error('Cannot overwrite the same content twice: \\'' + this.original.slice(start, end).replace(/\\n/g, '\\\\n') + '\\'');\n\t\t}\n\n\t\tif (firstChar > lastChar + 1) {\n\t\t\tthrow new Error('BUG! First character mapped to a position after the last character: ' + '[' + start + ', ' + end + '] -> [' + firstChar + ', ' + (lastChar + 1) + ']');\n\t\t}\n\n\t\tif (storeName) {\n\t\t\tthis.nameLocations[start] = this.original.slice(start, end);\n\t\t}\n\n\t\tthis.str = this.str.substr(0, firstChar) + content + this.str.substring(lastChar + 1);\n\n\t\td = content.length - (lastChar + 1 - firstChar);\n\n\t\tblank(this.mappings, start, end);\n\t\tadjust(this.mappings, end, this.mappings.length, d);\n\t\treturn this;\n\t};\n\n\tMagicString.prototype.prepend = function prepend(content) {\n\t\tthis.str = content + this.str;\n\t\tadjust(this.mappings, 0, this.mappings.length, content.length);\n\t\treturn this;\n\t};\n\n\tMagicString.prototype.remove = function remove(start, end) {\n\t\tif (start < 0 || end > this.mappings.length) {\n\t\t\tthrow new Error('Character is out of bounds');\n\t\t}\n\n\t\tvar currentStart = -1;\n\t\tvar currentEnd = -1;\n\t\tfor (var i = start; i < end; i += 1) {\n\t\t\tvar loc = this.mappings[i];\n\n\t\t\tif (~loc) {\n\t\t\t\tif (! ~currentStart) currentStart = loc;\n\n\t\t\t\tcurrentEnd = loc + 1;\n\t\t\t\tthis.mappings[i] = -1;\n\t\t\t}\n\t\t}\n\n\t\tthis.str = this.str.slice(0, currentStart) + this.str.slice(currentEnd);\n\n\t\tadjust(this.mappings, end, this.mappings.length, currentStart - currentEnd);\n\t\treturn this;\n\t};\n\n\tMagicString.prototype.replace = function replace(start, end, content) {\n\t\tif (!warned) {\n\t\t\tconsole.warn('magicString.replace(...) is deprecated. Use magicString.overwrite(...) instead');\n\t\t\twarned = true;\n\t\t}\n\n\t\treturn this.overwrite(start, end, content);\n\t};\n\n\tMagicString.prototype.slice = function slice(start) {\n\t\tvar end = arguments.length <= 1 || arguments[1] === undefined ? this.original.length : arguments[1];\n\n\t\tvar firstChar, lastChar;\n\n\t\twhile (start < 0) start += this.original.length;\n\t\twhile (end < 0) end += this.original.length;\n\n\t\tfirstChar = this.locate(start);\n\t\tlastChar = this.locate(end - 1);\n\n\t\tif (firstChar === null || lastChar === null) {\n\t\t\tthrow new Error('Cannot use replaced characters as slice anchors');\n\t\t}\n\n\t\treturn this.str.slice(firstChar, lastChar + 1);\n\t};\n\n\tMagicString.prototype.snip = function snip(start, end) {\n\t\tvar clone = this.clone();\n\t\tclone.remove(0, start);\n\t\tclone.remove(end, clone.original.length);\n\n\t\treturn clone;\n\t};\n\n\tMagicString.prototype.toString = function toString() {\n\t\treturn this.str;\n\t};\n\n\tMagicString.prototype.trimLines = function trimLines() {\n\t\treturn this.trim('[\\\\r\\\\n]');\n\t};\n\n\tMagicString.prototype.trim = function trim(charType) {\n\t\treturn this.trimStart(charType).trimEnd(charType);\n\t};\n\n\tMagicString.prototype.trimEnd = function trimEnd(charType) {\n\t\tvar self = this;\n\t\tvar rx = new RegExp((charType || '\\\\s') + '+$');\n\n\t\tthis.str = this.str.replace(rx, function (trailing, index, str) {\n\t\t\tvar strLength = str.length,\n\t\t\t    length = trailing.length,\n\t\t\t    i,\n\t\t\t    chars = [];\n\n\t\t\ti = strLength;\n\t\t\twhile (i-- > strLength - length) {\n\t\t\t\tchars.push(self.locateOrigin(i));\n\t\t\t}\n\n\t\t\ti = chars.length;\n\t\t\twhile (i--) {\n\t\t\t\tif (chars[i] !== null) {\n\t\t\t\t\tself.mappings[chars[i]] = -1;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn '';\n\t\t});\n\n\t\treturn this;\n\t};\n\n\tMagicString.prototype.trimStart = function trimStart(charType) {\n\t\tvar self = this;\n\t\tvar rx = new RegExp('^' + (charType || '\\\\s') + '+');\n\n\t\tthis.str = this.str.replace(rx, function (leading) {\n\t\t\tvar length = leading.length,\n\t\t\t    i,\n\t\t\t    chars = [],\n\t\t\t    adjustmentStart = 0;\n\n\t\t\ti = length;\n\t\t\twhile (i--) {\n\t\t\t\tchars.push(self.locateOrigin(i));\n\t\t\t}\n\n\t\t\ti = chars.length;\n\t\t\twhile (i--) {\n\t\t\t\tif (chars[i] !== null) {\n\t\t\t\t\tself.mappings[chars[i]] = -1;\n\t\t\t\t\tadjustmentStart += 1;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tadjust(self.mappings, adjustmentStart, self.mappings.length, -length);\n\n\t\t\treturn '';\n\t\t});\n\n\t\treturn this;\n\t};\n\n\treturn MagicString;\n})();\n\nfunction adjust(mappings, start, end, d) {\n\tvar i = end;\n\n\tif (!d) return; // replacement is same length as replaced string\n\n\twhile (i-- > start) {\n\t\tif (~mappings[i]) {\n\t\t\tmappings[i] += d;\n\t\t}\n\t}\n}\n\nfunction initMappings(i) {\n\tvar mappings = new Uint32Array(i);\n\n\twhile (i--) {\n\t\tmappings[i] = i;\n\t}\n\n\treturn mappings;\n}\n\nfunction blank(mappings, start, i) {\n\twhile (i-- > start) {\n\t\tmappings[i] = -1;\n\t}\n}\n\nfunction reverse(mappings, i) {\n\tvar result, location;\n\n\tresult = new Uint32Array(i);\n\n\twhile (i--) {\n\t\tresult[i] = -1;\n\t}\n\n\ti = mappings.length;\n\twhile (i--) {\n\t\tlocation = mappings[i];\n\n\t\tif (~location) {\n\t\t\tresult[location] = i;\n\t\t}\n\t}\n\n\treturn result;\n}\n\nvar hasOwnProp = Object.prototype.hasOwnProperty;\n\nvar _Bundle = (function () {\n\tfunction Bundle() {\n\t\tvar options = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];\n\t\tclassCallCheck(this, Bundle);\n\n\t\tthis.intro = options.intro || '';\n\t\tthis.outro = options.outro || '';\n\t\tthis.separator = options.separator !== undefined ? options.separator : '\\n';\n\n\t\tthis.sources = [];\n\n\t\tthis.uniqueSources = [];\n\t\tthis.uniqueSourceIndexByFilename = {};\n\t}\n\n\tBundle.prototype.addSource = function addSource(source) {\n\t\tif (source instanceof MagicString) {\n\t\t\treturn this.addSource({\n\t\t\t\tcontent: source,\n\t\t\t\tfilename: source.filename,\n\t\t\t\tseparator: this.separator\n\t\t\t});\n\t\t}\n\n\t\tif (typeof source !== 'object' || !source.content) {\n\t\t\tthrow new Error('bundle.addSource() takes an object with a `content` property, which should be an instance of MagicString, and an optional `filename`');\n\t\t}\n\n\t\t['filename', 'indentExclusionRanges', 'separator'].forEach(function (option) {\n\t\t\tif (!hasOwnProp.call(source, option)) source[option] = source.content[option];\n\t\t});\n\n\t\tif (source.separator === undefined) {\n\t\t\t// TODO there's a bunch of this sort of thing, needs cleaning up\n\t\t\tsource.separator = this.separator;\n\t\t}\n\n\t\tif (source.filename) {\n\t\t\tif (!hasOwnProp.call(this.uniqueSourceIndexByFilename, source.filename)) {\n\t\t\t\tthis.uniqueSourceIndexByFilename[source.filename] = this.uniqueSources.length;\n\t\t\t\tthis.uniqueSources.push({ filename: source.filename, content: source.content.original });\n\t\t\t} else {\n\t\t\t\tvar uniqueSource = this.uniqueSources[this.uniqueSourceIndexByFilename[source.filename]];\n\t\t\t\tif (source.content.original !== uniqueSource.content) {\n\t\t\t\t\tthrow new Error('Illegal source: same filename (' + source.filename + '), different contents');\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tthis.sources.push(source);\n\t\treturn this;\n\t};\n\n\tBundle.prototype.append = function append(str, options) {\n\t\tthis.addSource({\n\t\t\tcontent: new MagicString(str),\n\t\t\tseparator: options && options.separator || ''\n\t\t});\n\n\t\treturn this;\n\t};\n\n\tBundle.prototype.clone = function clone() {\n\t\tvar bundle = new Bundle({\n\t\t\tintro: this.intro,\n\t\t\toutro: this.outro,\n\t\t\tseparator: this.separator\n\t\t});\n\n\t\tthis.sources.forEach(function (source) {\n\t\t\tbundle.addSource({\n\t\t\t\tfilename: source.filename,\n\t\t\t\tcontent: source.content.clone(),\n\t\t\t\tseparator: source.separator\n\t\t\t});\n\t\t});\n\n\t\treturn bundle;\n\t};\n\n\tBundle.prototype.generateMap = function generateMap(options) {\n\t\tvar _this = this;\n\n\t\tvar offsets = {};\n\n\t\tvar names = [];\n\t\tthis.sources.forEach(function (source) {\n\t\t\tObject.keys(source.content.nameLocations).forEach(function (location) {\n\t\t\t\tvar name = source.content.nameLocations[location];\n\t\t\t\tif (! ~names.indexOf(name)) names.push(name);\n\t\t\t});\n\t\t});\n\n\t\tvar encoded = getSemis(this.intro) + this.sources.map(function (source, i) {\n\t\t\tvar prefix = i > 0 ? getSemis(source.separator) || ',' : '';\n\t\t\tvar mappings = undefined;\n\n\t\t\t// we don't bother encoding sources without a filename\n\t\t\tif (!source.filename) {\n\t\t\t\tmappings = getSemis(source.content.toString());\n\t\t\t} else {\n\t\t\t\tvar sourceIndex = _this.uniqueSourceIndexByFilename[source.filename];\n\t\t\t\tmappings = source.content.getMappings(options.hires, sourceIndex, offsets, names);\n\t\t\t}\n\n\t\t\treturn prefix + mappings;\n\t\t}).join('') + getSemis(this.outro);\n\n\t\treturn new SourceMap({\n\t\t\tfile: options.file ? options.file.split(/[\\/\\\\]/).pop() : null,\n\t\t\tsources: this.uniqueSources.map(function (source) {\n\t\t\t\treturn options.file ? getRelativePath(options.file, source.filename) : source.filename;\n\t\t\t}),\n\t\t\tsourcesContent: this.uniqueSources.map(function (source) {\n\t\t\t\treturn options.includeContent ? source.content : null;\n\t\t\t}),\n\t\t\tnames: names,\n\t\t\tmappings: encoded\n\t\t});\n\t};\n\n\tBundle.prototype.getIndentString = function getIndentString() {\n\t\tvar indentStringCounts = {};\n\n\t\tthis.sources.forEach(function (source) {\n\t\t\tvar indentStr = source.content.indentStr;\n\n\t\t\tif (indentStr === null) return;\n\n\t\t\tif (!indentStringCounts[indentStr]) indentStringCounts[indentStr] = 0;\n\t\t\tindentStringCounts[indentStr] += 1;\n\t\t});\n\n\t\treturn Object.keys(indentStringCounts).sort(function (a, b) {\n\t\t\treturn indentStringCounts[a] - indentStringCounts[b];\n\t\t})[0] || '\\t';\n\t};\n\n\tBundle.prototype.indent = function indent(indentStr) {\n\t\tvar _this2 = this;\n\n\t\tif (!arguments.length) {\n\t\t\tindentStr = this.getIndentString();\n\t\t}\n\n\t\tif (indentStr === '') return this; // noop\n\n\t\tvar trailingNewline = !this.intro || this.intro.slice(-1) === '\\n';\n\n\t\tthis.sources.forEach(function (source, i) {\n\t\t\tvar separator = source.separator !== undefined ? source.separator : _this2.separator;\n\t\t\tvar indentStart = trailingNewline || i > 0 && /\\r?\\n$/.test(separator);\n\n\t\t\tsource.content.indent(indentStr, {\n\t\t\t\texclude: source.indentExclusionRanges,\n\t\t\t\tindentStart: indentStart //: trailingNewline || /\\r?\\n$/.test( separator )  //true///\\r?\\n/.test( separator )\n\t\t\t});\n\n\t\t\ttrailingNewline = source.content.str.slice(0, -1) === '\\n';\n\t\t});\n\n\t\tif (this.intro) {\n\t\t\tthis.intro = indentStr + this.intro.replace(/^[^\\n]/gm, function (match, index) {\n\t\t\t\treturn index > 0 ? indentStr + match : match;\n\t\t\t});\n\t\t}\n\n\t\tthis.outro = this.outro.replace(/^[^\\n]/gm, indentStr + '$&');\n\n\t\treturn this;\n\t};\n\n\tBundle.prototype.prepend = function prepend(str) {\n\t\tthis.intro = str + this.intro;\n\t\treturn this;\n\t};\n\n\tBundle.prototype.toString = function toString() {\n\t\tvar _this3 = this;\n\n\t\tvar body = this.sources.map(function (source, i) {\n\t\t\tvar separator = source.separator !== undefined ? source.separator : _this3.separator;\n\t\t\tvar str = (i > 0 ? separator : '') + source.content.toString();\n\n\t\t\treturn str;\n\t\t}).join('');\n\n\t\treturn this.intro + body + this.outro;\n\t};\n\n\tBundle.prototype.trimLines = function trimLines() {\n\t\treturn this.trim('[\\\\r\\\\n]');\n\t};\n\n\tBundle.prototype.trim = function trim(charType) {\n\t\treturn this.trimStart(charType).trimEnd(charType);\n\t};\n\n\tBundle.prototype.trimStart = function trimStart(charType) {\n\t\tvar rx = new RegExp('^' + (charType || '\\\\s') + '+');\n\t\tthis.intro = this.intro.replace(rx, '');\n\n\t\tif (!this.intro) {\n\t\t\tvar source = undefined; // TODO put inside loop if safe\n\t\t\tvar i = 0;\n\n\t\t\tdo {\n\t\t\t\tsource = this.sources[i];\n\n\t\t\t\tif (!source) {\n\t\t\t\t\tthis.outro = this.outro.replace(rx, '');\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tsource.content.trimStart();\n\t\t\t\ti += 1;\n\t\t\t} while (source.content.str === '');\n\t\t}\n\n\t\treturn this;\n\t};\n\n\tBundle.prototype.trimEnd = function trimEnd(charType) {\n\t\tvar rx = new RegExp((charType || '\\\\s') + '+$');\n\t\tthis.outro = this.outro.replace(rx, '');\n\n\t\tif (!this.outro) {\n\t\t\tvar source = undefined;\n\t\t\tvar i = this.sources.length - 1;\n\n\t\t\tdo {\n\t\t\t\tsource = this.sources[i];\n\n\t\t\t\tif (!source) {\n\t\t\t\t\tthis.intro = this.intro.replace(rx, '');\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tsource.content.trimEnd(charType);\n\t\t\t\ti -= 1;\n\t\t\t} while (source.content.str === '');\n\t\t}\n\n\t\treturn this;\n\t};\n\n\treturn Bundle;\n})();\n\nfunction getSemis(str) {\n\treturn new Array(str.split('\\n').length).join(';');\n}\n\nMagicString.Bundle = _Bundle;\n\nfunction badExports(option, keys) {\n\tthrow new Error('\\'' + option + '\\' was specified for options.exports, but entry module has following exports: ' + keys.join(', '));\n}\nfunction getExportMode(bundle, exportMode) {\n\tvar exportKeys = keys(bundle.entryModule.exports.names);\n\n\tif (exportMode === 'default') {\n\t\tif (exportKeys.length !== 1 || exportKeys[0] !== 'default') {\n\t\t\tbadExports('default', exportKeys);\n\t\t}\n\t} else if (exportMode === 'none' && exportKeys.length) {\n\t\tbadExports('none', exportKeys);\n\t}\n\n\tif (!exportMode || exportMode === 'auto') {\n\t\tif (exportKeys.length === 0) {\n\t\t\texportMode = 'none';\n\t\t} else if (exportKeys.length === 1 && exportKeys[0] === 'default') {\n\t\t\texportMode = 'default';\n\t\t} else {\n\t\t\texportMode = 'named';\n\t\t}\n\t}\n\n\tif (!/(?:default|named|none)/.test(exportMode)) {\n\t\tthrow new Error('options.exports must be \\'default\\', \\'named\\', \\'none\\', \\'auto\\', or left unspecified (defaults to \\'auto\\')');\n\t}\n\n\treturn exportMode;\n}\n\nvar reservedWords = 'break case class catch const continue debugger default delete do else export extends finally for function if import in instanceof let new return super switch this throw try typeof var void while with yield enum await implements package protected static interface private public'.split(' ');\nvar builtins = 'Infinity NaN undefined null true false eval uneval isFinite isNaN parseFloat parseInt decodeURI decodeURIComponent encodeURI encodeURIComponent escape unescape Object Function Boolean Symbol Error EvalError InternalError RangeError ReferenceError SyntaxError TypeError URIError Number Math Date String RegExp Array Int8Array Uint8Array Uint8ClampedArray Int16Array Uint16Array Int32Array Uint32Array Float32Array Float64Array Map Set WeakMap WeakSet SIMD ArrayBuffer DataView JSON Promise Generator GeneratorFunction Reflect Proxy Intl'.split(' ');\n\nvar blacklisted = _blank();\nreservedWords.concat(builtins).forEach(function (word) {\n\treturn blacklisted[word] = true;\n});\nfunction makeLegalIdentifier(str) {\n\tstr = str.replace(/-(\\w)/g, function (_, letter) {\n\t\treturn letter.toUpperCase();\n\t}).replace(/[^$_a-zA-Z0-9]/g, '_');\n\n\tif (/\\d/.test(str[0]) || blacklisted[str]) str = '_' + str;\n\n\treturn str;\n}\n\n// An external identifier.\n\nvar _Id = (function () {\n\tfunction Id(module, name) {\n\t\tclassCallCheck(this, Id);\n\n\t\tthis.originalName = this.name = name;\n\t\tthis.module = module;\n\n\t\tthis.modifierStatements = [];\n\t}\n\n\t// Flags the identifier as imported by the bundle when marked.\n\n\tId.prototype.mark = function mark() {\n\t\tthis.module.importedByBundle[this.originalName] = true;\n\t\tthis.modifierStatements.forEach(function (stmt) {\n\t\t\treturn stmt.mark();\n\t\t});\n\t};\n\n\treturn Id;\n})();\n\nvar ExternalModule = (function () {\n\tfunction ExternalModule(_ref) {\n\t\tvar _this = this;\n\n\t\tvar id = _ref.id;\n\t\tvar bundle = _ref.bundle;\n\t\tclassCallCheck(this, ExternalModule);\n\n\t\tthis.id = id;\n\n\t\t// Implement `Identifier` interface.\n\t\tthis.originalName = this.name = makeLegalIdentifier(id);\n\t\tthis.module = this;\n\t\tthis.isModule = true;\n\n\t\t// Define the external module's name in the bundle scope.\n\t\tbundle.scope.define(id, this);\n\n\t\tthis.isExternal = true;\n\t\tthis.importedByBundle = _blank();\n\n\t\t// Invariant: needsNamed and needsAll are never both true at once.\n\t\t// Because an import with both a namespace and named import is invalid:\n\t\t//\n\t\t// \t\timport * as ns, { a } from '...'\n\t\t//\n\t\tthis.needsNamed = false;\n\t\tthis.needsAll = false;\n\n\t\tthis.exports = bundle.scope.virtual(false);\n\n\t\tvar reference = this.exports.reference;\n\n\t\t// Override reference.\n\t\tthis.exports.reference = function (name) {\n\t\t\tif (name !== 'default') {\n\t\t\t\t_this.needsNamed = true;\n\t\t\t}\n\n\t\t\tif (!_this.exports.defines(name)) {\n\t\t\t\t_this.exports.define(name, new _Id(_this, name));\n\t\t\t}\n\n\t\t\treturn reference.call(_this.exports, name);\n\t\t};\n\t}\n\n\t// External modules are always marked for inclusion in the bundle.\n\t// Marking an external module signals its use as a namespace.\n\n\tExternalModule.prototype.mark = function mark() {\n\t\tthis.needsAll = true;\n\t};\n\n\treturn ExternalModule;\n})();\n\nvar shouldSkip = undefined;\nvar shouldAbort = undefined;\nfunction walk(ast, _ref) {\n\tvar enter = _ref.enter;\n\tvar leave = _ref.leave;\n\n\tshouldAbort = false;\n\tvisit(ast, null, enter, leave);\n}\n\nvar context = {\n\tskip: function () {\n\t\treturn shouldSkip = true;\n\t},\n\tabort: function () {\n\t\treturn shouldAbort = true;\n\t}\n};\n\nvar childKeys = _blank();\n\nvar toString = Object.prototype.toString;\n\nfunction isArray(thing) {\n\treturn toString.call(thing) === '[object Array]';\n}\n\nfunction visit(node, parent, enter, leave) {\n\tif (!node || shouldAbort) return;\n\n\tif (enter) {\n\t\tshouldSkip = false;\n\t\tenter.call(context, node, parent);\n\t\tif (shouldSkip || shouldAbort) return;\n\t}\n\n\tvar keys = childKeys[node.type] || (childKeys[node.type] = Object.keys(node).filter(function (key) {\n\t\treturn typeof node[key] === 'object';\n\t}));\n\n\tvar key = undefined,\n\t    value = undefined,\n\t    i = undefined,\n\t    j = undefined;\n\n\ti = keys.length;\n\twhile (i--) {\n\t\tkey = keys[i];\n\t\tvalue = node[key];\n\n\t\tif (isArray(value)) {\n\t\t\tj = value.length;\n\t\t\twhile (j--) {\n\t\t\t\tvisit(value[j], node, enter, leave);\n\t\t\t}\n\t\t} else if (value && value.type) {\n\t\t\tvisit(value, node, enter, leave);\n\t\t}\n\t}\n\n\tif (leave && !shouldAbort) {\n\t\tleave(node, parent);\n\t}\n}\n\nfunction getLocation(source, charIndex) {\n\tvar lines = source.split('\\n');\n\tvar len = lines.length;\n\n\tvar lineStart = 0;\n\tvar i = undefined;\n\n\tfor (i = 0; i < len; i += 1) {\n\t\tvar line = lines[i];\n\t\tvar lineEnd = lineStart + line.length + 1; // +1 for newline\n\n\t\tif (lineEnd > charIndex) {\n\t\t\treturn { line: i + 1, column: charIndex - lineStart };\n\t\t}\n\n\t\tlineStart = lineEnd;\n\t}\n\n\tthrow new Error('Could not determine location of character');\n}\n\nvar extractors = {\n\tIdentifier: function (names, param) {\n\t\tnames.push(param.name);\n\t},\n\n\tObjectPattern: function (names, param) {\n\t\tparam.properties.forEach(function (prop) {\n\t\t\textractors[prop.key.type](names, prop.key);\n\t\t});\n\t},\n\n\tArrayPattern: function (names, param) {\n\t\tparam.elements.forEach(function (element) {\n\t\t\tif (element) extractors[element.type](names, element);\n\t\t});\n\t},\n\n\tRestElement: function (names, param) {\n\t\textractors[param.argument.type](names, param.argument);\n\t},\n\n\tAssignmentPattern: function (names, param) {\n\t\treturn extractors[param.left.type](names, param.left);\n\t}\n};\n\nfunction extractNames(param) {\n\tvar names = [];\n\n\textractors[param.type](names, param);\n\treturn names;\n}\n\nvar _Scope = (function () {\n\tfunction Scope(options) {\n\t\tvar _this = this;\n\n\t\tclassCallCheck(this, Scope);\n\n\t\toptions = options || {};\n\n\t\tthis.parent = options.parent;\n\t\tthis.depth = this.parent ? this.parent.depth + 1 : 0;\n\t\tthis.declarations = _blank();\n\t\tthis.isBlockScope = !!options.block;\n\n\t\tthis.varDeclarations = [];\n\n\t\tif (options.params) {\n\t\t\toptions.params.forEach(function (param) {\n\t\t\t\textractNames(param).forEach(function (name) {\n\t\t\t\t\t_this.declarations[name] = true;\n\t\t\t\t});\n\t\t\t});\n\t\t}\n\t}\n\n\tScope.prototype.addDeclaration = function addDeclaration(declaration, isBlockDeclaration, isVar) {\n\t\tvar _this2 = this;\n\n\t\tif (!isBlockDeclaration && this.isBlockScope) {\n\t\t\t// it's a `var` or function node, and this\n\t\t\t// is a block scope, so we need to go up\n\t\t\tthis.parent.addDeclaration(declaration, isBlockDeclaration, isVar);\n\t\t} else {\n\t\t\textractNames(declaration.id).forEach(function (name) {\n\t\t\t\t_this2.declarations[name] = true;\n\t\t\t\tif (isVar) _this2.varDeclarations.push(name);\n\t\t\t});\n\t\t}\n\t};\n\n\tScope.prototype.contains = function contains(name) {\n\t\treturn this.declarations[name] || (this.parent ? this.parent.contains(name) : false);\n\t};\n\n\tScope.prototype.findDefiningScope = function findDefiningScope(name) {\n\t\tif (this.declarations[name]) {\n\t\t\treturn this;\n\t\t}\n\n\t\tif (this.parent) {\n\t\t\treturn this.parent.findDefiningScope(name);\n\t\t}\n\n\t\treturn null;\n\t};\n\n\treturn Scope;\n})();\n\nvar blockDeclarations = {\n\t'const': true,\n\t'let': true\n};\n\nvar modifierNodes = {\n\tAssignmentExpression: 'left',\n\tUpdateExpression: 'argument'\n};\n\nfunction isIife(node, parent) {\n\treturn parent && parent.type === 'CallExpression' && node === parent.callee;\n}\n\nfunction isFunctionDeclaration(node, parent) {\n\t// `function foo () {}`\n\tif (node.type === 'FunctionDeclaration') return true;\n\n\t// `var foo = function () {}` - same thing for present purposes\n\tif (node.type === 'FunctionExpression' && parent.type === 'VariableDeclarator') return true;\n}\n\nfunction chainedMemberExpression(node) {\n\tif (node.object.type === 'MemberExpression') {\n\t\treturn chainedMemberExpression(node.object) + '.' + node.property.name;\n\t}\n\n\treturn node.object.name + '.' + node.property.name;\n}\n\nvar Statement = (function () {\n\tfunction Statement(node, module, start, end) {\n\t\tclassCallCheck(this, Statement);\n\n\t\tthis.node = node;\n\t\tthis.module = module;\n\t\tthis.start = start;\n\t\tthis.end = end;\n\t\tthis.next = null; // filled in later\n\n\t\tthis.scope = new _Scope();\n\t\tthis.defines = _blank();\n\t\tthis.dependsOn = _blank();\n\t\tthis.stronglyDependsOn = _blank();\n\n\t\tthis.reassigns = _blank();\n\n\t\t// TODO: make this more efficient\n\t\tthis.dependantIds = [];\n\t\tthis.namespaceReplacements = [];\n\n\t\tthis.isIncluded = false;\n\n\t\tthis.isImportDeclaration = node.type === 'ImportDeclaration';\n\t\tthis.isExportDeclaration = /^Export/.test(node.type);\n\t\tthis.isReexportDeclaration = this.isExportDeclaration && !!node.source;\n\t}\n\n\tStatement.prototype.analyse = function analyse() {\n\t\tvar _this = this;\n\n\t\tif (this.isImportDeclaration) return; // nothing to analyse\n\n\t\t// `export { name } from './other'` is a special case\n\t\tif (this.isReexportDeclaration) {\n\t\t\tthis.node.specifiers && this.node.specifiers.forEach(function (specifier) {\n\t\t\t\tvar id = _this.module.exports.lookup(specifier.exported.name);\n\n\t\t\t\tif (! ~_this.dependantIds.indexOf(id)) {\n\t\t\t\t\t_this.dependantIds.push(id);\n\t\t\t\t}\n\t\t\t});\n\n\t\t\treturn;\n\t\t}\n\n\t\tvar scope = this.scope;\n\n\t\twalk(this.node, {\n\t\t\tenter: function (node, parent) {\n\t\t\t\tvar newScope = undefined;\n\n\t\t\t\tswitch (node.type) {\n\t\t\t\t\tcase 'FunctionDeclaration':\n\t\t\t\t\t\tscope.addDeclaration(node, false, false);\n\n\t\t\t\t\tcase 'BlockStatement':\n\t\t\t\t\t\tif (parent && /Function/.test(parent.type)) {\n\t\t\t\t\t\t\tnewScope = new _Scope({\n\t\t\t\t\t\t\t\tparent: scope,\n\t\t\t\t\t\t\t\tblock: false,\n\t\t\t\t\t\t\t\tparams: parent.params\n\t\t\t\t\t\t\t});\n\n\t\t\t\t\t\t\t// named function expressions - the name is considered\n\t\t\t\t\t\t\t// part of the function's scope\n\t\t\t\t\t\t\tif (parent.type === 'FunctionExpression' && parent.id) {\n\t\t\t\t\t\t\t\tnewScope.addDeclaration(parent, false, false);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tnewScope = new _Scope({\n\t\t\t\t\t\t\t\tparent: scope,\n\t\t\t\t\t\t\t\tblock: true\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'CatchClause':\n\t\t\t\t\t\tnewScope = new _Scope({\n\t\t\t\t\t\t\tparent: scope,\n\t\t\t\t\t\t\tparams: [node.param],\n\t\t\t\t\t\t\tblock: true\n\t\t\t\t\t\t});\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'VariableDeclaration':\n\t\t\t\t\t\tnode.declarations.forEach(function (declarator) {\n\t\t\t\t\t\t\tvar isBlockDeclaration = node.type === 'VariableDeclaration' && blockDeclarations[node.kind];\n\t\t\t\t\t\t\tscope.addDeclaration(declarator, isBlockDeclaration, true);\n\t\t\t\t\t\t});\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'ClassDeclaration':\n\t\t\t\t\t\tscope.addDeclaration(node, false, false);\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tif (newScope) {\n\t\t\t\t\tObject.defineProperty(node, '_scope', {\n\t\t\t\t\t\tvalue: newScope,\n\t\t\t\t\t\tconfigurable: true\n\t\t\t\t\t});\n\n\t\t\t\t\tscope = newScope;\n\t\t\t\t}\n\t\t\t},\n\t\t\tleave: function (node) {\n\t\t\t\tif (node._scope) {\n\t\t\t\t\tscope = scope.parent;\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\n\t\t// This allows us to track whether we're looking at code that will\n\t\t// be executed immediately (either outside a function, or immediately\n\t\t// inside an IIFE), for the purposes of determining whether dependencies\n\t\t// are strong or weak. It's not bulletproof, since it wouldn't catch...\n\t\t//\n\t\t//    var calledImmediately = function () {\n\t\t//      doSomethingWith( strongDependency );\n\t\t//    }\n\t\t//    calledImmediately();\n\t\t//\n\t\t// ...but it's better than nothing\n\t\tvar readDepth = 0;\n\n\t\t// This allows us to track whether a modifying statement (i.e. assignment\n\t\t// /update expressions) need to be captured\n\t\tvar writeDepth = 0;\n\n\t\t// Used to track\n\t\tvar topName = undefined;\n\t\tvar currentMemberExpression = null;\n\t\tvar namespace = null;\n\n\t\tif (!this.isImportDeclaration) {\n\t\t\twalk(this.node, {\n\t\t\t\tenter: function (node, parent) {\n\t\t\t\t\tif (isFunctionDeclaration(node, parent)) writeDepth += 1;\n\t\t\t\t\tif (/Function/.test(node.type) && !isIife(node, parent)) readDepth += 1;\n\n\t\t\t\t\tif (node._scope) scope = node._scope;\n\n\t\t\t\t\t_this.checkForReads(scope, node, parent, !readDepth);\n\t\t\t\t\t_this.checkForWrites(scope, node, writeDepth);\n\t\t\t\t},\n\t\t\t\tleave: function (node, parent) {\n\t\t\t\t\tif (isFunctionDeclaration(node, parent)) writeDepth -= 1;\n\t\t\t\t\tif (/Function/.test(node.type) && !isIife(node, parent)) readDepth -= 1;\n\n\t\t\t\t\tif (node._scope) scope = scope.parent;\n\n\t\t\t\t\t// Optimize namespace lookups, which manifest as MemberExpressions.\n\t\t\t\t\tif (node.type === 'MemberExpression' && (!currentMemberExpression || node.object === currentMemberExpression)) {\n\t\t\t\t\t\tcurrentMemberExpression = node;\n\n\t\t\t\t\t\tif (!namespace) {\n\t\t\t\t\t\t\ttopName = node.object.name;\n\t\t\t\t\t\t\tvar _id = _this.module.locals.lookup(topName);\n\n\t\t\t\t\t\t\tif (!_id || !_id.isModule || _id.isExternal) return;\n\n\t\t\t\t\t\t\tnamespace = _id;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// If a namespace is the left hand side of an assignment, throw an error.\n\t\t\t\t\t\tif (parent.type === 'AssignmentExpression' && parent.left === node || parent.type === 'UpdateExpression' && parent.argument === node) {\n\t\t\t\t\t\t\tvar err = new Error('Illegal reassignment to import \\'' + chainedMemberExpression(node) + '\\'');\n\t\t\t\t\t\t\terr.file = _this.module.id;\n\t\t\t\t\t\t\terr.loc = getLocation(_this.module.magicString.toString(), node.start);\n\t\t\t\t\t\t\tthrow err;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// Extract the name of the accessed property, from and Identifier or Literal.\n\t\t\t\t\t\t// Any eventual Literal value is converted to a string.\n\t\t\t\t\t\tvar _name = !node.computed ? node.property.name : node.property.type === 'Literal' ? String(node.property.value) : null;\n\n\t\t\t\t\t\t// If we can't resolve the name being accessed statically,\n\t\t\t\t\t\t// we mark the whole namespace for inclusion in the bundle.\n\t\t\t\t\t\t//\n\t\t\t\t\t\t//     // resolvable\n\t\t\t\t\t\t//     console.log( javascript.keywords.for )\n\t\t\t\t\t\t//     console.log( javascript.keywords[ 'for' ] )\n\t\t\t\t\t\t//     console.log( javascript.keywords[ 6 ] )\n\t\t\t\t\t\t//\n\t\t\t\t\t\t//     // unresolvable\n\t\t\t\t\t\t//     console.log( javascript.keywords[ index ] )\n\t\t\t\t\t\t//     console.log( javascript.keywords[ 1 + 5 ] )\n\t\t\t\t\t\tif (_name === null) {\n\t\t\t\t\t\t\tnamespace.mark();\n\n\t\t\t\t\t\t\tnamespace = null;\n\t\t\t\t\t\t\tcurrentMemberExpression = null;\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tvar id = namespace.exports.lookup(_name);\n\n\t\t\t\t\t\t// If the namespace doesn't define the given name,\n\t\t\t\t\t\t// we can throw an error (even for nested namespaces).\n\t\t\t\t\t\tif (!id) {\n\t\t\t\t\t\t\tthrow new Error('Module doesn\\'t define \"' + _name + '\"!');\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// We can't resolve deeper. Replace the member chain.\n\t\t\t\t\t\tif (parent.type !== 'MemberExpression' || !(id.isModule && !id.isExternal)) {\n\t\t\t\t\t\t\tif (! ~_this.dependantIds.indexOf(id)) {\n\t\t\t\t\t\t\t\t_this.dependantIds.push(id);\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t// FIXME: do this better\n\t\t\t\t\t\t\t// If we depend on this name...\n\t\t\t\t\t\t\tif (_this.dependsOn[topName]) {\n\t\t\t\t\t\t\t\t// ... decrement the count...\n\t\t\t\t\t\t\t\tif (! --_this.dependsOn[topName]) {\n\t\t\t\t\t\t\t\t\t// ... and remove it if the count is 0.\n\t\t\t\t\t\t\t\t\tdelete _this.dependsOn[topName];\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t_this.namespaceReplacements.push([node, id]);\n\t\t\t\t\t\t\tnamespace = null;\n\t\t\t\t\t\t\tcurrentMemberExpression = null;\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tnamespace = id;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\n\t\tkeys(scope.declarations).forEach(function (name) {\n\t\t\t_this.defines[name] = true;\n\t\t});\n\t};\n\n\tStatement.prototype.checkForReads = function checkForReads(scope, node, parent, strong) {\n\t\tif (node.type === 'Identifier') {\n\t\t\t// disregard the `bar` in `foo.bar` - these appear as Identifier nodes\n\t\t\tif (parent.type === 'MemberExpression' && !parent.computed && node !== parent.object) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// disregard the `bar` in { bar: foo }\n\t\t\tif (parent.type === 'Property' && node !== parent.value) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// disregard the `bar` in `class Foo { bar () {...} }`\n\t\t\tif (parent.type === 'MethodDefinition') return;\n\n\t\t\t// disregard the `bar` in `export { foo as bar }`\n\t\t\tif (parent.type === 'ExportSpecifier' && node !== parent.local) return;\n\n\t\t\tvar definingScope = scope.findDefiningScope(node.name);\n\n\t\t\tif (!definingScope || definingScope.depth === 0) {\n\t\t\t\tif (!(node.name in this.dependsOn)) {\n\t\t\t\t\tthis.dependsOn[node.name] = 0;\n\t\t\t\t}\n\n\t\t\t\tthis.dependsOn[node.name]++;\n\t\t\t\tif (strong) this.stronglyDependsOn[node.name] = true;\n\t\t\t}\n\t\t}\n\t};\n\n\tStatement.prototype.checkForWrites = function checkForWrites(scope, node, writeDepth) {\n\t\tvar _this2 = this;\n\n\t\tvar addNode = function (node, isAssignment) {\n\t\t\tvar depth = 0; // determine whether we're illegally modifying a binding or namespace\n\n\t\t\twhile (node.type === 'MemberExpression') {\n\t\t\t\tnode = node.object;\n\t\t\t\tdepth += 1;\n\t\t\t}\n\n\t\t\t// disallow assignments/updates to imported bindings and namespaces\n\t\t\tif (isAssignment) {\n\t\t\t\tvar importSpecifier = _this2.module.locals.lookup(node.name);\n\n\t\t\t\tif (importSpecifier && importSpecifier.module !== _this2.module && !scope.contains(node.name)) {\n\t\t\t\t\tvar minDepth = importSpecifier.name === '*' ? 2 : // cannot do e.g. `namespace.foo = bar`\n\t\t\t\t\t1; // cannot do e.g. `foo = bar`, but `foo.bar = bar` is fine\n\n\t\t\t\t\tif (depth < minDepth) {\n\t\t\t\t\t\tvar err = new Error('Illegal reassignment to import \\'' + node.name + '\\'');\n\t\t\t\t\t\terr.file = _this2.module.id;\n\t\t\t\t\t\terr.loc = getLocation(_this2.module.magicString.toString(), node.start);\n\t\t\t\t\t\tthrow err;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// special case = `export default foo; foo += 1;` - we'll\n\t\t\t\t// need to assign a new variable so that the exported\n\t\t\t\t// value is not updated by the second statement\n\t\t\t\tvar def = _this2.module.exports.lookup('default');\n\t\t\t\tif (def && depth === 0 && def.name === node.name) {\n\t\t\t\t\t// but only if this is a) inside a function body or\n\t\t\t\t\t// b) after the export declaration\n\t\t\t\t\tif (!!scope.parent || node.start > def.statement.node.start) {\n\t\t\t\t\t\tdef.isModified = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// we track updates/reassignments to variables, to know whether we\n\t\t\t\t// need to rewrite it later from `foo` to `exports.foo` to keep\n\t\t\t\t// bindings live\n\t\t\t\tif (depth === 0 && writeDepth > 0 && !scope.contains(node.name)) {\n\t\t\t\t\t_this2.reassigns[node.name] = true;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// we only care about writes that happen a) at the top level,\n\t\t\t// or b) inside a function that could be immediately invoked.\n\t\t\t// Writes inside named functions are only relevant if the\n\t\t\t// function is called, in which case we don't need to do\n\t\t\t// anything (but we still need to call checkForWrites to\n\t\t\t// catch illegal reassignments to imported bindings)\n\t\t\tif (writeDepth === 0 && node.type === 'Identifier') {\n\t\t\t\tvar id = _this2.module.locals.lookup(node.name);\n\n\t\t\t\tif (id && id.modifierStatements && ! ~id.modifierStatements.indexOf(_this2)) {\n\t\t\t\t\tid.modifierStatements.push(_this2);\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\n\t\tif (node.type === 'AssignmentExpression') {\n\t\t\taddNode(node.left, true);\n\t\t} else if (node.type === 'UpdateExpression') {\n\t\t\taddNode(node.argument, true);\n\t\t} else if (node.type === 'CallExpression') {\n\t\t\tnode.arguments.forEach(function (arg) {\n\t\t\t\treturn addNode(arg, false);\n\t\t\t});\n\n\t\t\t// `foo.bar()` is assumed to mutate foo\n\t\t\tif (node.callee.type === 'MemberExpression') {\n\t\t\t\taddNode(node.callee);\n\t\t\t}\n\t\t}\n\t};\n\n\tStatement.prototype.mark = function mark() {\n\t\tvar _this3 = this;\n\n\t\tif (this.isIncluded) return; // prevent infinite loops\n\t\tthis.isIncluded = true;\n\n\t\tthis.dependantIds.forEach(function (id) {\n\t\t\treturn id.mark();\n\t\t});\n\n\t\t// TODO: perhaps these could also be added?\n\t\tkeys(this.dependsOn).forEach(function (name) {\n\t\t\tif (_this3.defines[name]) return; // TODO maybe exclude from `this.dependsOn` in the first place?\n\t\t\t_this3.module.locals.lookup(name).mark();\n\t\t});\n\t};\n\n\tStatement.prototype.markSideEffect = function markSideEffect() {\n\t\tvar statement = this;\n\n\t\twalk(this.node, {\n\t\t\tenter: function (node, parent) {\n\t\t\t\tif (/Function/.test(node.type) && !isIife(node, parent)) return this.skip();\n\n\t\t\t\t// If this is a top-level call expression, or an assignment to a global,\n\t\t\t\t// this statement will need to be marked\n\t\t\t\tif (node.type === 'CallExpression') {\n\t\t\t\t\tstatement.mark();\n\t\t\t\t} else if (node.type in modifierNodes) {\n\t\t\t\t\tvar subject = node[modifierNodes[node.type]];\n\t\t\t\t\twhile (subject.type === 'MemberExpression') subject = subject.object;\n\n\t\t\t\t\tif (statement.module.bundle.globals.defines(subject.name)) statement.mark();\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t};\n\n\tStatement.prototype.replaceIdentifiers = function replaceIdentifiers(magicString, names, bundleExports) {\n\t\tvar statement = this;\n\n\t\tvar replacementStack = [];\n\t\tvar nameList = keys(names);\n\n\t\tvar deshadowList = [];\n\t\tnameList.forEach(function (name) {\n\t\t\tvar replacement = names[name];\n\t\t\tdeshadowList.push(replacement.split('.')[0]);\n\t\t});\n\n\t\tvar topLevel = true;\n\t\tvar depth = 0;\n\n\t\twalk(this.node, {\n\t\t\tenter: function (node, parent) {\n\t\t\t\tvar _this4 = this;\n\n\t\t\t\tif (node._skip) return this.skip();\n\n\t\t\t\tif (/^Function/.test(node.type)) depth += 1;\n\n\t\t\t\t// `this` is undefined at the top level of ES6 modules\n\t\t\t\tif (node.type === 'ThisExpression' && depth === 0) {\n\t\t\t\t\tmagicString.overwrite(node.start, node.end, 'undefined', true);\n\t\t\t\t}\n\n\t\t\t\t// special case - variable declarations that need to be rewritten\n\t\t\t\t// as bundle exports\n\t\t\t\tif (topLevel) {\n\t\t\t\t\tif (node.type === 'VariableDeclaration') {\n\t\t\t\t\t\t// if this contains a single declarator, and it's one that\n\t\t\t\t\t\t// needs to be rewritten, we replace the whole lot\n\t\t\t\t\t\tvar id = node.declarations[0].id;\n\t\t\t\t\t\tvar _name2 = id.name;\n\n\t\t\t\t\t\tif (node.declarations.length === 1 && bundleExports[_name2]) {\n\t\t\t\t\t\t\tmagicString.overwrite(node.start, id.end, bundleExports[_name2], true);\n\t\t\t\t\t\t\tid._skip = true;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// otherwise, we insert the `exports.foo = foo` after the declaration\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\tvar exportInitialisers = node.declarations.map(function (declarator) {\n\t\t\t\t\t\t\t\t\treturn declarator.id.name;\n\t\t\t\t\t\t\t\t}).filter(function (name) {\n\t\t\t\t\t\t\t\t\treturn !!bundleExports[name];\n\t\t\t\t\t\t\t\t}).map(function (name) {\n\t\t\t\t\t\t\t\t\treturn '\\n' + bundleExports[name] + ' = ' + name + ';';\n\t\t\t\t\t\t\t\t}).join('');\n\n\t\t\t\t\t\t\t\tif (exportInitialisers) {\n\t\t\t\t\t\t\t\t\t// TODO clean this up\n\t\t\t\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t\t\t\tmagicString.insert(node.end, exportInitialisers);\n\t\t\t\t\t\t\t\t\t} catch (err) {\n\t\t\t\t\t\t\t\t\t\tmagicString.append(exportInitialisers);\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tvar scope = node._scope;\n\n\t\t\t\tif (scope) {\n\t\t\t\t\tvar _ret = (function () {\n\t\t\t\t\t\ttopLevel = false;\n\n\t\t\t\t\t\tvar newNames = _blank();\n\t\t\t\t\t\tvar hasReplacements = undefined;\n\n\t\t\t\t\t\tkeys(names).forEach(function (name) {\n\t\t\t\t\t\t\tif (!scope.declarations[name]) {\n\t\t\t\t\t\t\t\tnewNames[name] = names[name];\n\t\t\t\t\t\t\t\thasReplacements = true;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t});\n\n\t\t\t\t\t\tdeshadowList.forEach(function (name) {\n\t\t\t\t\t\t\tif (scope.declarations[name]) {\n\t\t\t\t\t\t\t\tnewNames[name] = name + '$$'; // TODO better mechanism\n\t\t\t\t\t\t\t\thasReplacements = true;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t});\n\n\t\t\t\t\t\tif (!hasReplacements && depth > 0) {\n\t\t\t\t\t\t\treturn {\n\t\t\t\t\t\t\t\tv: _this4.skip()\n\t\t\t\t\t\t\t};\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tnames = newNames;\n\t\t\t\t\t\treplacementStack.push(newNames);\n\t\t\t\t\t})();\n\n\t\t\t\t\tif (typeof _ret === 'object') return _ret.v;\n\t\t\t\t}\n\n\t\t\t\tif (node.type === 'MemberExpression') {\n\t\t\t\t\tvar replacements = statement.namespaceReplacements;\n\t\t\t\t\tfor (var i = 0; i < replacements.length; i += 1) {\n\t\t\t\t\t\tvar _replacements$i = replacements[i];\n\t\t\t\t\t\tvar _top = _replacements$i[0];\n\t\t\t\t\t\tvar id = _replacements$i[1];\n\n\t\t\t\t\t\tif (node === _top) {\n\t\t\t\t\t\t\tmagicString.overwrite(node.start, node.end, id.name);\n\t\t\t\t\t\t\treturn this.skip();\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (node.type !== 'Identifier') return;\n\n\t\t\t\t// if there's no replacement, or it's the same, there's nothing more to do\n\t\t\t\tvar name = names[node.name];\n\t\t\t\tif (!name || name === node.name) return;\n\n\t\t\t\t// shorthand properties (`obj = { foo }`) need to be expanded\n\t\t\t\tif (parent.type === 'Property' && parent.shorthand) {\n\t\t\t\t\tmagicString.insert(node.end, ': ' + name);\n\t\t\t\t\tparent.key._skip = true;\n\t\t\t\t\tparent.value._skip = true; // redundant, but defensive\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\t// property names etc can be disregarded\n\t\t\t\tif (parent.type === 'MemberExpression' && !parent.computed && node !== parent.object) return;\n\t\t\t\tif (parent.type === 'Property' && node !== parent.value) return;\n\t\t\t\tif (parent.type === 'MethodDefinition' && node === parent.key) return;\n\t\t\t\tif (parent.type === 'FunctionExpression') return;\n\t\t\t\tif (/Function/.test(parent.type) && ~parent.params.indexOf(node)) return;\n\t\t\t\t// TODO others...?\n\n\t\t\t\t// all other identifiers should be overwritten\n\t\t\t\tmagicString.overwrite(node.start, node.end, name, true);\n\t\t\t},\n\n\t\t\tleave: function (node) {\n\t\t\t\tif (/^Function/.test(node.type)) depth -= 1;\n\n\t\t\t\tif (node._scope) {\n\t\t\t\t\tnames = replacementStack.pop();\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\n\t\treturn magicString;\n\t};\n\n\tStatement.prototype.source = function source() {\n\t\treturn this.module.source.slice(this.start, this.end);\n\t};\n\n\tStatement.prototype.toString = function toString() {\n\t\treturn this.module.magicString.slice(this.start, this.end);\n\t};\n\n\treturn Statement;\n})();\n\nfunction isEmptyExportedVarDeclaration(node, exports, toExport) {\n\tif (node.type !== 'VariableDeclaration' || node.declarations[0].init) return false;\n\n\tvar name = node.declarations[0].id.name;\n\n\tvar id = exports.lookup(name);\n\n\treturn id && id.name in toExport;\n}\n\nfunction removeSourceMappingURLComments(source, magicString) {\n\tvar SOURCEMAPPING_URL_PATTERN = new RegExp('\\\\/\\\\/#\\\\s+' + SOURCEMAPPING_URL + '=.+\\\\n?', 'g');\n\tvar match = undefined;\n\n\twhile (match = SOURCEMAPPING_URL_PATTERN.exec(source)) {\n\t\tmagicString.remove(match.index, match.index + match[0].length);\n\t}\n}\n\nfunction assign(target, source) {\n\tfor (var key in source) {\n\t\ttarget[key] = source[key];\n\t}\n}\n\nvar Id = (function () {\n\tfunction Id(module, name, statement) {\n\t\tclassCallCheck(this, Id);\n\n\t\tthis.originalName = this.name = name;\n\t\tthis.module = module;\n\t\tthis.statement = statement;\n\n\t\tthis.modifierStatements = [];\n\n\t\t// modifiers\n\t\tthis.isUsed = false;\n\t}\n\n\tId.prototype.mark = function mark() {\n\t\tthis.isUsed = true;\n\t\tthis.statement.mark();\n\t\tthis.modifierStatements.forEach(function (stmt) {\n\t\t\treturn stmt.mark();\n\t\t});\n\t};\n\n\treturn Id;\n})();\n\nvar Module = (function () {\n\tfunction Module(_ref) {\n\t\tvar _this = this;\n\n\t\tvar id = _ref.id;\n\t\tvar source = _ref.source;\n\t\tvar ast = _ref.ast;\n\t\tvar bundle = _ref.bundle;\n\t\tclassCallCheck(this, Module);\n\n\t\tthis.source = source;\n\n\t\tthis.bundle = bundle;\n\t\tthis.id = id;\n\t\tthis.module = this;\n\t\tthis.isModule = true;\n\n\t\t// Implement Identifier interface.\n\t\tthis.name = makeLegalIdentifier(basename(id).slice(0, -extname(id).length));\n\n\t\t// HACK: If `id` isn't a path, the above code yields the empty string.\n\t\tif (!this.name) {\n\t\t\tthis.name = makeLegalIdentifier(id);\n\t\t}\n\n\t\t// By default, `id` is the filename. Custom resolvers and loaders\n\t\t// can change that, but it makes sense to use it for the source filename\n\t\tthis.magicString = new MagicString(source, {\n\t\t\tfilename: id\n\t\t});\n\n\t\tremoveSourceMappingURLComments(source, this.magicString);\n\n\t\tthis.comments = [];\n\n\t\tthis.statements = this.parse(ast);\n\n\t\t// all dependencies\n\t\tthis.resolvedIds = _blank();\n\n\t\t// Virtual scopes for the local and exported names.\n\t\tthis.locals = bundle.scope.virtual(true);\n\t\tthis.exports = bundle.scope.virtual(false);\n\n\t\tvar _exports = this.exports;\n\t\tvar reference = _exports.reference;\n\t\tvar inScope = _exports.inScope;\n\n\t\tthis.exports.reference = function (name) {\n\t\t\t// If we have it, grab it.\n\t\t\tif (inScope.call(_this.exports, name)) {\n\t\t\t\treturn reference.call(_this.exports, name);\n\t\t\t}\n\n\t\t\t// ... otherwise search allExportsFrom\n\t\t\tfor (var i = 0; i < _this.allExportsFrom.length; i += 1) {\n\t\t\t\tvar _module = _this.allExportsFrom[i];\n\t\t\t\tif (_module.exports.inScope(name)) {\n\t\t\t\t\treturn _module.exports.reference(name);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// throw new Error( `The name \"${name}\" is never exported (from ${this.id})!` );\n\t\t\treturn reference.call(_this.exports, name);\n\t\t};\n\n\t\tthis.exports.inScope = function (name) {\n\t\t\tif (inScope.call(_this.exports, name)) return true;\n\n\t\t\treturn _this.allExportsFrom.some(function (module) {\n\t\t\t\treturn module.exports.inScope(name);\n\t\t\t});\n\t\t};\n\n\t\t// Create a unique virtual scope for references to the module.\n\t\t// const unique = bundle.scope.virtual();\n\t\t// unique.define( this.name, this );\n\t\t// this.reference = unique.reference( this.name );\n\n\t\t// As far as we know, all our exported bindings have been resolved.\n\t\tthis.allExportsResolved = true;\n\t\tthis.allExportsFrom = [];\n\n\t\tthis.reassignments = [];\n\n\t\t// TODO: change to false, and detect when it's necessary.\n\t\tthis.needsDynamicAccess = false;\n\n\t\tthis.dependencies = this.collectDependencies();\n\t}\n\n\tModule.prototype.addExport = function addExport(statement) {\n\t\tvar _this2 = this;\n\n\t\tvar node = statement.node;\n\t\tvar source = node.source && node.source.value;\n\n\t\t// export { name } from './other'\n\t\tif (source) {\n\t\t\t(function () {\n\t\t\t\tvar module = _this2.getModule(source);\n\n\t\t\t\tif (node.type === 'ExportAllDeclaration') {\n\t\t\t\t\t// Store `export * from '...'` statements in an array of delegates.\n\t\t\t\t\t// When an unknown import is encountered, we see if one of them can satisfy it.\n\n\t\t\t\t\tif (module.isExternal) {\n\t\t\t\t\t\tvar err = new Error('Cannot trace \\'export *\\' references through external modules.');\n\t\t\t\t\t\terr.file = _this2.id;\n\t\t\t\t\t\terr.loc = getLocation(_this2.source, node.start);\n\t\t\t\t\t\tthrow err;\n\t\t\t\t\t}\n\n\t\t\t\t\t// It seems like we must re-export all exports from another module...\n\t\t\t\t\t_this2.allExportsResolved = false;\n\n\t\t\t\t\tif (! ~_this2.allExportsFrom.indexOf(module)) {\n\t\t\t\t\t\t_this2.allExportsFrom.push(module);\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tnode.specifiers.forEach(function (specifier) {\n\t\t\t\t\t\t// Bind the export of this module, to the export of the other.\n\t\t\t\t\t\t_this2.exports.bind(specifier.exported.name, module.exports.reference(specifier.local.name));\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t})();\n\t\t}\n\n\t\t// export default function foo () {}\n\t\t// export default foo;\n\t\t// export default 42;\n\t\telse if (node.type === 'ExportDefaultDeclaration') {\n\t\t\t\tvar isDeclaration = /Declaration$/.test(node.declaration.type);\n\t\t\t\tvar isAnonymous = /(?:Class|Function)Expression$/.test(node.declaration.type);\n\n\t\t\t\tvar identifier = isDeclaration ? node.declaration.id.name : node.declaration.type === 'Identifier' ? node.declaration.name : null;\n\t\t\t\tvar _name = identifier || this.name;\n\n\t\t\t\t// Always define a new `Identifier` for the default export.\n\t\t\t\tvar id = new Id(this, _name, statement);\n\n\t\t\t\t// Keep the identifier name, if one exists.\n\t\t\t\t// We can optimize the newly created default `Identifier` away,\n\t\t\t\t// if it is never modified.\n\t\t\t\t// in case of `export default foo; foo = somethingElse`\n\t\t\t\tassign(id, { isDeclaration: isDeclaration, isAnonymous: isAnonymous, identifier: identifier });\n\n\t\t\t\tthis.exports.define('default', id);\n\t\t\t}\n\n\t\t\t// export { foo, bar, baz }\n\t\t\t// export var foo = 42;\n\t\t\t// export function foo () {}\n\t\t\telse if (node.type === 'ExportNamedDeclaration') {\n\t\t\t\t\tif (node.specifiers.length) {\n\t\t\t\t\t\t// export { foo, bar, baz }\n\t\t\t\t\t\tnode.specifiers.forEach(function (specifier) {\n\t\t\t\t\t\t\tvar localName = specifier.local.name;\n\t\t\t\t\t\t\tvar exportedName = specifier.exported.name;\n\n\t\t\t\t\t\t\t_this2.exports.bind(exportedName, _this2.locals.reference(localName));\n\t\t\t\t\t\t});\n\t\t\t\t\t} else {\n\t\t\t\t\t\tvar declaration = node.declaration;\n\n\t\t\t\t\t\tvar _name2 = undefined;\n\n\t\t\t\t\t\tif (declaration.type === 'VariableDeclaration') {\n\t\t\t\t\t\t\t// export var foo = 42\n\t\t\t\t\t\t\t_name2 = declaration.declarations[0].id.name;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t// export function foo () {}\n\t\t\t\t\t\t\t_name2 = declaration.id.name;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tthis.locals.define(_name2, new Id(this, _name2, statement));\n\t\t\t\t\t\tthis.exports.bind(_name2, this.locals.reference(_name2));\n\t\t\t\t\t}\n\t\t\t\t}\n\t};\n\n\tModule.prototype.addImport = function addImport(statement) {\n\t\tvar _this3 = this;\n\n\t\tvar node = statement.node;\n\t\tvar module = this.getModule(node.source.value);\n\n\t\tnode.specifiers.forEach(function (specifier) {\n\t\t\tvar isDefault = specifier.type === 'ImportDefaultSpecifier';\n\t\t\tvar isNamespace = specifier.type === 'ImportNamespaceSpecifier';\n\n\t\t\tvar localName = specifier.local.name;\n\n\t\t\tif (_this3.locals.defines(localName)) {\n\t\t\t\tvar err = new Error('Duplicated import \\'' + localName + '\\'');\n\t\t\t\terr.file = _this3.id;\n\t\t\t\terr.loc = getLocation(_this3.source, specifier.start);\n\t\t\t\tthrow err;\n\t\t\t}\n\n\t\t\tif (isNamespace) {\n\t\t\t\t// If it's a namespace import, we bind the localName to the module itself.\n\t\t\t\tmodule.needsAll = true;\n\t\t\t\tmodule.name = localName;\n\t\t\t\t_this3.locals.bind(localName, module);\n\t\t\t} else {\n\t\t\t\tvar _name3 = isDefault ? 'default' : specifier.imported.name;\n\n\t\t\t\t_this3.locals.bind(localName, module.exports.reference(_name3));\n\n\t\t\t\t// For compliance with earlier Rollup versions.\n\t\t\t\t// If the module is external, and we access the default.\n\t\t\t\t// Rewrite the module name, and the default name to the\n\t\t\t\t// `localName` we use for it.\n\t\t\t\tif (module.isExternal && isDefault) {\n\t\t\t\t\tvar id = module.exports.lookup(_name3);\n\t\t\t\t\tmodule.name = id.name = localName;\n\t\t\t\t\tid.name += '__default';\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t};\n\n\tModule.prototype.analyse = function analyse() {\n\t\tvar _this4 = this;\n\n\t\t// discover this module's imports and exports\n\t\tthis.statements.forEach(function (statement) {\n\t\t\tif (statement.isImportDeclaration) _this4.addImport(statement);else if (statement.isExportDeclaration) _this4.addExport(statement);\n\n\t\t\tstatement.analyse();\n\n\t\t\t// consolidate names that are defined/modified in this module\n\t\t\tkeys(statement.defines).forEach(function (name) {\n\t\t\t\t_this4.locals.define(name, new Id(_this4, name, statement));\n\t\t\t});\n\t\t});\n\n\t\t// If all exports aren't resolved, but all our delegate modules are...\n\t\tif (!this.allExportsResolved && this.allExportsFrom.every(function (module) {\n\t\t\treturn module.allExportsResolved;\n\t\t})) {\n\t\t\t// .. then all our exports should be as well.\n\t\t\tthis.allExportsResolved = true;\n\n\t\t\t// For all modules we export all from, iterate through its exported names.\n\t\t\t// If we don't already define the binding 'name',\n\t\t\t// bind the name to the other module's reference.\n\t\t\tthis.allExportsFrom.forEach(function (module) {\n\t\t\t\tmodule.exports.getNames().forEach(function (name) {\n\t\t\t\t\tif (!_this4.exports.defines(name)) {\n\t\t\t\t\t\t_this4.exports.bind(name, module.exports.reference(name));\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t});\n\t\t}\n\n\t\t// discover variables that are reassigned inside function\n\t\t// bodies, so we can keep bindings live, e.g.\n\t\t//\n\t\t//   export var count = 0;\n\t\t//   export function incr () { count += 1 }\n\t\tvar reassigned = _blank();\n\t\tthis.statements.forEach(function (statement) {\n\t\t\tkeys(statement.reassigns).forEach(function (name) {\n\t\t\t\treassigned[name] = true;\n\t\t\t});\n\t\t});\n\n\t\t// if names are referenced that are neither defined nor imported\n\t\t// in this module, we assume that they're globals\n\t\tthis.statements.forEach(function (statement) {\n\t\t\tif (statement.isReexportDeclaration) return;\n\n\t\t\t// while we're here, mark reassignments\n\t\t\tstatement.scope.varDeclarations.forEach(function (name) {\n\t\t\t\tif (reassigned[name] && ! ~_this4.reassignments.indexOf(name)) {\n\t\t\t\t\t_this4.reassignments.push(name);\n\t\t\t\t}\n\t\t\t});\n\n\t\t\tkeys(statement.dependsOn).forEach(function (name) {\n\t\t\t\t// For each name we depend on that isn't in scope,\n\t\t\t\t// add a new global and bind the local name to it.\n\t\t\t\tif (!_this4.locals.inScope(name)) {\n\t\t\t\t\t_this4.bundle.globals.define(name, {\n\t\t\t\t\t\toriginalName: name,\n\t\t\t\t\t\tname: name,\n\t\t\t\t\t\tmark: function () {}\n\t\t\t\t\t});\n\t\t\t\t\t_this4.locals.bind(name, _this4.bundle.globals.reference(name));\n\t\t\t\t}\n\t\t\t});\n\t\t});\n\n\t\t// OPTIMIZATION!\n\t\t// If we have a default export and it's value is never modified,\n\t\t// bind to it directly.\n\t\tvar def = this.exports.lookup('default');\n\t\tif (def && !def.isModified && def.identifier) {\n\t\t\tthis.exports.bind('default', this.locals.reference(def.identifier));\n\t\t}\n\t};\n\n\t// Returns the set of imported module ids by going through all import/exports statements.\n\n\tModule.prototype.collectDependencies = function collectDependencies() {\n\t\tvar importedModules = _blank();\n\n\t\tthis.statements.forEach(function (statement) {\n\t\t\tif (statement.isImportDeclaration || statement.isExportDeclaration && statement.node.source) {\n\t\t\t\timportedModules[statement.node.source.value] = true;\n\t\t\t}\n\t\t});\n\n\t\treturn keys(importedModules);\n\t};\n\n\tModule.prototype.consolidateDependencies = function consolidateDependencies() {\n\t\tvar _this5 = this;\n\n\t\tvar strongDependencies = _blank();\n\n\t\tfunction addDependency(dependencies, declaration) {\n\t\t\tif (declaration && declaration.module && !declaration.module.isExternal) {\n\t\t\t\tdependencies[declaration.module.id] = declaration.module;\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\n\t\tthis.statements.forEach(function (statement) {\n\t\t\tif (statement.isImportDeclaration && !statement.node.specifiers.length) {\n\t\t\t\t// include module for its side-effects\n\t\t\t\tvar _module2 = _this5.getModule(statement.node.source.value);\n\n\t\t\t\tif (!_module2.isExternal) strongDependencies[_module2.id] = _module2;\n\t\t\t} else if (statement.isReexportDeclaration) {\n\t\t\t\tif (statement.node.specifiers) {\n\t\t\t\t\tstatement.node.specifiers.forEach(function (specifier) {\n\t\t\t\t\t\tvar name = specifier.exported.name;\n\n\t\t\t\t\t\tvar id = _this5.exports.lookup(name);\n\n\t\t\t\t\t\taddDependency(strongDependencies, id);\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tkeys(statement.stronglyDependsOn).forEach(function (name) {\n\t\t\t\t\tif (statement.defines[name]) return;\n\n\t\t\t\t\taddDependency(strongDependencies, _this5.locals.lookup(name));\n\t\t\t\t});\n\t\t\t}\n\t\t});\n\n\t\tvar weakDependencies = _blank();\n\n\t\tthis.statements.forEach(function (statement) {\n\t\t\tkeys(statement.dependsOn).forEach(function (name) {\n\t\t\t\tif (statement.defines[name]) return;\n\n\t\t\t\taddDependency(weakDependencies, _this5.locals.lookup(name));\n\t\t\t});\n\t\t});\n\n\t\t// Go through all our local and exported ids and make us depend on\n\t\t// the defining modules as well as\n\t\tthis.exports.getIds().concat(this.locals.getIds()).forEach(function (id) {\n\t\t\tif (id.module && !id.module.isExternal) {\n\t\t\t\tweakDependencies[id.module.id] = id.module;\n\t\t\t}\n\n\t\t\tif (!id.modifierStatements) return;\n\n\t\t\tid.modifierStatements.forEach(function (statement) {\n\t\t\t\tvar module = statement.module;\n\t\t\t\tweakDependencies[module.id] = module;\n\t\t\t});\n\t\t});\n\n\t\t// `Bundle.sort` gets stuck in an infinite loop if a module has\n\t\t// `strongDependencies` to itself. Make sure it doesn't happen.\n\t\tdelete strongDependencies[this.id];\n\t\tdelete weakDependencies[this.id];\n\n\t\treturn { strongDependencies: strongDependencies, weakDependencies: weakDependencies };\n\t};\n\n\tModule.prototype.getModule = function getModule(source) {\n\t\treturn this.bundle.moduleById[this.resolvedIds[source]];\n\t};\n\n\t// If a module is marked, enforce dynamic access of its properties.\n\n\tModule.prototype.mark = function mark() {\n\t\tif (this.needsDynamicAccess) return;\n\t\tthis.needsDynamicAccess = true;\n\n\t\tthis.markAllExports();\n\t};\n\n\tModule.prototype.markAllSideEffects = function markAllSideEffects() {\n\t\tthis.statements.forEach(function (statement) {\n\t\t\tstatement.markSideEffect();\n\t\t});\n\t};\n\n\tModule.prototype.markAllStatements = function markAllStatements(isEntryModule) {\n\t\tvar _this6 = this;\n\n\t\tthis.statements.forEach(function (statement) {\n\t\t\tif (statement.isIncluded) return; // TODO can this happen? probably not...\n\n\t\t\t// skip import declarations...\n\t\t\tif (statement.isImportDeclaration) {\n\t\t\t\t// ...unless they're empty, in which case assume we're importing them for the side-effects\n\t\t\t\t// THIS IS NOT FOOLPROOF. Probably need /*rollup: include */ or similar\n\t\t\t\tif (!statement.node.specifiers.length) {\n\t\t\t\t\tvar otherModule = _this6.getModule(statement.node.source.value);\n\n\t\t\t\t\tif (!otherModule.isExternal) otherModule.markAllStatements();\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// skip `export { foo, bar, baz }`...\n\t\t\telse if (statement.node.type === 'ExportNamedDeclaration' && statement.node.specifiers.length) {\n\t\t\t\t\t// ...but ensure they are defined, if this is the entry module\n\t\t\t\t\tif (isEntryModule) statement.mark();\n\t\t\t\t}\n\n\t\t\t\t// include everything else\n\t\t\t\telse {\n\t\t\t\t\t\t// Be sure to mark the default export for the entry module.\n\t\t\t\t\t\tif (isEntryModule && statement.node.type === 'ExportDefaultDeclaration') {\n\t\t\t\t\t\t\t_this6.exports.lookup('default').mark();\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tstatement.mark();\n\t\t\t\t\t}\n\t\t});\n\t};\n\n\t// Marks all exported identifiers.\n\n\tModule.prototype.markAllExports = function markAllExports() {\n\t\tthis.exports.getIds().forEach(function (id) {\n\t\t\treturn id.mark();\n\t\t});\n\t};\n\n\tModule.prototype.parse = function parse(ast) {\n\t\tvar _this7 = this;\n\n\t\t// The ast can be supplied programmatically (but usually won't be)\n\t\tif (!ast) {\n\t\t\t// Try to extract a list of top-level statements/declarations. If\n\t\t\t// the parse fails, attach file info and abort\n\t\t\ttry {\n\t\t\t\tast = acorn.parse(this.source, {\n\t\t\t\t\tecmaVersion: 6,\n\t\t\t\t\tsourceType: 'module',\n\t\t\t\t\tonComment: function (block, text, start, end) {\n\t\t\t\t\t\treturn _this7.comments.push({ block: block, text: text, start: start, end: end });\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t} catch (err) {\n\t\t\t\terr.code = 'PARSE_ERROR';\n\t\t\t\terr.file = this.id; // see above - not necessarily true, but true enough\n\t\t\t\tthrow err;\n\t\t\t}\n\t\t}\n\n\t\twalk(ast, {\n\t\t\tenter: function (node) {\n\t\t\t\t_this7.magicString.addSourcemapLocation(node.start);\n\t\t\t\t_this7.magicString.addSourcemapLocation(node.end);\n\t\t\t}\n\t\t});\n\n\t\tvar statements = [];\n\t\tvar lastChar = 0;\n\t\tvar commentIndex = 0;\n\n\t\tast.body.forEach(function (node) {\n\t\t\t// special case - top-level var declarations with multiple declarators\n\t\t\t// should be split up. Otherwise, we may end up including code we\n\t\t\t// don't need, just because an unwanted declarator is included\n\t\t\tif (node.type === 'VariableDeclaration' && node.declarations.length > 1) {\n\t\t\t\t// remove the leading var/let/const... UNLESS the previous node\n\t\t\t\t// was also a synthetic node, in which case it'll get removed anyway\n\t\t\t\tvar lastStatement = statements[statements.length - 1];\n\t\t\t\tif (!lastStatement || !lastStatement.node.isSynthetic) {\n\t\t\t\t\t_this7.magicString.remove(node.start, node.declarations[0].start);\n\t\t\t\t}\n\n\t\t\t\tnode.declarations.forEach(function (declarator) {\n\t\t\t\t\tvar start = declarator.start;\n\t\t\t\t\tvar end = declarator.end;\n\n\t\t\t\t\tvar syntheticNode = {\n\t\t\t\t\t\ttype: 'VariableDeclaration',\n\t\t\t\t\t\tkind: node.kind,\n\t\t\t\t\t\tstart: start,\n\t\t\t\t\t\tend: end,\n\t\t\t\t\t\tdeclarations: [declarator],\n\t\t\t\t\t\tisSynthetic: true\n\t\t\t\t\t};\n\n\t\t\t\t\tvar statement = new Statement(syntheticNode, _this7, start, end);\n\t\t\t\t\tstatements.push(statement);\n\t\t\t\t});\n\n\t\t\t\tlastChar = node.end; // TODO account for trailing line comment\n\t\t\t} else {\n\t\t\t\t\tvar comment = undefined;\n\t\t\t\t\tdo {\n\t\t\t\t\t\tcomment = _this7.comments[commentIndex];\n\t\t\t\t\t\tif (!comment) break;\n\t\t\t\t\t\tif (comment.start > node.start) break;\n\t\t\t\t\t\tcommentIndex += 1;\n\t\t\t\t\t} while (comment.end < lastChar);\n\n\t\t\t\t\tvar start = comment ? Math.min(comment.start, node.start) : node.start;\n\t\t\t\t\tvar end = node.end; // TODO account for trailing line comment\n\n\t\t\t\t\tvar statement = new Statement(node, _this7, start, end);\n\t\t\t\t\tstatements.push(statement);\n\n\t\t\t\t\tlastChar = end;\n\t\t\t\t}\n\t\t});\n\n\t\tstatements.forEach(function (statement, i) {\n\t\t\tvar nextStatement = statements[i + 1];\n\t\t\tstatement.next = nextStatement ? nextStatement.start : statement.end;\n\t\t});\n\n\t\treturn statements;\n\t};\n\n\tModule.prototype.render = function render(toExport, direct) {\n\t\tvar _this8 = this;\n\n\t\tvar magicString = this.magicString.clone();\n\n\t\tthis.statements.forEach(function (statement) {\n\t\t\tif (!statement.isIncluded) {\n\t\t\t\tmagicString.remove(statement.start, statement.next);\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// skip `export { foo, bar, baz }`\n\t\t\tif (statement.node.type === 'ExportNamedDeclaration') {\n\t\t\t\t// skip `export { foo, bar, baz }`\n\t\t\t\tif (statement.node.specifiers.length) {\n\t\t\t\t\tmagicString.remove(statement.start, statement.next);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\t// skip `export var foo;` if foo is exported\n\t\t\t\tif (isEmptyExportedVarDeclaration(statement.node.declaration, _this8.exports, toExport)) {\n\t\t\t\t\tmagicString.remove(statement.start, statement.next);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// skip empty var declarations for exported bindings\n\t\t\t// (otherwise we're left with `exports.foo;`, which is useless)\n\t\t\tif (isEmptyExportedVarDeclaration(statement.node, _this8.exports, toExport)) {\n\t\t\t\tmagicString.remove(statement.start, statement.next);\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// split up/remove var declarations as necessary\n\t\t\tif (statement.node.isSynthetic) {\n\t\t\t\t// insert `var/let/const` if necessary\n\t\t\t\tif (!toExport[statement.node.declarations[0].id.name]) {\n\t\t\t\t\tmagicString.insert(statement.start, statement.node.kind + ' ');\n\t\t\t\t}\n\n\t\t\t\tmagicString.overwrite(statement.end, statement.next, ';\\n'); // TODO account for trailing newlines\n\t\t\t}\n\n\t\t\tvar replacements = _blank();\n\t\t\tvar bundleExports = _blank();\n\n\t\t\t// Indirect identifier access.\n\t\t\tif (!direct) {\n\t\t\t\tkeys(statement.dependsOn).forEach(function (name) {\n\t\t\t\t\tvar id = _this8.locals.lookup(name);\n\n\t\t\t\t\t// We shouldn't create a replacement for `id` if\n\t\t\t\t\t//   1. `id` is a Global, in which case it has no module property\n\t\t\t\t\t//   2. `id.module` isn't external, which means we have direct access\n\t\t\t\t\t//   3. `id` is its own module, in the case of namespace imports\n\t\t\t\t\tif (id.module && id.module.isExternal && id.module !== id) {\n\t\t\t\t\t\treplacements[name] = id.originalName === 'default' ?\n\t\t\t\t\t\t// default names are always directly accessed\n\t\t\t\t\t\tid.name :\n\t\t\t\t\t\t// other names are indirectly accessed\n\t\t\t\t\t\tid.module.name + '.' + id.originalName;\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t}\n\n\t\t\tkeys(statement.dependsOn).concat(keys(statement.defines)).forEach(function (name) {\n\t\t\t\tvar bundleName = _this8.locals.lookup(name).name;\n\n\t\t\t\tif (toExport[bundleName]) {\n\t\t\t\t\tbundleExports[name] = replacements[name] = toExport[bundleName];\n\t\t\t\t} else if (bundleName !== name && !replacements[name]) {\n\t\t\t\t\t// TODO weird structure\n\t\t\t\t\treplacements[name] = bundleName;\n\t\t\t\t}\n\t\t\t});\n\n\t\t\tstatement.replaceIdentifiers(magicString, replacements, bundleExports);\n\n\t\t\t// modify exports as necessary\n\t\t\tif (statement.isExportDeclaration) {\n\t\t\t\t// remove `export` from `export var foo = 42`\n\t\t\t\tif (statement.node.type === 'ExportNamedDeclaration' && statement.node.declaration.type === 'VariableDeclaration') {\n\t\t\t\t\tmagicString.remove(statement.node.start, statement.node.declaration.start);\n\t\t\t\t} else if (statement.node.type === 'ExportAllDeclaration') {\n\t\t\t\t\t// TODO: remove once `export * from 'external'` is supported.\n\t\t\t\t\tmagicString.remove(statement.start, statement.next);\n\t\t\t\t}\n\n\t\t\t\t// remove `export` from `export class Foo {...}` or `export default Foo`\n\t\t\t\t// TODO default exports need different treatment\n\t\t\t\telse if (statement.node.declaration.id) {\n\t\t\t\t\t\tmagicString.remove(statement.node.start, statement.node.declaration.start);\n\t\t\t\t\t} else if (statement.node.type === 'ExportDefaultDeclaration') {\n\t\t\t\t\t\tvar def = _this8.exports.lookup('default');\n\n\t\t\t\t\t\t// FIXME: dunno what to do here yet.\n\t\t\t\t\t\tif (statement.node.declaration.type === 'Identifier' && def.name === (replacements[statement.node.declaration.name] || statement.node.declaration.name)) {\n\t\t\t\t\t\t\tmagicString.remove(statement.start, statement.next);\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// prevent `var undefined = sideEffectyDefault(foo)`\n\t\t\t\t\t\tif (!def.isUsed) {\n\t\t\t\t\t\t\tmagicString.remove(statement.start, statement.node.declaration.start);\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// anonymous functions should be converted into declarations\n\t\t\t\t\t\tif (statement.node.declaration.type === 'FunctionExpression') {\n\t\t\t\t\t\t\tmagicString.overwrite(statement.node.start, statement.node.declaration.start + 8, 'function ' + def.name);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tmagicString.overwrite(statement.node.start, statement.node.declaration.start, 'var ' + def.name + ' = ');\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tthrow new Error('Unhandled export');\n\t\t\t\t\t}\n\t\t\t}\n\t\t});\n\n\t\treturn magicString.trim();\n\t};\n\n\treturn Module;\n})();\n\n// A minimal `Identifier` implementation. Anything that has an `originalName`,\n// and a mutable `name` property can be used as an `Identifier`.\n\nvar Identifier = (function () {\n\tfunction Identifier(name) {\n\t\tclassCallCheck(this, Identifier);\n\n\t\tthis.originalName = this.name = name;\n\t}\n\n\t// A reference to an `Identifier`.\n\n\tIdentifier.prototype.mark = function mark() {\n\t\t// noop\n\t};\n\n\treturn Identifier;\n})();\n\nfunction Reference(scope, index) {\n\tthis.scope = scope;\n\tthis.index = index;\n}\n\n// Dereferences a `Reference`.\nfunction dereference(ref) {\n\treturn ref.scope.ids[ref.index];\n}\n\nfunction isntReference(id) {\n\treturn !(id instanceof Reference);\n}\n\n// Prefix the argument with '_'.\nfunction underscorePrefix(x) {\n\treturn '_' + x;\n}\n\n// ## Scope\n// A Scope is a mapping from string names to `Identifiers`.\n\nvar Scope = (function () {\n\tfunction Scope(parent) {\n\t\tclassCallCheck(this, Scope);\n\n\t\tthis.ids = [];\n\t\tthis.names = _blank();\n\n\t\tthis.parent = parent || null;\n\t\tthis.used = _blank();\n\t}\n\n\t// Binds the `name` to the given reference `ref`.\n\n\tScope.prototype.bind = function bind(name, ref) {\n\t\tthis.ids[this.index(name)] = ref;\n\t};\n\n\t// Deconflict all names within the scope,\n\t// using the given renaming function.\n\t// If no function is supplied, `underscorePrefix` is used.\n\n\tScope.prototype.deconflict = function deconflict() {\n\t\tvar _this = this;\n\n\t\tvar rename = arguments.length <= 0 || arguments[0] === undefined ? underscorePrefix : arguments[0];\n\n\t\tvar names = this.used;\n\n\t\tthis.ids.filter(function (ref) {\n\t\t\treturn ref instanceof Reference;\n\t\t}).forEach(function (ref) {\n\t\t\t// Same scope.\n\t\t\tif (ref.scope.ids === _this.ids) return;\n\n\t\t\t// Another scope!\n\t\t\twhile (ref instanceof Reference) {\n\t\t\t\tref = dereference(ref);\n\t\t\t}\n\n\t\t\tnames[ref.name] = ref;\n\t\t});\n\n\t\tthis.ids.filter(isntReference).forEach(function (id) {\n\t\t\tif (typeof id === 'string') {\n\t\t\t\tthrow new Error('Required name \"' + id + '\" is undefined!');\n\t\t\t}\n\n\t\t\tvar name = id.name;\n\n\t\t\twhile (name in names && names[name] !== id) {\n\t\t\t\tname = rename(name);\n\t\t\t}\n\t\t\tnames[name] = id;\n\n\t\t\tid.name = name;\n\t\t});\n\t};\n\n\t// Defines `name` in the scope to be `id`.\n\t// If no `id` is supplied, a plain `Identifier` is created.\n\n\tScope.prototype.define = function define(name, id) {\n\t\tthis.ids[this.index(name)] = id || new Identifier(name);\n\t};\n\n\t// TODO: rename! Too similar to `define`.\n\n\tScope.prototype.defines = function defines(name) {\n\t\treturn name in this.names;\n\t};\n\n\t// Return the names referenced to in the scope.\n\n\tScope.prototype.getNames = function getNames() {\n\t\treturn keys(this.names);\n\t};\n\n\t// *private, don't use*\n\t//\n\t// Return `name`'s index in the `ids` array if it exists,\n\t// otherwise returns the index to a new placeholder slot.\n\n\tScope.prototype.index = function index(name) {\n\t\tif (!(name in this.names)) {\n\t\t\treturn this.names[name] = this.ids.push(name) - 1;\n\t\t}\n\n\t\treturn this.names[name];\n\t};\n\n\t// Returns true if `name` is in Scope.\n\n\tScope.prototype.inScope = function inScope(name) {\n\t\tif (name in this.names) return true;\n\n\t\treturn this.parent ? this.parent.inScope(name) : false;\n\t};\n\n\t// Returns a list of `[ name, identifier ]` tuples.\n\n\tScope.prototype.getIds = function getIds() {\n\t\tvar _this2 = this;\n\n\t\treturn keys(this.names).map(function (name) {\n\t\t\treturn _this2.lookup(name);\n\t\t});\n\t};\n\n\t// Lookup the identifier referred to by `name`.\n\n\tScope.prototype.lookup = function lookup(name) {\n\t\tif (!(name in this.names) && this.parent) {\n\t\t\treturn this.parent.lookup(name);\n\t\t}\n\n\t\tvar id = this.ids[this.names[name]];\n\n\t\twhile (id instanceof Reference) {\n\t\t\tid = dereference(id);\n\t\t}\n\n\t\treturn id;\n\t};\n\n\t// Get a reference to the identifier `name` in this scope.\n\n\tScope.prototype.reference = function reference(name) {\n\t\treturn new Reference(this, this.index(name));\n\t};\n\n\t// Return the used names of the scope.\n\t// Names aren't considered used unless they're deconflicted.\n\n\tScope.prototype.usedNames = function usedNames() {\n\t\treturn keys(this.used).sort();\n\t};\n\n\t// Create and return a virtual `Scope` instance, bound to\n\t// the actual scope of `this`, optionally inherit the parent scope.\n\n\tScope.prototype.virtual = function virtual(inheritParent) {\n\t\tvar scope = new Scope(inheritParent ? this.parent : null);\n\t\tscope.ids = this.ids;\n\t\treturn scope;\n\t};\n\n\treturn Scope;\n})();\n\nfunction ensureArray(thing) {\n\tif (Array.isArray(thing)) return thing;\n\tif (thing == undefined) return [];\n\treturn [thing];\n}\n\nfunction dirExists(dir) {\n\ttry {\n\t\treaddirSync(dir);\n\t\treturn true;\n\t} catch (err) {\n\t\treturn false;\n\t}\n}\n\nfunction defaultResolver(importee, importer, options) {\n\t// absolute paths are left untouched\n\tif (isAbsolute(importee)) return importee;\n\n\t// if this is the entry point, resolve against cwd\n\tif (importer === undefined) return resolve(process.cwd(), importee);\n\n\t// we try to resolve external modules\n\tif (importee[0] !== '.') {\n\t\tvar _importee$split = importee.split(/[\\/\\\\]/);\n\n\t\tvar id = _importee$split[0];\n\n\t\t// unless we want to keep it external, that is\n\t\tif (~options.external.indexOf(id)) return null;\n\n\t\treturn options.resolveExternal(importee, importer, options);\n\t}\n\n\treturn resolve(dirname(importer), importee).replace(/\\.js$/, '') + '.js';\n}\n\nfunction defaultExternalResolver(id, importer) {\n\t// for now, only node_modules is supported, and only jsnext:main\n\tvar root = absolutePath.exec(importer)[0];\n\tvar dir = dirname(importer);\n\n\t// `foo` should use jsnext:main, but `foo/src/bar` shouldn't\n\tvar parts = id.split(/[\\/\\\\]/);\n\n\twhile (dir !== root && dir !== '.') {\n\t\tvar modulePath = resolve(dir, 'node_modules', parts[0]);\n\n\t\tif (dirExists(modulePath)) {\n\t\t\t// `foo/src/bar`\n\t\t\tif (parts.length > 1) {\n\t\t\t\treturn resolve.apply(undefined, [modulePath].concat(toConsumableArray(parts.slice(1)))).replace(/\\.js$/, '') + '.js';\n\t\t\t}\n\n\t\t\t// `foo`\n\t\t\tvar pkgPath = resolve(modulePath, 'package.json');\n\t\t\tvar pkg = undefined;\n\n\t\t\ttry {\n\t\t\t\tpkg = JSON.parse(readFileSync(pkgPath).toString());\n\t\t\t} catch (err) {\n\t\t\t\tthrow new Error('Missing or malformed package.json: ' + modulePath);\n\t\t\t}\n\n\t\t\tvar main = pkg['jsnext:main'];\n\n\t\t\tif (!main) {\n\t\t\t\tthrow new Error('Package ' + id + ' (imported by ' + importer + ') does not have a jsnext:main field, and so cannot be included in your rollup. Try adding it as an external module instead (e.g. options.external = [\\'' + id + '\\']). See https://github.com/rollup/rollup/wiki/jsnext:main for more info');\n\t\t\t}\n\n\t\t\treturn resolve(dirname(pkgPath), main).replace(/\\.js$/, '') + '.js';\n\t\t}\n\n\t\tdir = dirname(dir);\n\t}\n\n\tthrow new Error('Could not find package ' + id + ' (required by ' + importer + ')');\n}\n\nfunction defaultLoader(id, options) {\n\t// TODO support plugins e.g. !css and !json?\n\tvar source = readFileSync(id, { encoding: 'utf-8' });\n\n\treturn options.transform.reduce(function (source, transformer) {\n\t\treturn transformer(source, id);\n\t}, source);\n}\n\nvar Bundle = (function () {\n\tfunction Bundle(options) {\n\t\tvar _this = this;\n\n\t\tclassCallCheck(this, Bundle);\n\n\t\tthis.entry = options.entry;\n\t\tthis.entryModule = null;\n\n\t\tthis.resolveId = options.resolveId || defaultResolver;\n\t\tthis.load = options.load || defaultLoader;\n\n\t\tthis.resolveOptions = {\n\t\t\texternal: ensureArray(options.external),\n\t\t\tresolveExternal: options.resolveExternal || defaultExternalResolver\n\t\t};\n\n\t\tthis.loadOptions = {\n\t\t\ttransform: ensureArray(options.transform)\n\t\t};\n\n\t\t// The global scope, and the bundle's internal scope.\n\t\tthis.globals = new Scope();\n\t\tthis.scope = new Scope(this.globals);\n\n\t\t// Strictly speaking, these globals only apply to non-ES6, non-default-only bundles.\n\t\t// However, the deconfliction logic is greatly simplified by being the same for all formats.\n\t\t// * CommonJS needs `module` and `exports` ( and `require`? ) to be in scope.\n\t\t// * SystemJS needs a reference to a function for its `exports`,\n\t\t//   and another one for any `module` it imports. These global names can be reused!\n\t\t['exports', 'module'].forEach(function (name) {\n\t\t\t_this.globals.define(name);\n\t\t\t_this.scope.bind(name, _this.globals.reference(name));\n\t\t});\n\n\t\t// Alias for entryModule.exports.\n\t\tthis.exports = null;\n\n\t\tthis.toExport = null;\n\n\t\tthis.pending = _blank();\n\t\tthis.moduleById = _blank();\n\t\tthis.modules = [];\n\n\t\tthis.statements = null;\n\t\tthis.externalModules = [];\n\t}\n\n\tBundle.prototype.build = function build() {\n\t\tvar _this2 = this;\n\n\t\treturn _Promise.resolve(this.resolveId(this.entry, undefined, this.resolveOptions)).then(function (id) {\n\t\t\treturn _this2.fetchModule(id);\n\t\t}).then(function (entryModule) {\n\t\t\t_this2.entryModule = entryModule;\n\t\t\t_this2.exports = entryModule.exports;\n\n\t\t\tentryModule.markAllStatements(true);\n\t\t\tentryModule.markAllExports();\n\n\t\t\t// Include all side-effects\n\t\t\t_this2.modules.forEach(function (module) {\n\t\t\t\tmodule.markAllSideEffects();\n\t\t\t});\n\n\t\t\t// Sort the modules.\n\t\t\t_this2.orderedModules = _this2.sort();\n\n\t\t\t// As a last step, deconflict all identifier names, once.\n\t\t\t_this2.scope.deconflict();\n\n\t\t\t// Alias the default import to the external module named\n\t\t\t// for external modules that don't need named imports.\n\t\t\t_this2.externalModules.forEach(function (module) {\n\t\t\t\tvar externalDefault = module.exports.lookup('default');\n\n\t\t\t\tif (externalDefault && !(module.needsNamed || module.needsAll)) {\n\t\t\t\t\texternalDefault.name = module.name;\n\t\t\t\t}\n\t\t\t});\n\t\t});\n\t};\n\n\tBundle.prototype.fetchModule = function fetchModule(id) {\n\t\tvar _this3 = this;\n\n\t\t// short-circuit cycles\n\t\tif (this.pending[id]) return null;\n\t\tthis.pending[id] = true;\n\n\t\treturn _Promise.resolve(this.load(id, this.loadOptions)).then(function (source) {\n\t\t\tvar ast = undefined;\n\n\t\t\tif (typeof source === 'object') {\n\t\t\t\tast = source.ast;\n\t\t\t\tsource = source.code;\n\t\t\t}\n\n\t\t\tvar module = new Module({\n\t\t\t\tid: id,\n\t\t\t\tsource: source,\n\t\t\t\tast: ast,\n\t\t\t\tbundle: _this3\n\t\t\t});\n\n\t\t\t_this3.modules.push(module);\n\t\t\t_this3.moduleById[id] = module;\n\n\t\t\treturn _this3.fetchAllDependencies(module).then(function () {\n\t\t\t\t// Analyze the module once all its dependencies have been resolved.\n\t\t\t\t// This means that any dependencies of a module has already been\n\t\t\t\t// analysed when it's time for the module itself.\n\t\t\t\tmodule.analyse();\n\t\t\t\treturn module;\n\t\t\t});\n\t\t});\n\t};\n\n\tBundle.prototype.fetchAllDependencies = function fetchAllDependencies(module) {\n\t\tvar _this4 = this;\n\n\t\tvar promises = module.dependencies.map(function (source) {\n\t\t\treturn _Promise.resolve(_this4.resolveId(source, module.id, _this4.resolveOptions)).then(function (resolvedId) {\n\t\t\t\tmodule.resolvedIds[source] = resolvedId || source;\n\n\t\t\t\t// external module\n\t\t\t\tif (!resolvedId) {\n\t\t\t\t\tif (!_this4.moduleById[source]) {\n\t\t\t\t\t\tvar _module = new ExternalModule({ id: source, bundle: _this4 });\n\t\t\t\t\t\t_this4.externalModules.push(_module);\n\t\t\t\t\t\t_this4.moduleById[source] = _module;\n\t\t\t\t\t}\n\t\t\t\t} else if (resolvedId === module.id) {\n\t\t\t\t\tthrow new Error('A module cannot import itself (' + resolvedId + ')');\n\t\t\t\t} else {\n\t\t\t\t\treturn _this4.fetchModule(resolvedId);\n\t\t\t\t}\n\t\t\t});\n\t\t});\n\n\t\treturn _Promise.all(promises);\n\t};\n\n\tBundle.prototype.render = function render() {\n\t\tvar _this5 = this;\n\n\t\tvar options = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];\n\n\t\tvar format = options.format || 'es6';\n\n\t\t// Determine export mode - 'default', 'named', 'none'\n\t\tvar exportMode = getExportMode(this, options.exports);\n\n\t\t// If we have named exports from the bundle, and those exports\n\t\t// are assigned to *within* the bundle, we may need to rewrite e.g.\n\t\t//\n\t\t//   export let count = 0;\n\t\t//   export function incr () { count++ }\n\t\t//\n\t\t// might become...\n\t\t//\n\t\t//   exports.count = 0;\n\t\t//   function incr () {\n\t\t//     exports.count += 1;\n\t\t//   }\n\t\t//   exports.incr = incr;\n\t\t//\n\t\t// This doesn't apply if the bundle is exported as ES6!\n\t\tvar allBundleExports = _blank();\n\t\tvar isReassignedVarDeclaration = _blank();\n\t\tvar varExports = _blank();\n\t\tvar getterExports = [];\n\n\t\tthis.orderedModules.forEach(function (module) {\n\t\t\tmodule.reassignments.forEach(function (name) {\n\t\t\t\tisReassignedVarDeclaration[module.locals.lookup(name).name] = true;\n\t\t\t});\n\t\t});\n\n\t\tif (format !== 'es6' && exportMode === 'named') {\n\t\t\tthis.exports.getNames().forEach(function (name) {\n\t\t\t\tvar canonicalName = _this5.exports.lookup(name).name;\n\n\t\t\t\tif (isReassignedVarDeclaration[canonicalName]) {\n\t\t\t\t\tvarExports[name] = true;\n\n\t\t\t\t\t// if the same binding is exported multiple ways, we need to\n\t\t\t\t\t// use getters to keep all exports in sync\n\t\t\t\t\tif (allBundleExports[canonicalName]) {\n\t\t\t\t\t\tgetterExports.push({ key: name, value: allBundleExports[canonicalName] });\n\t\t\t\t\t} else {\n\t\t\t\t\t\tallBundleExports[canonicalName] = 'exports.' + name;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\n\t\t// since we're rewriting variable exports, we want to\n\t\t// ensure we don't try and export them again at the bottom\n\t\tthis.toExport = this.exports.getNames().filter(function (key) {\n\t\t\treturn !varExports[key];\n\t\t});\n\n\t\tvar magicString = new MagicString.Bundle({ separator: '\\n\\n' });\n\n\t\tthis.orderedModules.forEach(function (module) {\n\t\t\tvar source = module.render(allBundleExports, format === 'es6');\n\t\t\tif (source.toString().length) {\n\t\t\t\tmagicString.addSource(source);\n\t\t\t}\n\t\t});\n\n\t\t// prepend bundle with internal namespaces\n\t\tvar indentString = getIndentString(magicString, options);\n\n\t\tvar namespaceBlock = this.modules.filter(function (module) {\n\t\t\treturn module.needsDynamicAccess;\n\t\t}).map(function (module) {\n\t\t\tvar exports = module.exports.getNames().map(function (name) {\n\t\t\t\tvar id = module.exports.lookup(name);\n\t\t\t\treturn indentString + 'get ' + name + ' () { return ' + id.name + '; }';\n\t\t\t});\n\n\t\t\treturn 'var ' + module.name + ' = {\\n' + exports.join(',\\n') + '\\n};\\n\\n';\n\t\t}).join('');\n\n\t\tmagicString.prepend(namespaceBlock);\n\n\t\tif (getterExports.length) {\n\t\t\t// TODO offer ES3-safe (but not spec-compliant) alternative?\n\t\t\tvar getterExportsBlock = 'Object.defineProperties(exports, {\\n' + getterExports.map(function (_ref) {\n\t\t\t\tvar key = _ref.key;\n\t\t\t\tvar value = _ref.value;\n\t\t\t\treturn indentString + (key + ': { get: function () { return ' + value + '; } }');\n\t\t\t}).join(',\\n') + '\\n});';\n\n\t\t\tmagicString.append('\\n\\n' + getterExportsBlock);\n\t\t}\n\n\t\tvar finalise = finalisers[format];\n\n\t\tif (!finalise) {\n\t\t\tthrow new Error('You must specify an output type - valid options are ' + keys(finalisers).join(', '));\n\t\t}\n\n\t\tmagicString = finalise(this, magicString.trim(), { exportMode: exportMode, indentString: indentString }, options);\n\n\t\tif (options.banner) magicString.prepend(options.banner + '\\n');\n\t\tif (options.footer) magicString.append('\\n' + options.footer);\n\n\t\tvar code = magicString.toString();\n\t\tvar map = null;\n\n\t\tif (options.sourceMap) {\n\t\t\tvar file = options.sourceMapFile || options.dest;\n\t\t\tmap = magicString.generateMap({\n\t\t\t\tincludeContent: true,\n\t\t\t\tfile: file\n\t\t\t\t// TODO\n\t\t\t});\n\n\t\t\tmap.sources = map.sources.map(unixizePath);\n\t\t}\n\n\t\treturn { code: code, map: map };\n\t};\n\n\tBundle.prototype.sort = function sort() {\n\t\t// Set of visited module ids.\n\t\tvar seen = _blank();\n\n\t\tvar ordered = [];\n\t\tvar hasCycles = undefined;\n\n\t\t// Map from module id to list of modules.\n\t\tvar strongDeps = _blank();\n\n\t\t// Map from module id to boolean.\n\t\tvar stronglyDependsOn = _blank();\n\n\t\tfunction visit(module) {\n\t\t\tseen[module.id] = true;\n\n\t\t\tvar _module$consolidateDependencies = module.consolidateDependencies();\n\n\t\t\tvar strongDependencies = _module$consolidateDependencies.strongDependencies;\n\t\t\tvar weakDependencies = _module$consolidateDependencies.weakDependencies;\n\n\t\t\tstrongDeps[module.id] = [];\n\t\t\tstronglyDependsOn[module.id] = {};\n\n\t\t\tkeys(strongDependencies).forEach(function (id) {\n\t\t\t\tvar imported = strongDependencies[id];\n\n\t\t\t\tstrongDeps[module.id].push(imported);\n\n\t\t\t\tif (seen[id]) {\n\t\t\t\t\t// we need to prevent an infinite loop, and note that\n\t\t\t\t\t// we need to check for strong/weak dependency relationships\n\t\t\t\t\thasCycles = true;\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tvisit(imported);\n\t\t\t});\n\n\t\t\tkeys(weakDependencies).forEach(function (id) {\n\t\t\t\tvar imported = weakDependencies[id];\n\n\t\t\t\tif (seen[id]) {\n\t\t\t\t\t// we need to prevent an infinite loop, and note that\n\t\t\t\t\t// we need to check for strong/weak dependency relationships\n\t\t\t\t\thasCycles = true;\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tvisit(imported);\n\t\t\t});\n\n\t\t\t// add second (and third...) order dependencies\n\t\t\tfunction addStrongDependencies(dependency) {\n\t\t\t\tif (stronglyDependsOn[module.id][dependency.id]) return;\n\n\t\t\t\tstronglyDependsOn[module.id][dependency.id] = true;\n\t\t\t\tstrongDeps[dependency.id].forEach(addStrongDependencies);\n\t\t\t}\n\n\t\t\tstrongDeps[module.id].forEach(addStrongDependencies);\n\n\t\t\tordered.push(module);\n\t\t}\n\n\t\tvisit(this.entryModule);\n\n\t\tif (hasCycles) {\n\t\t\tvar unordered = ordered;\n\t\t\tordered = [];\n\n\t\t\t// unordered is actually semi-ordered, as [ fewer dependencies ... more dependencies ]\n\t\t\tunordered.forEach(function (module) {\n\t\t\t\t// ensure strong dependencies of `module` that don't strongly depend on `module` go first\n\t\t\t\tstrongDeps[module.id].forEach(place);\n\n\t\t\t\tfunction place(dep) {\n\t\t\t\t\tif (!stronglyDependsOn[dep.id][module.id] && ! ~ordered.indexOf(dep)) {\n\t\t\t\t\t\tstrongDeps[dep.id].forEach(place);\n\t\t\t\t\t\tordered.push(dep);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (! ~ordered.indexOf(module)) {\n\t\t\t\t\tordered.push(module);\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\n\t\treturn ordered;\n\t};\n\n\treturn Bundle;\n})();\n\nfunction rollup(options) {\n\tif (!options || !options.entry) {\n\t\tthrow new Error('You must supply options.entry to rollup');\n\t}\n\n\tvar bundle = new Bundle(options);\n\n\treturn bundle.build().then(function () {\n\t\treturn {\n\t\t\timports: bundle.externalModules.map(function (module) {\n\t\t\t\treturn module.id;\n\t\t\t}),\n\t\t\texports: keys(bundle.entryModule.exports),\n\t\t\tmodules: bundle.orderedModules.map(function (module) {\n\t\t\t\treturn { id: module.id };\n\t\t\t}),\n\n\t\t\tgenerate: function (options) {\n\t\t\t\treturn bundle.render(options);\n\t\t\t},\n\t\t\twrite: function (options) {\n\t\t\t\tif (!options || !options.dest) {\n\t\t\t\t\tthrow new Error('You must supply options.dest to bundle.write');\n\t\t\t\t}\n\n\t\t\t\tvar dest = options.dest;\n\n\t\t\t\tvar _bundle$render = bundle.render(options);\n\n\t\t\t\tvar code = _bundle$render.code;\n\t\t\t\tvar map = _bundle$render.map;\n\n\t\t\t\tvar promises = [];\n\n\t\t\t\tif (options.sourceMap) {\n\t\t\t\t\tvar url = undefined;\n\n\t\t\t\t\tif (options.sourceMap === 'inline') {\n\t\t\t\t\t\turl = map.toUrl();\n\t\t\t\t\t} else {\n\t\t\t\t\t\turl = basename(dest) + '.map';\n\t\t\t\t\t\tpromises.push(writeFile(dest + '.map', map.toString()));\n\t\t\t\t\t}\n\n\t\t\t\t\tcode += '\\n//# ' + SOURCEMAPPING_URL + '=' + url;\n\t\t\t\t}\n\n\t\t\t\tpromises.push(writeFile(dest, code));\n\t\t\t\treturn Promise.all(promises);\n\t\t\t}\n\t\t};\n\t});\n}\n\nexports.rollup = rollup;","(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require==\"function\"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error(\"Cannot find module '\"+o+\"'\");throw f.code=\"MODULE_NOT_FOUND\",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require==\"function\"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})"],"names":[],"mappings":"AOAA;;ADAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;ADrjHA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;AD/uGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AD7/CA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AD5HA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ADpFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ADjCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA"}