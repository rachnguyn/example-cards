'use strict';

function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) arr2[i] = arr[i]; return arr2; } else { return Array.from(arr); } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

var sander = require('sander');
var acorn = require('acorn');

// this looks ridiculous, but it prevents sourcemap tooling from mistaking
// this for an actual sourceMappingURL
var SOURCEMAPPING_URL = 'sourceMa';
SOURCEMAPPING_URL += 'ppingURL';

// TODO does this all work on windows?

var absolutePath = /^(?:\/|(?:[A-Za-z]:)?[\\|\/])/;

function isAbsolute(path) {
	return absolutePath.test(path);
}

function basename(path) {
	return path.split(/(\/|\\)/).pop();
}

function dirname(path) {
	var match = /(\/|\\)[^\/\\]*$/.exec(path);
	if (!match) return '.';

	var dir = path.slice(0, -match[0].length);

	// If `dir` is the empty string, we're at root.
	return dir ? dir : '/';
}

function extname(path) {
	var match = /\.[^\.]+$/.exec(path);
	if (!match) return '';
	return match[0];
}

function resolve() {
	for (var _len = arguments.length, paths = Array(_len), _key = 0; _key < _len; _key++) {
		paths[_key] = arguments[_key];
	}

	var resolvedParts = paths.shift().split(/[\/\\]/);

	paths.forEach(function (path) {
		if (isAbsolute(path)) {
			resolvedParts = path.split(/[\/\\]/);
		} else {
			var parts = path.split(/[\/\\]/);

			while (parts[0] && parts[0][0] === '.') {
				var part = parts.shift();
				if (part === '..') {
					resolvedParts.pop();
				} else if (part !== '.') {
					throw new Error('Unexpected path part (' + part + ')');
				}
			}

			resolvedParts.push.apply(resolvedParts, parts);
		}
	});

	return resolvedParts.join('/'); // TODO windows...
}

var keys = Object.keys;

function blank() {
	return Object.create(null);
}

function unixizePath(path) {
	return path.split(/[\/\\]/).join('/');
}

function wrapAccess(id) {
	return id.originalName !== 'default' && id.module && id.module.isExternal ? id.module.name + propertyAccess(id.originalName) : id.name;
}

function propertyAccess(name) {
	return name === 'default' ? '[\'default\']' : '.' + name;
}

function getExportBlock(bundle, exportMode) {
	var mechanism = arguments.length <= 2 || arguments[2] === undefined ? 'return' : arguments[2];

	if (exportMode === 'default') {
		var id = bundle.exports.lookup('default');

		return mechanism + ' ' + wrapAccess(id) + ';';
	}

	return bundle.toExport.map(function (name) {
		var id = bundle.exports.lookup(name);

		return 'exports' + propertyAccess(name) + ' = ' + wrapAccess(id) + ';';
	}).join('\n');
}

function getInteropBlock(bundle) {
	return bundle.externalModules.map(function (module) {
		var def = module.exports.lookup('default');

		if (!def) return;

		return (module.needsNamed ? 'var ' : '') + (def.name + ' = \'default\' in ' + module.name + ' ? ' + module.name + '[\'default\'] : ' + module.name + ';');
	}).filter(Boolean).join('\n');
}

function getName(x) {
	return x.name;
}

function quoteId(x) {
	return '\'' + x.id + '\'';
}

function req(x) {
	return 'require(\'' + x.id + '\')';
}

function umd(bundle, magicString, _ref, options) {
	var exportMode = _ref.exportMode;
	var indentString = _ref.indentString;

	if (exportMode !== 'none' && !options.moduleName) {
		throw new Error('You must supply options.moduleName for UMD bundles');
	}

	var globalNames = options.globals || blank();

	var amdDeps = bundle.externalModules.map(quoteId);
	var cjsDeps = bundle.externalModules.map(req);
	var globalDeps = bundle.externalModules.map(function (module) {
		return 'global.' + (globalNames[module.id] || module.name);
	});

	var args = bundle.externalModules.map(getName);

	if (exportMode === 'named') {
		amdDeps.unshift('\'exports\'');
		cjsDeps.unshift('exports');
		globalDeps.unshift('(global.' + options.moduleName + ' = {})');

		args.unshift('exports');
	}

	var amdParams = (options.moduleId ? '\'' + options.moduleId + '\', ' : '') + (amdDeps.length ? '[' + amdDeps.join(', ') + '], ' : '');

	var cjsExport = exportMode === 'default' ? 'module.exports = ' : '';
	var defaultExport = exportMode === 'default' ? 'global.' + options.moduleName + ' = ' : '';

	var useStrict = options.useStrict !== false ? ' \'use strict\';' : '';

	var intro = ('(function (global, factory) {\n\t\t\ttypeof exports === \'object\' && typeof module !== \'undefined\' ? ' + cjsExport + 'factory(' + cjsDeps.join(', ') + ') :\n\t\t\ttypeof define === \'function\' && define.amd ? define(' + amdParams + 'factory) :\n\t\t\t' + defaultExport + 'factory(' + globalDeps + ');\n\t\t}(this, function (' + args + ') {' + useStrict + '\n\n\t\t').replace(/^\t\t/gm, '').replace(/^\t/gm, magicString.getIndentString());

	// var foo__default = 'default' in foo ? foo['default'] : foo;
	var interopBlock = getInteropBlock(bundle);
	if (interopBlock) magicString.prepend(interopBlock + '\n\n');

	var exportBlock = getExportBlock(bundle, exportMode);
	if (exportBlock) magicString.append('\n\n' + exportBlock);

	return magicString.trim().indent(indentString).append('\n\n}));').prepend(intro);
}

function iife(bundle, magicString, _ref2, options) {
	var exportMode = _ref2.exportMode;
	var indentString = _ref2.indentString;

	var globalNames = options.globals || blank();

	var dependencies = bundle.externalModules.map(function (module) {
		return globalNames[module.id] || module.name;
	});

	var args = bundle.externalModules.map(getName);

	if (exportMode !== 'none' && !options.moduleName) {
		throw new Error('You must supply options.moduleName for IIFE bundles');
	}

	if (exportMode === 'named') {
		dependencies.unshift('(this.' + options.moduleName + ' = {})');
		args.unshift('exports');
	}

	var useStrict = options.useStrict !== false ? ' \'use strict\';' : '';
	var intro = '(function (' + args + ') {' + useStrict + '\n\n';
	var outro = '\n\n})(' + dependencies + ');';

	if (exportMode === 'default') {
		intro = 'var ' + options.moduleName + ' = ' + intro;
	}

	// var foo__default = 'default' in foo ? foo['default'] : foo;
	var interopBlock = getInteropBlock(bundle);
	if (interopBlock) magicString.prepend(interopBlock + '\n\n');

	var exportBlock = getExportBlock(bundle, exportMode);
	if (exportBlock) magicString.append('\n\n' + exportBlock);

	return magicString.indent(indentString).prepend(intro).append(outro);
}

function specifiersFor(externalModule) {
	return keys(externalModule.importedByBundle).filter(notDefault).sort().map(function (name) {
		var id = externalModule.exports.lookup(name);

		return name !== id.name ? name + ' as ' + id.name : name;
	});
}

function notDefault(name) {
	return name !== 'default';
}

function es6(bundle, magicString) {
	var importBlock = bundle.externalModules.map(function (module) {
		var specifiers = [];

		var id = module.exports.lookup('default');

		if (id) {
			specifiers.push(id.name);
		}

		if (module.needsAll) {
			specifiers.push('* as ' + module.name);
		}

		if (module.needsNamed) {
			specifiers.push('{ ' + specifiersFor(module).join(', ') + ' }');
		}

		return specifiers.length ? 'import ' + specifiers.join(', ') + ' from \'' + module.id + '\';' : 'import \'' + module.id + '\';';
	}).join('\n');

	if (importBlock) {
		magicString.prepend(importBlock + '\n\n');
	}

	var module = bundle.entryModule;

	var specifiers = bundle.toExport.filter(notDefault).map(function (name) {
		var id = bundle.exports.lookup(name);

		return id.name === name ? name : id.name + ' as ' + name;
	});

	var exportBlock = specifiers.length ? 'export { ' + specifiers.join(', ') + ' };' : '';

	var defaultExport = module.exports.lookup('default');
	if (defaultExport) {
		exportBlock += '\nexport default ' + defaultExport.name + ';';
	}

	if (exportBlock) {
		magicString.append('\n\n' + exportBlock.trim());
	}

	return magicString.trim();
}

function cjs(bundle, magicString, _ref3, options) {
	var exportMode = _ref3.exportMode;

	var intro = options.useStrict === false ? '' : '\'use strict\';\n\n';

	// TODO handle empty imports, once they're supported
	var importBlock = bundle.externalModules.map(function (module) {
		return 'var ' + module.name + ' = require(\'' + module.id + '\');';
	}).join('\n');

	var interopBlock = getInteropBlock(bundle);

	if (interopBlock) {
		importBlock += '\n' + interopBlock;
	}

	if (importBlock) {
		intro += importBlock + '\n\n';
	}

	magicString.prepend(intro);

	var exportBlock = getExportBlock(bundle, exportMode, 'module.exports =');
	if (exportBlock) magicString.append('\n\n' + exportBlock);

	return magicString;
}

function amd(bundle, magicString, _ref4, options) {
	var exportMode = _ref4.exportMode;
	var indentString = _ref4.indentString;

	var deps = bundle.externalModules.map(quoteId);
	var args = bundle.externalModules.map(getName);

	if (exportMode === 'named') {
		args.unshift('exports');
		deps.unshift('\'exports\'');
	}

	var params = (options.moduleId ? '\'' + options.moduleId + '\', ' : '') + (deps.length ? '[' + deps.join(', ') + '], ' : '');

	var useStrict = options.useStrict !== false ? ' \'use strict\';' : '';
	var intro = 'define(' + params + 'function (' + args.join(', ') + ') {' + useStrict + '\n\n';

	// var foo__default = 'default' in foo ? foo['default'] : foo;
	var interopBlock = getInteropBlock(bundle);
	if (interopBlock) magicString.prepend(interopBlock + '\n\n');

	var exportBlock = getExportBlock(bundle, exportMode);
	if (exportBlock) magicString.append('\n\n' + exportBlock);

	return magicString.indent(indentString).append('\n\n});').prepend(intro);
}

var _index = { amd: amd, cjs: cjs, es6: es6, iife: iife, umd: umd };

function getIndentString(magicString, options) {
	if (!('indent' in options) || options.indent === true) {
		return magicString.getIndentString();
	}

	return options.indent || '';
}

var charToInteger = {};
var integerToChar = {};

'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/='.split('').forEach(function (char, i) {
	charToInteger[char] = i;
	integerToChar[i] = char;
});

function encode(value) {
	var result, i;

	if (typeof value === 'number') {
		result = encodeInteger(value);
	} else {
		result = '';
		for (i = 0; i < value.length; i += 1) {
			result += encodeInteger(value[i]);
		}
	}

	return result;
}

function encodeInteger(num) {
	var result = '',
	    clamped;

	if (num < 0) {
		num = -num << 1 | 1;
	} else {
		num <<= 1;
	}

	do {
		clamped = num & 31;
		num >>= 5;

		if (num > 0) {
			clamped |= 32;
		}

		result += integerToChar[clamped];
	} while (num > 0);

	return result;
}

function encodeMappings(original, str, mappings, hires, sourcemapLocations, sourceIndex, offsets, names, nameLocations) {
	// store locations, for fast lookup
	var lineStart = 0;
	var locations = original.split('\n').map(function (line) {
		var start = lineStart;
		lineStart += line.length + 1; // +1 for the newline

		return start;
	});

	var inverseMappings = invert(str, mappings);

	var charOffset = 0;
	var lines = str.split('\n').map(function (line) {
		var segments = [];

		var char = undefined; // TODO put these inside loop, once we've determined it's safe to do so transpilation-wise
		var origin = undefined;
		var lastOrigin = -1;
		var location = undefined;
		var nameIndex = undefined;

		var i = undefined;

		var len = line.length;
		for (i = 0; i < len; i += 1) {
			char = i + charOffset;
			origin = inverseMappings[char];

			nameIndex = -1;
			location = null;

			// if this character has no mapping, but the last one did,
			// create a new segment
			if (! ~origin && ~lastOrigin) {
				location = _getLocation(locations, lastOrigin + 1);

				if (lastOrigin + 1 in nameLocations) nameIndex = names.indexOf(nameLocations[lastOrigin + 1]);
			} else if (~origin && (hires || ~lastOrigin && origin !== lastOrigin + 1 || sourcemapLocations[origin])) {
				location = _getLocation(locations, origin);
			}

			if (location) {
				segments.push({
					generatedCodeColumn: i,
					sourceIndex: sourceIndex,
					sourceCodeLine: location.line,
					sourceCodeColumn: location.column,
					sourceCodeName: nameIndex
				});
			}

			lastOrigin = origin;
		}

		charOffset += line.length + 1;
		return segments;
	});

	offsets.sourceIndex = offsets.sourceIndex || 0;
	offsets.sourceCodeLine = offsets.sourceCodeLine || 0;
	offsets.sourceCodeColumn = offsets.sourceCodeColumn || 0;
	offsets.sourceCodeName = offsets.sourceCodeName || 0;

	var encoded = lines.map(function (segments) {
		var generatedCodeColumn = 0;

		return segments.map(function (segment) {
			var arr = [segment.generatedCodeColumn - generatedCodeColumn, segment.sourceIndex - offsets.sourceIndex, segment.sourceCodeLine - offsets.sourceCodeLine, segment.sourceCodeColumn - offsets.sourceCodeColumn];

			generatedCodeColumn = segment.generatedCodeColumn;
			offsets.sourceIndex = segment.sourceIndex;
			offsets.sourceCodeLine = segment.sourceCodeLine;
			offsets.sourceCodeColumn = segment.sourceCodeColumn;

			if (~segment.sourceCodeName) {
				arr.push(segment.sourceCodeName - offsets.sourceCodeName);
				offsets.sourceCodeName = segment.sourceCodeName;
			}

			return encode(arr);
		}).join(',');
	}).join(';');

	return encoded;
}

function invert(str, mappings) {
	var inverted = new Uint32Array(str.length),
	    i;

	// initialise everything to -1
	i = str.length;
	while (i--) {
		inverted[i] = -1;
	}

	// then apply the actual mappings
	i = mappings.length;
	while (i--) {
		if (~mappings[i]) {
			inverted[mappings[i]] = i;
		}
	}

	return inverted;
}

function _getLocation(locations, char) {
	var i;

	i = locations.length;
	while (i--) {
		if (locations[i] <= char) {
			return {
				line: i,
				column: char - locations[i]
			};
		}
	}

	throw new Error('Character out of bounds');
}

function getRelativePath(from, to) {
	var fromParts = from.split(/[\/\\]/);
	var toParts = to.split(/[\/\\]/);

	fromParts.pop(); // get dirname

	while (fromParts[0] === toParts[0]) {
		fromParts.shift();
		toParts.shift();
	}

	if (fromParts.length) {
		var i = fromParts.length;
		while (i--) fromParts[i] = '..';
	}

	return fromParts.concat(toParts).join('/');
}

var _btoa;

if (typeof window !== 'undefined' && typeof window.btoa === 'function') {
	_btoa = window.btoa;
} else if (typeof Buffer === 'function') {
	_btoa = function (str) {
		return new Buffer(str).toString('base64');
	};
} else {
	throw new Error('Unsupported environment: `window.btoa` or `Buffer` should be supported.');
}

var SourceMap = (function () {
	function SourceMap(properties) {
		_classCallCheck(this, SourceMap);

		this.version = 3;

		this.file = properties.file;
		this.sources = properties.sources;
		this.sourcesContent = properties.sourcesContent;
		this.names = properties.names;
		this.mappings = properties.mappings;
	}

	SourceMap.prototype.toString = function toString() {
		return JSON.stringify(this);
	};

	SourceMap.prototype.toUrl = function toUrl() {
		return 'data:application/json;charset=utf-8;base64,' + _btoa(this.toString());
	};

	return SourceMap;
})();

function guessIndent(code) {
	var lines = code.split('\n');

	var tabbed = lines.filter(function (line) {
		return (/^\t+/.test(line)
		);
	});
	var spaced = lines.filter(function (line) {
		return (/^ {2,}/.test(line)
		);
	});

	if (tabbed.length === 0 && spaced.length === 0) {
		return null;
	}

	// More lines tabbed than spaced? Assume tabs, and
	// default to tabs in the case of a tie (or nothing
	// to go on)
	if (tabbed.length >= spaced.length) {
		return '\t';
	}

	// Otherwise, we need to guess the multiple
	var min = spaced.reduce(function (previous, current) {
		var numSpaces = /^ +/.exec(current)[0].length;
		return Math.min(numSpaces, previous);
	}, Infinity);

	return new Array(min + 1).join(' ');
}

var hasOwnProp = Object.prototype.hasOwnProperty;

var Bundle = (function () {
	function Bundle() {
		var options = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];

		_classCallCheck(this, Bundle);

		this.intro = options.intro || '';
		this.outro = options.outro || '';
		this.separator = options.separator !== undefined ? options.separator : '\n';

		this.sources = [];

		this.uniqueSources = [];
		this.uniqueSourceIndexByFilename = {};
	}

	Bundle.prototype.addSource = function addSource(source) {
		if (source instanceof MagicString) {
			return this.addSource({
				content: source,
				filename: source.filename,
				separator: this.separator
			});
		}

		if (typeof source !== 'object' || !source.content) {
			throw new Error('bundle.addSource() takes an object with a `content` property, which should be an instance of MagicString, and an optional `filename`');
		}

		['filename', 'indentExclusionRanges', 'separator'].forEach(function (option) {
			if (!hasOwnProp.call(source, option)) source[option] = source.content[option];
		});

		if (source.separator === undefined) {
			// TODO there's a bunch of this sort of thing, needs cleaning up
			source.separator = this.separator;
		}

		if (source.filename) {
			if (!hasOwnProp.call(this.uniqueSourceIndexByFilename, source.filename)) {
				this.uniqueSourceIndexByFilename[source.filename] = this.uniqueSources.length;
				this.uniqueSources.push({ filename: source.filename, content: source.content.original });
			} else {
				var uniqueSource = this.uniqueSources[this.uniqueSourceIndexByFilename[source.filename]];
				if (source.content.original !== uniqueSource.content) {
					throw new Error('Illegal source: same filename (' + source.filename + '), different contents');
				}
			}
		}

		this.sources.push(source);
		return this;
	};

	Bundle.prototype.append = function append(str, options) {
		this.addSource({
			content: new MagicString(str),
			separator: options && options.separator || ''
		});

		return this;
	};

	Bundle.prototype.clone = function clone() {
		var bundle = new Bundle({
			intro: this.intro,
			outro: this.outro,
			separator: this.separator
		});

		this.sources.forEach(function (source) {
			bundle.addSource({
				filename: source.filename,
				content: source.content.clone(),
				separator: source.separator
			});
		});

		return bundle;
	};

	Bundle.prototype.generateMap = function generateMap(options) {
		var _this = this;

		var offsets = {};

		var names = [];
		this.sources.forEach(function (source) {
			Object.keys(source.content.nameLocations).forEach(function (location) {
				var name = source.content.nameLocations[location];
				if (! ~names.indexOf(name)) names.push(name);
			});
		});

		var encoded = getSemis(this.intro) + this.sources.map(function (source, i) {
			var prefix = i > 0 ? getSemis(source.separator) || ',' : '';
			var mappings = undefined;

			// we don't bother encoding sources without a filename
			if (!source.filename) {
				mappings = getSemis(source.content.toString());
			} else {
				var sourceIndex = _this.uniqueSourceIndexByFilename[source.filename];
				mappings = source.content.getMappings(options.hires, sourceIndex, offsets, names);
			}

			return prefix + mappings;
		}).join('') + getSemis(this.outro);

		return new SourceMap({
			file: options.file ? options.file.split(/[\/\\]/).pop() : null,
			sources: this.uniqueSources.map(function (source) {
				return options.file ? getRelativePath(options.file, source.filename) : source.filename;
			}),
			sourcesContent: this.uniqueSources.map(function (source) {
				return options.includeContent ? source.content : null;
			}),
			names: names,
			mappings: encoded
		});
	};

	Bundle.prototype.getIndentString = function getIndentString() {
		var indentStringCounts = {};

		this.sources.forEach(function (source) {
			var indentStr = source.content.indentStr;

			if (indentStr === null) return;

			if (!indentStringCounts[indentStr]) indentStringCounts[indentStr] = 0;
			indentStringCounts[indentStr] += 1;
		});

		return Object.keys(indentStringCounts).sort(function (a, b) {
			return indentStringCounts[a] - indentStringCounts[b];
		})[0] || '\t';
	};

	Bundle.prototype.indent = function indent(indentStr) {
		var _this2 = this;

		if (!arguments.length) {
			indentStr = this.getIndentString();
		}

		if (indentStr === '') return this; // noop

		var trailingNewline = !this.intro || this.intro.slice(-1) === '\n';

		this.sources.forEach(function (source, i) {
			var separator = source.separator !== undefined ? source.separator : _this2.separator;
			var indentStart = trailingNewline || i > 0 && /\r?\n$/.test(separator);

			source.content.indent(indentStr, {
				exclude: source.indentExclusionRanges,
				indentStart: indentStart //: trailingNewline || /\r?\n$/.test( separator )  //true///\r?\n/.test( separator )
			});

			trailingNewline = source.content.str.slice(0, -1) === '\n';
		});

		if (this.intro) {
			this.intro = indentStr + this.intro.replace(/^[^\n]/gm, function (match, index) {
				return index > 0 ? indentStr + match : match;
			});
		}

		this.outro = this.outro.replace(/^[^\n]/gm, indentStr + '$&');

		return this;
	};

	Bundle.prototype.prepend = function prepend(str) {
		this.intro = str + this.intro;
		return this;
	};

	Bundle.prototype.toString = function toString() {
		var _this3 = this;

		var body = this.sources.map(function (source, i) {
			var separator = source.separator !== undefined ? source.separator : _this3.separator;
			var str = (i > 0 ? separator : '') + source.content.toString();

			return str;
		}).join('');

		return this.intro + body + this.outro;
	};

	Bundle.prototype.trimLines = function trimLines() {
		return this.trim('[\\r\\n]');
	};

	Bundle.prototype.trim = function trim(charType) {
		return this.trimStart(charType).trimEnd(charType);
	};

	Bundle.prototype.trimStart = function trimStart(charType) {
		var rx = new RegExp('^' + (charType || '\\s') + '+');
		this.intro = this.intro.replace(rx, '');

		if (!this.intro) {
			var source = undefined; // TODO put inside loop if safe
			var i = 0;

			do {
				source = this.sources[i];

				if (!source) {
					this.outro = this.outro.replace(rx, '');
					break;
				}

				source.content.trimStart();
				i += 1;
			} while (source.content.str === '');
		}

		return this;
	};

	Bundle.prototype.trimEnd = function trimEnd(charType) {
		var rx = new RegExp((charType || '\\s') + '+$');
		this.outro = this.outro.replace(rx, '');

		if (!this.outro) {
			var source = undefined;
			var i = this.sources.length - 1;

			do {
				source = this.sources[i];

				if (!source) {
					this.intro = this.intro.replace(rx, '');
					break;
				}

				source.content.trimEnd(charType);
				i -= 1;
			} while (source.content.str === '');
		}

		return this;
	};

	return Bundle;
})();

function getSemis(str) {
	return new Array(str.split('\n').length).join(';');
}

var warned = false;

var MagicString = (function () {
	function MagicString(string) {
		var options = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];

		_classCallCheck(this, MagicString);

		this.original = this.str = string;
		this.mappings = initMappings(string.length);

		this.filename = options.filename;
		this.indentExclusionRanges = options.indentExclusionRanges;

		this.sourcemapLocations = {};
		this.nameLocations = {};

		this.indentStr = guessIndent(string);
	}

	MagicString.prototype.addSourcemapLocation = function addSourcemapLocation(char) {
		this.sourcemapLocations[char] = true;
	};

	MagicString.prototype.append = function append(content) {
		if (typeof content !== 'string') {
			throw new TypeError('appended content must be a string');
		}

		this.str += content;
		return this;
	};

	MagicString.prototype.clone = function clone() {
		var clone, i;

		clone = new MagicString(this.original, { filename: this.filename });
		clone.str = this.str;

		i = clone.mappings.length;
		while (i--) {
			clone.mappings[i] = this.mappings[i];
		}

		if (this.indentExclusionRanges) {
			clone.indentExclusionRanges = typeof this.indentExclusionRanges[0] === 'number' ? [this.indentExclusionRanges[0], this.indentExclusionRanges[1]] : this.indentExclusionRanges.map(function (_ref5) {
				var start = _ref5[0];
				var end = _ref5[1];
				return [start, end];
			});
		}

		Object.keys(this.sourcemapLocations).forEach(function (loc) {
			clone.sourcemapLocations[loc] = true;
		});

		return clone;
	};

	MagicString.prototype.generateMap = function generateMap(options) {
		var _this4 = this;

		options = options || {};

		var names = [];
		Object.keys(this.nameLocations).forEach(function (location) {
			var name = _this4.nameLocations[location];
			if (! ~names.indexOf(name)) names.push(name);
		});

		return new SourceMap({
			file: options.file ? options.file.split(/[\/\\]/).pop() : null,
			sources: [options.source ? getRelativePath(options.file || '', options.source) : null],
			sourcesContent: options.includeContent ? [this.original] : [null],
			names: names,
			mappings: this.getMappings(options.hires, 0, {}, names)
		});
	};

	MagicString.prototype.getIndentString = function getIndentString() {
		return this.indentStr === null ? '\t' : this.indentStr;
	};

	MagicString.prototype.getMappings = function getMappings(hires, sourceIndex, offsets, names) {
		return encodeMappings(this.original, this.str, this.mappings, hires, this.sourcemapLocations, sourceIndex, offsets, names, this.nameLocations);
	};

	MagicString.prototype.indent = function indent(indentStr, options) {
		var self = this,
		    mappings = this.mappings,
		    reverseMappings = reverse(mappings, this.str.length),
		    pattern = /^[^\r\n]/gm,
		    match,
		    inserts = [],
		    adjustments,
		    exclusions,
		    lastEnd,
		    i;

		if (typeof indentStr === 'object') {
			options = indentStr;
			indentStr = undefined;
		}

		indentStr = indentStr !== undefined ? indentStr : this.indentStr || '\t';

		if (indentStr === '') return this; // noop

		options = options || {};

		// Process exclusion ranges
		if (options.exclude) {
			exclusions = typeof options.exclude[0] === 'number' ? [options.exclude] : options.exclude;

			exclusions = exclusions.map(function (range) {
				var rangeStart, rangeEnd;

				rangeStart = self.locate(range[0]);
				rangeEnd = self.locate(range[1]);

				if (rangeStart === null || rangeEnd === null) {
					throw new Error('Cannot use indices of replaced characters as exclusion ranges');
				}

				return [rangeStart, rangeEnd];
			});

			exclusions.sort(function (a, b) {
				return a[0] - b[0];
			});

			// check for overlaps
			lastEnd = -1;
			exclusions.forEach(function (range) {
				if (range[0] < lastEnd) {
					throw new Error('Exclusion ranges cannot overlap');
				}

				lastEnd = range[1];
			});
		}

		var indentStart = options.indentStart !== false;

		if (!exclusions) {
			this.str = this.str.replace(pattern, function (match, index) {
				if (!indentStart && index === 0) {
					return match;
				}

				inserts.push(index);
				return indentStr + match;
			});
		} else {
			this.str = this.str.replace(pattern, function (match, index) {
				if (!indentStart && index === 0 || isExcluded(index - 1)) {
					return match;
				}

				inserts.push(index);
				return indentStr + match;
			});
		}

		adjustments = inserts.map(function (index) {
			var origin;

			do {
				origin = reverseMappings[index++];
			} while (! ~origin && index < self.str.length);

			return origin;
		});

		i = adjustments.length;
		lastEnd = this.mappings.length;
		while (i--) {
			adjust(self.mappings, adjustments[i], lastEnd, (i + 1) * indentStr.length);
			lastEnd = adjustments[i];
		}

		return this;

		function isExcluded(index) {
			var i = exclusions.length,
			    range;

			while (i--) {
				range = exclusions[i];

				if (range[1] < index) {
					return false;
				}

				if (range[0] <= index) {
					return true;
				}
			}
		}
	};

	MagicString.prototype.insert = function insert(index, content) {
		if (typeof content !== 'string') {
			throw new TypeError('inserted content must be a string');
		}

		if (index === this.original.length) {
			this.append(content);
		} else {
			var mapped = this.locate(index);

			if (mapped === null) {
				throw new Error('Cannot insert at replaced character index: ' + index);
			}

			this.str = this.str.substr(0, mapped) + content + this.str.substr(mapped);
			adjust(this.mappings, index, this.mappings.length, content.length);
		}

		return this;
	};

	// get current location of character in original string

	MagicString.prototype.locate = function locate(character) {
		var loc;

		if (character < 0 || character > this.mappings.length) {
			throw new Error('Character is out of bounds');
		}

		loc = this.mappings[character];
		return ~loc ? loc : null;
	};

	MagicString.prototype.locateOrigin = function locateOrigin(character) {
		var i;

		if (character < 0 || character >= this.str.length) {
			throw new Error('Character is out of bounds');
		}

		i = this.mappings.length;
		while (i--) {
			if (this.mappings[i] === character) {
				return i;
			}
		}

		return null;
	};

	MagicString.prototype.overwrite = function overwrite(start, end, content, storeName) {
		if (typeof content !== 'string') {
			throw new TypeError('replacement content must be a string');
		}

		var firstChar, lastChar, d;

		firstChar = this.locate(start);
		lastChar = this.locate(end - 1);

		if (firstChar === null || lastChar === null) {
			throw new Error('Cannot overwrite the same content twice: \'' + this.original.slice(start, end).replace(/\n/g, '\\n') + '\'');
		}

		if (firstChar > lastChar + 1) {
			throw new Error('BUG! First character mapped to a position after the last character: ' + '[' + start + ', ' + end + '] -> [' + firstChar + ', ' + (lastChar + 1) + ']');
		}

		if (storeName) {
			this.nameLocations[start] = this.original.slice(start, end);
		}

		this.str = this.str.substr(0, firstChar) + content + this.str.substring(lastChar + 1);

		d = content.length - (lastChar + 1 - firstChar);

		_blank(this.mappings, start, end);
		adjust(this.mappings, end, this.mappings.length, d);
		return this;
	};

	MagicString.prototype.prepend = function prepend(content) {
		this.str = content + this.str;
		adjust(this.mappings, 0, this.mappings.length, content.length);
		return this;
	};

	MagicString.prototype.remove = function remove(start, end) {
		if (start < 0 || end > this.mappings.length) {
			throw new Error('Character is out of bounds');
		}

		var currentStart = -1;
		var currentEnd = -1;
		for (var i = start; i < end; i += 1) {
			var loc = this.mappings[i];

			if (~loc) {
				if (! ~currentStart) currentStart = loc;

				currentEnd = loc + 1;
				this.mappings[i] = -1;
			}
		}

		this.str = this.str.slice(0, currentStart) + this.str.slice(currentEnd);

		adjust(this.mappings, end, this.mappings.length, currentStart - currentEnd);
		return this;
	};

	MagicString.prototype.replace = function replace(start, end, content) {
		if (!warned) {
			console.warn('magicString.replace(...) is deprecated. Use magicString.overwrite(...) instead');
			warned = true;
		}

		return this.overwrite(start, end, content);
	};

	MagicString.prototype.slice = function slice(start) {
		var end = arguments.length <= 1 || arguments[1] === undefined ? this.original.length : arguments[1];

		var firstChar, lastChar;

		while (start < 0) start += this.original.length;
		while (end < 0) end += this.original.length;

		firstChar = this.locate(start);
		lastChar = this.locate(end - 1);

		if (firstChar === null || lastChar === null) {
			throw new Error('Cannot use replaced characters as slice anchors');
		}

		return this.str.slice(firstChar, lastChar + 1);
	};

	MagicString.prototype.snip = function snip(start, end) {
		var clone = this.clone();
		clone.remove(0, start);
		clone.remove(end, clone.original.length);

		return clone;
	};

	MagicString.prototype.toString = function toString() {
		return this.str;
	};

	MagicString.prototype.trimLines = function trimLines() {
		return this.trim('[\\r\\n]');
	};

	MagicString.prototype.trim = function trim(charType) {
		return this.trimStart(charType).trimEnd(charType);
	};

	MagicString.prototype.trimEnd = function trimEnd(charType) {
		var self = this;
		var rx = new RegExp((charType || '\\s') + '+$');

		this.str = this.str.replace(rx, function (trailing, index, str) {
			var strLength = str.length,
			    length = trailing.length,
			    i,
			    chars = [];

			i = strLength;
			while (i-- > strLength - length) {
				chars.push(self.locateOrigin(i));
			}

			i = chars.length;
			while (i--) {
				if (chars[i] !== null) {
					self.mappings[chars[i]] = -1;
				}
			}

			return '';
		});

		return this;
	};

	MagicString.prototype.trimStart = function trimStart(charType) {
		var self = this;
		var rx = new RegExp('^' + (charType || '\\s') + '+');

		this.str = this.str.replace(rx, function (leading) {
			var length = leading.length,
			    i,
			    chars = [],
			    adjustmentStart = 0;

			i = length;
			while (i--) {
				chars.push(self.locateOrigin(i));
			}

			i = chars.length;
			while (i--) {
				if (chars[i] !== null) {
					self.mappings[chars[i]] = -1;
					adjustmentStart += 1;
				}
			}

			adjust(self.mappings, adjustmentStart, self.mappings.length, -length);

			return '';
		});

		return this;
	};

	return MagicString;
})();

function adjust(mappings, start, end, d) {
	var i = end;

	if (!d) return; // replacement is same length as replaced string

	while (i-- > start) {
		if (~mappings[i]) {
			mappings[i] += d;
		}
	}
}

function initMappings(i) {
	var mappings = new Uint32Array(i);

	while (i--) {
		mappings[i] = i;
	}

	return mappings;
}

function _blank(mappings, start, i) {
	while (i-- > start) {
		mappings[i] = -1;
	}
}

function reverse(mappings, i) {
	var result, location;

	result = new Uint32Array(i);

	while (i--) {
		result[i] = -1;
	}

	i = mappings.length;
	while (i--) {
		location = mappings[i];

		if (~location) {
			result[location] = i;
		}
	}

	return result;
}

MagicString.Bundle = Bundle;

function badExports(option, keys) {
	throw new Error('\'' + option + '\' was specified for options.exports, but entry module has following exports: ' + keys.join(', '));
}

function getExportMode(bundle, exportMode) {
	var exportKeys = keys(bundle.entryModule.exports.names);

	if (exportMode === 'default') {
		if (exportKeys.length !== 1 || exportKeys[0] !== 'default') {
			badExports('default', exportKeys);
		}
	} else if (exportMode === 'none' && exportKeys.length) {
		badExports('none', exportKeys);
	}

	if (!exportMode || exportMode === 'auto') {
		if (exportKeys.length === 0) {
			exportMode = 'none';
		} else if (exportKeys.length === 1 && exportKeys[0] === 'default') {
			exportMode = 'default';
		} else {
			exportMode = 'named';
		}
	}

	if (!/(?:default|named|none)/.test(exportMode)) {
		throw new Error('options.exports must be \'default\', \'named\', \'none\', \'auto\', or left unspecified (defaults to \'auto\')');
	}

	return exportMode;
}

var reservedWords = 'break case class catch const continue debugger default delete do else export extends finally for function if import in instanceof let new return super switch this throw try typeof var void while with yield enum await implements package protected static interface private public'.split(' ');
var builtins = 'Infinity NaN undefined null true false eval uneval isFinite isNaN parseFloat parseInt decodeURI decodeURIComponent encodeURI encodeURIComponent escape unescape Object Function Boolean Symbol Error EvalError InternalError RangeError ReferenceError SyntaxError TypeError URIError Number Math Date String RegExp Array Int8Array Uint8Array Uint8ClampedArray Int16Array Uint16Array Int32Array Uint32Array Float32Array Float64Array Map Set WeakMap WeakSet SIMD ArrayBuffer DataView JSON Promise Generator GeneratorFunction Reflect Proxy Intl'.split(' ');

var blacklisted = blank();
reservedWords.concat(builtins).forEach(function (word) {
	return blacklisted[word] = true;
});

function makeLegalIdentifier(str) {
	str = str.replace(/-(\w)/g, function (_, letter) {
		return letter.toUpperCase();
	}).replace(/[^$_a-zA-Z0-9]/g, '_');

	if (/\d/.test(str[0]) || blacklisted[str]) str = '_' + str;

	return str;
}

// An external identifier.

var Id = (function () {
	function Id(module, name) {
		_classCallCheck(this, Id);

		this.originalName = this.name = name;
		this.module = module;

		this.modifierStatements = [];
	}

	// Flags the identifier as imported by the bundle when marked.

	Id.prototype.mark = function mark() {
		this.module.importedByBundle[this.originalName] = true;
		this.modifierStatements.forEach(function (stmt) {
			return stmt.mark();
		});
	};

	return Id;
})();

var ExternalModule = (function () {
	function ExternalModule(_ref6) {
		var _this5 = this;

		var id = _ref6.id;
		var bundle = _ref6.bundle;

		_classCallCheck(this, ExternalModule);

		this.id = id;

		// Implement `Identifier` interface.
		this.originalName = this.name = makeLegalIdentifier(id);
		this.module = this;
		this.isModule = true;

		// Define the external module's name in the bundle scope.
		bundle.scope.define(id, this);

		this.isExternal = true;
		this.importedByBundle = blank();

		// Invariant: needsNamed and needsAll are never both true at once.
		// Because an import with both a namespace and named import is invalid:
		//
		// 		import * as ns, { a } from '...'
		//
		this.needsNamed = false;
		this.needsAll = false;

		this.exports = bundle.scope.virtual(false);

		var reference = this.exports.reference;

		// Override reference.
		this.exports.reference = function (name) {
			if (name !== 'default') {
				_this5.needsNamed = true;
			}

			if (!_this5.exports.defines(name)) {
				_this5.exports.define(name, new Id(_this5, name));
			}

			return reference.call(_this5.exports, name);
		};
	}

	// External modules are always marked for inclusion in the bundle.
	// Marking an external module signals its use as a namespace.

	ExternalModule.prototype.mark = function mark() {
		this.needsAll = true;
	};

	return ExternalModule;
})();

var shouldSkip = undefined;
var shouldAbort = undefined;

function walk(ast, _ref7) {
	var enter = _ref7.enter;
	var leave = _ref7.leave;

	shouldAbort = false;
	visit(ast, null, enter, leave);
}

var context = {
	skip: function () {
		return shouldSkip = true;
	},
	abort: function () {
		return shouldAbort = true;
	}
};

var childKeys = blank();

var toString = Object.prototype.toString;

function isArray(thing) {
	return toString.call(thing) === '[object Array]';
}

function visit(node, parent, enter, leave) {
	if (!node || shouldAbort) return;

	if (enter) {
		shouldSkip = false;
		enter.call(context, node, parent);
		if (shouldSkip || shouldAbort) return;
	}

	var keys = childKeys[node.type] || (childKeys[node.type] = Object.keys(node).filter(function (key) {
		return typeof node[key] === 'object';
	}));

	var key = undefined,
	    value = undefined,
	    i = undefined,
	    j = undefined;

	i = keys.length;
	while (i--) {
		key = keys[i];
		value = node[key];

		if (isArray(value)) {
			j = value.length;
			while (j--) {
				visit(value[j], node, enter, leave);
			}
		} else if (value && value.type) {
			visit(value, node, enter, leave);
		}
	}

	if (leave && !shouldAbort) {
		leave(node, parent);
	}
}

function getLocation(source, charIndex) {
	var lines = source.split('\n');
	var len = lines.length;

	var lineStart = 0;
	var i = undefined;

	for (i = 0; i < len; i += 1) {
		var line = lines[i];
		var lineEnd = lineStart + line.length + 1; // +1 for newline

		if (lineEnd > charIndex) {
			return { line: i + 1, column: charIndex - lineStart };
		}

		lineStart = lineEnd;
	}

	throw new Error('Could not determine location of character');
}

var extractors = {
	Identifier: function (names, param) {
		names.push(param.name);
	},

	ObjectPattern: function (names, param) {
		param.properties.forEach(function (prop) {
			extractors[prop.key.type](names, prop.key);
		});
	},

	ArrayPattern: function (names, param) {
		param.elements.forEach(function (element) {
			if (element) extractors[element.type](names, element);
		});
	},

	RestElement: function (names, param) {
		extractors[param.argument.type](names, param.argument);
	},

	AssignmentPattern: function (names, param) {
		return extractors[param.left.type](names, param.left);
	}
};

function extractNames(param) {
	var names = [];

	extractors[param.type](names, param);
	return names;
}

var _Scope = (function () {
	function _Scope(options) {
		var _this6 = this;

		_classCallCheck(this, _Scope);

		options = options || {};

		this.parent = options.parent;
		this.depth = this.parent ? this.parent.depth + 1 : 0;
		this.declarations = blank();
		this.isBlockScope = !!options.block;

		this.varDeclarations = [];

		if (options.params) {
			options.params.forEach(function (param) {
				extractNames(param).forEach(function (name) {
					_this6.declarations[name] = true;
				});
			});
		}
	}

	_Scope.prototype.addDeclaration = function addDeclaration(declaration, isBlockDeclaration, isVar) {
		var _this7 = this;

		if (!isBlockDeclaration && this.isBlockScope) {
			// it's a `var` or function node, and this
			// is a block scope, so we need to go up
			this.parent.addDeclaration(declaration, isBlockDeclaration, isVar);
		} else {
			extractNames(declaration.id).forEach(function (name) {
				_this7.declarations[name] = true;
				if (isVar) _this7.varDeclarations.push(name);
			});
		}
	};

	_Scope.prototype.contains = function contains(name) {
		return this.declarations[name] || (this.parent ? this.parent.contains(name) : false);
	};

	_Scope.prototype.findDefiningScope = function findDefiningScope(name) {
		if (this.declarations[name]) {
			return this;
		}

		if (this.parent) {
			return this.parent.findDefiningScope(name);
		}

		return null;
	};

	return _Scope;
})();

var blockDeclarations = {
	'const': true,
	'let': true
};

var modifierNodes = {
	AssignmentExpression: 'left',
	UpdateExpression: 'argument'
};

function isIife(node, parent) {
	return parent && parent.type === 'CallExpression' && node === parent.callee;
}

function isFunctionDeclaration(node, parent) {
	// `function foo () {}`
	if (node.type === 'FunctionDeclaration') return true;

	// `var foo = function () {}` - same thing for present purposes
	if (node.type === 'FunctionExpression' && parent.type === 'VariableDeclarator') return true;
}

function chainedMemberExpression(node) {
	if (node.object.type === 'MemberExpression') {
		return chainedMemberExpression(node.object) + '.' + node.property.name;
	}

	return node.object.name + '.' + node.property.name;
}

var Statement = (function () {
	function Statement(node, module, start, end) {
		_classCallCheck(this, Statement);

		this.node = node;
		this.module = module;
		this.start = start;
		this.end = end;
		this.next = null; // filled in later

		this.scope = new _Scope();
		this.defines = blank();
		this.dependsOn = blank();
		this.stronglyDependsOn = blank();

		this.reassigns = blank();

		// TODO: make this more efficient
		this.dependantIds = [];
		this.namespaceReplacements = [];

		this.isIncluded = false;

		this.isImportDeclaration = node.type === 'ImportDeclaration';
		this.isExportDeclaration = /^Export/.test(node.type);
		this.isReexportDeclaration = this.isExportDeclaration && !!node.source;
	}

	Statement.prototype.analyse = function analyse() {
		var _this8 = this;

		if (this.isImportDeclaration) return; // nothing to analyse

		// `export { name } from './other'` is a special case
		if (this.isReexportDeclaration) {
			this.node.specifiers && this.node.specifiers.forEach(function (specifier) {
				var id = _this8.module.exports.lookup(specifier.exported.name);

				if (! ~_this8.dependantIds.indexOf(id)) {
					_this8.dependantIds.push(id);
				}
			});

			return;
		}

		var scope = this.scope;

		walk(this.node, {
			enter: function (node, parent) {
				var newScope = undefined;

				switch (node.type) {
					case 'FunctionDeclaration':
						scope.addDeclaration(node, false, false);

					case 'BlockStatement':
						if (parent && /Function/.test(parent.type)) {
							newScope = new _Scope({
								parent: scope,
								block: false,
								params: parent.params
							});

							// named function expressions - the name is considered
							// part of the function's scope
							if (parent.type === 'FunctionExpression' && parent.id) {
								newScope.addDeclaration(parent, false, false);
							}
						} else {
							newScope = new _Scope({
								parent: scope,
								block: true
							});
						}

						break;

					case 'CatchClause':
						newScope = new _Scope({
							parent: scope,
							params: [node.param],
							block: true
						});

						break;

					case 'VariableDeclaration':
						node.declarations.forEach(function (declarator) {
							var isBlockDeclaration = node.type === 'VariableDeclaration' && blockDeclarations[node.kind];
							scope.addDeclaration(declarator, isBlockDeclaration, true);
						});
						break;

					case 'ClassDeclaration':
						scope.addDeclaration(node, false, false);
						break;
				}

				if (newScope) {
					Object.defineProperty(node, '_scope', {
						value: newScope,
						configurable: true
					});

					scope = newScope;
				}
			},
			leave: function (node) {
				if (node._scope) {
					scope = scope.parent;
				}
			}
		});

		// This allows us to track whether we're looking at code that will
		// be executed immediately (either outside a function, or immediately
		// inside an IIFE), for the purposes of determining whether dependencies
		// are strong or weak. It's not bulletproof, since it wouldn't catch...
		//
		//    var calledImmediately = function () {
		//      doSomethingWith( strongDependency );
		//    }
		//    calledImmediately();
		//
		// ...but it's better than nothing
		var readDepth = 0;

		// This allows us to track whether a modifying statement (i.e. assignment
		// /update expressions) need to be captured
		var writeDepth = 0;

		// Used to track
		var topName = undefined;
		var currentMemberExpression = null;
		var namespace = null;

		if (!this.isImportDeclaration) {
			walk(this.node, {
				enter: function (node, parent) {
					if (isFunctionDeclaration(node, parent)) writeDepth += 1;
					if (/Function/.test(node.type) && !isIife(node, parent)) readDepth += 1;

					if (node._scope) scope = node._scope;

					_this8.checkForReads(scope, node, parent, !readDepth);
					_this8.checkForWrites(scope, node, writeDepth);
				},
				leave: function (node, parent) {
					if (isFunctionDeclaration(node, parent)) writeDepth -= 1;
					if (/Function/.test(node.type) && !isIife(node, parent)) readDepth -= 1;

					if (node._scope) scope = scope.parent;

					// Optimize namespace lookups, which manifest as MemberExpressions.
					if (node.type === 'MemberExpression' && (!currentMemberExpression || node.object === currentMemberExpression)) {
						currentMemberExpression = node;

						if (!namespace) {
							topName = node.object.name;
							var _id = _this8.module.locals.lookup(topName);

							if (!_id || !_id.isModule || _id.isExternal) return;

							namespace = _id;
						}

						// If a namespace is the left hand side of an assignment, throw an error.
						if (parent.type === 'AssignmentExpression' && parent.left === node || parent.type === 'UpdateExpression' && parent.argument === node) {
							var err = new Error('Illegal reassignment to import \'' + chainedMemberExpression(node) + '\'');
							err.file = _this8.module.id;
							err.loc = getLocation(_this8.module.magicString.toString(), node.start);
							throw err;
						}

						// Extract the name of the accessed property, from and Identifier or Literal.
						// Any eventual Literal value is converted to a string.
						var _name = !node.computed ? node.property.name : node.property.type === 'Literal' ? String(node.property.value) : null;

						// If we can't resolve the name being accessed statically,
						// we mark the whole namespace for inclusion in the bundle.
						//
						//     // resolvable
						//     console.log( javascript.keywords.for )
						//     console.log( javascript.keywords[ 'for' ] )
						//     console.log( javascript.keywords[ 6 ] )
						//
						//     // unresolvable
						//     console.log( javascript.keywords[ index ] )
						//     console.log( javascript.keywords[ 1 + 5 ] )
						if (_name === null) {
							namespace.mark();

							namespace = null;
							currentMemberExpression = null;
							return;
						}

						var id = namespace.exports.lookup(_name);

						// If the namespace doesn't define the given name,
						// we can throw an error (even for nested namespaces).
						if (!id) {
							throw new Error('Module doesn\'t define "' + _name + '"!');
						}

						// We can't resolve deeper. Replace the member chain.
						if (parent.type !== 'MemberExpression' || !(id.isModule && !id.isExternal)) {
							if (! ~_this8.dependantIds.indexOf(id)) {
								_this8.dependantIds.push(id);
							}

							// FIXME: do this better
							// If we depend on this name...
							if (_this8.dependsOn[topName]) {
								// ... decrement the count...
								if (! --_this8.dependsOn[topName]) {
									// ... and remove it if the count is 0.
									delete _this8.dependsOn[topName];
								}
							}

							_this8.namespaceReplacements.push([node, id]);
							namespace = null;
							currentMemberExpression = null;
							return;
						}

						namespace = id;
					}
				}
			});
		}

		keys(scope.declarations).forEach(function (name) {
			_this8.defines[name] = true;
		});
	};

	Statement.prototype.checkForReads = function checkForReads(scope, node, parent, strong) {
		if (node.type === 'Identifier') {
			// disregard the `bar` in `foo.bar` - these appear as Identifier nodes
			if (parent.type === 'MemberExpression' && !parent.computed && node !== parent.object) {
				return;
			}

			// disregard the `bar` in { bar: foo }
			if (parent.type === 'Property' && node !== parent.value) {
				return;
			}

			// disregard the `bar` in `class Foo { bar () {...} }`
			if (parent.type === 'MethodDefinition') return;

			// disregard the `bar` in `export { foo as bar }`
			if (parent.type === 'ExportSpecifier' && node !== parent.local) return;

			var definingScope = scope.findDefiningScope(node.name);

			if (!definingScope || definingScope.depth === 0) {
				if (!(node.name in this.dependsOn)) {
					this.dependsOn[node.name] = 0;
				}

				this.dependsOn[node.name]++;
				if (strong) this.stronglyDependsOn[node.name] = true;
			}
		}
	};

	Statement.prototype.checkForWrites = function checkForWrites(scope, node, writeDepth) {
		var _this9 = this;

		var addNode = function (node, isAssignment) {
			var depth = 0; // determine whether we're illegally modifying a binding or namespace

			while (node.type === 'MemberExpression') {
				node = node.object;
				depth += 1;
			}

			// disallow assignments/updates to imported bindings and namespaces
			if (isAssignment) {
				var importSpecifier = _this9.module.locals.lookup(node.name);

				if (importSpecifier && importSpecifier.module !== _this9.module && !scope.contains(node.name)) {
					var minDepth = importSpecifier.name === '*' ? 2 : // cannot do e.g. `namespace.foo = bar`
					1; // cannot do e.g. `foo = bar`, but `foo.bar = bar` is fine

					if (depth < minDepth) {
						var err = new Error('Illegal reassignment to import \'' + node.name + '\'');
						err.file = _this9.module.id;
						err.loc = getLocation(_this9.module.magicString.toString(), node.start);
						throw err;
					}
				}

				// special case = `export default foo; foo += 1;` - we'll
				// need to assign a new variable so that the exported
				// value is not updated by the second statement
				var def = _this9.module.exports.lookup('default');
				if (def && depth === 0 && def.name === node.name) {
					// but only if this is a) inside a function body or
					// b) after the export declaration
					if (!!scope.parent || node.start > def.statement.node.start) {
						def.isModified = true;
					}
				}

				// we track updates/reassignments to variables, to know whether we
				// need to rewrite it later from `foo` to `exports.foo` to keep
				// bindings live
				if (depth === 0 && writeDepth > 0 && !scope.contains(node.name)) {
					_this9.reassigns[node.name] = true;
				}
			}

			// we only care about writes that happen a) at the top level,
			// or b) inside a function that could be immediately invoked.
			// Writes inside named functions are only relevant if the
			// function is called, in which case we don't need to do
			// anything (but we still need to call checkForWrites to
			// catch illegal reassignments to imported bindings)
			if (writeDepth === 0 && node.type === 'Identifier') {
				var id = _this9.module.locals.lookup(node.name);

				if (id && id.modifierStatements && ! ~id.modifierStatements.indexOf(_this9)) {
					id.modifierStatements.push(_this9);
				}
			}
		};

		if (node.type === 'AssignmentExpression') {
			addNode(node.left, true);
		} else if (node.type === 'UpdateExpression') {
			addNode(node.argument, true);
		} else if (node.type === 'CallExpression') {
			node.arguments.forEach(function (arg) {
				return addNode(arg, false);
			});

			// `foo.bar()` is assumed to mutate foo
			if (node.callee.type === 'MemberExpression') {
				addNode(node.callee);
			}
		}
	};

	Statement.prototype.mark = function mark() {
		var _this10 = this;

		if (this.isIncluded) return; // prevent infinite loops
		this.isIncluded = true;

		this.dependantIds.forEach(function (id) {
			return id.mark();
		});

		// TODO: perhaps these could also be added?
		keys(this.dependsOn).forEach(function (name) {
			if (_this10.defines[name]) return; // TODO maybe exclude from `this.dependsOn` in the first place?
			_this10.module.locals.lookup(name).mark();
		});
	};

	Statement.prototype.markSideEffect = function markSideEffect() {
		var statement = this;

		walk(this.node, {
			enter: function (node, parent) {
				if (/Function/.test(node.type) && !isIife(node, parent)) return this.skip();

				// If this is a top-level call expression, or an assignment to a global,
				// this statement will need to be marked
				if (node.type === 'CallExpression') {
					statement.mark();
				} else if (node.type in modifierNodes) {
					var subject = node[modifierNodes[node.type]];
					while (subject.type === 'MemberExpression') subject = subject.object;

					if (statement.module.bundle.globals.defines(subject.name)) statement.mark();
				}
			}
		});
	};

	Statement.prototype.replaceIdentifiers = function replaceIdentifiers(magicString, names, bundleExports) {
		var statement = this;

		var replacementStack = [];
		var nameList = keys(names);

		var deshadowList = [];
		nameList.forEach(function (name) {
			var replacement = names[name];
			deshadowList.push(replacement.split('.')[0]);
		});

		var topLevel = true;
		var depth = 0;

		walk(this.node, {
			enter: function (node, parent) {
				var _this11 = this;

				if (node._skip) return this.skip();

				if (/^Function/.test(node.type)) depth += 1;

				// `this` is undefined at the top level of ES6 modules
				if (node.type === 'ThisExpression' && depth === 0) {
					magicString.overwrite(node.start, node.end, 'undefined', true);
				}

				// special case - variable declarations that need to be rewritten
				// as bundle exports
				if (topLevel) {
					if (node.type === 'VariableDeclaration') {
						// if this contains a single declarator, and it's one that
						// needs to be rewritten, we replace the whole lot
						var id = node.declarations[0].id;
						var _name2 = id.name;

						if (node.declarations.length === 1 && bundleExports[_name2]) {
							magicString.overwrite(node.start, id.end, bundleExports[_name2], true);
							id._skip = true;
						}

						// otherwise, we insert the `exports.foo = foo` after the declaration
						else {
								var exportInitialisers = node.declarations.map(function (declarator) {
									return declarator.id.name;
								}).filter(function (name) {
									return !!bundleExports[name];
								}).map(function (name) {
									return '\n' + bundleExports[name] + ' = ' + name + ';';
								}).join('');

								if (exportInitialisers) {
									// TODO clean this up
									try {
										magicString.insert(node.end, exportInitialisers);
									} catch (err) {
										magicString.append(exportInitialisers);
									}
								}
							}
					}
				}

				var scope = node._scope;

				if (scope) {
					var _ret = (function () {
						topLevel = false;

						var newNames = blank();
						var hasReplacements = undefined;

						keys(names).forEach(function (name) {
							if (!scope.declarations[name]) {
								newNames[name] = names[name];
								hasReplacements = true;
							}
						});

						deshadowList.forEach(function (name) {
							if (scope.declarations[name]) {
								newNames[name] = name + '$$'; // TODO better mechanism
								hasReplacements = true;
							}
						});

						if (!hasReplacements && depth > 0) {
							return {
								v: _this11.skip()
							};
						}

						names = newNames;
						replacementStack.push(newNames);
					})();

					if (typeof _ret === 'object') return _ret.v;
				}

				if (node.type === 'MemberExpression') {
					var replacements = statement.namespaceReplacements;
					for (var i = 0; i < replacements.length; i += 1) {
						var _replacements$i = replacements[i];
						var _top = _replacements$i[0];
						var id = _replacements$i[1];

						if (node === _top) {
							magicString.overwrite(node.start, node.end, id.name);
							return this.skip();
						}
					}
				}

				if (node.type !== 'Identifier') return;

				// if there's no replacement, or it's the same, there's nothing more to do
				var name = names[node.name];
				if (!name || name === node.name) return;

				// shorthand properties (`obj = { foo }`) need to be expanded
				if (parent.type === 'Property' && parent.shorthand) {
					magicString.insert(node.end, ': ' + name);
					parent.key._skip = true;
					parent.value._skip = true; // redundant, but defensive
					return;
				}

				// property names etc can be disregarded
				if (parent.type === 'MemberExpression' && !parent.computed && node !== parent.object) return;
				if (parent.type === 'Property' && node !== parent.value) return;
				if (parent.type === 'MethodDefinition' && node === parent.key) return;
				if (parent.type === 'FunctionExpression') return;
				if (/Function/.test(parent.type) && ~parent.params.indexOf(node)) return;
				// TODO others...?

				// all other identifiers should be overwritten
				magicString.overwrite(node.start, node.end, name, true);
			},

			leave: function (node) {
				if (/^Function/.test(node.type)) depth -= 1;

				if (node._scope) {
					names = replacementStack.pop();
				}
			}
		});

		return magicString;
	};

	Statement.prototype.source = function source() {
		return this.module.source.slice(this.start, this.end);
	};

	Statement.prototype.toString = function toString() {
		return this.module.magicString.slice(this.start, this.end);
	};

	return Statement;
})();

function isEmptyExportedVarDeclaration(node, exports, toExport) {
	if (node.type !== 'VariableDeclaration' || node.declarations[0].init) return false;

	var name = node.declarations[0].id.name;

	var id = exports.lookup(name);

	return id && id.name in toExport;
}

function removeSourceMappingURLComments(source, magicString) {
	var SOURCEMAPPING_URL_PATTERN = new RegExp('\\/\\/#\\s+' + SOURCEMAPPING_URL + '=.+\\n?', 'g');
	var match = undefined;

	while (match = SOURCEMAPPING_URL_PATTERN.exec(source)) {
		magicString.remove(match.index, match.index + match[0].length);
	}
}

function assign(target, source) {
	for (var key in source) {
		target[key] = source[key];
	}
}

var _Id = (function () {
	function _Id(module, name, statement) {
		_classCallCheck(this, _Id);

		this.originalName = this.name = name;
		this.module = module;
		this.statement = statement;

		this.modifierStatements = [];

		// modifiers
		this.isUsed = false;
	}

	_Id.prototype.mark = function mark() {
		this.isUsed = true;
		this.statement.mark();
		this.modifierStatements.forEach(function (stmt) {
			return stmt.mark();
		});
	};

	return _Id;
})();

var Module = (function () {
	function Module(_ref8) {
		var _this12 = this;

		var id = _ref8.id;
		var source = _ref8.source;
		var ast = _ref8.ast;
		var bundle = _ref8.bundle;

		_classCallCheck(this, Module);

		this.source = source;

		this.bundle = bundle;
		this.id = id;
		this.module = this;
		this.isModule = true;

		// Implement Identifier interface.
		this.name = makeLegalIdentifier(basename(id).slice(0, -extname(id).length));

		// HACK: If `id` isn't a path, the above code yields the empty string.
		if (!this.name) {
			this.name = makeLegalIdentifier(id);
		}

		// By default, `id` is the filename. Custom resolvers and loaders
		// can change that, but it makes sense to use it for the source filename
		this.magicString = new MagicString(source, {
			filename: id
		});

		removeSourceMappingURLComments(source, this.magicString);

		this.comments = [];

		this.statements = this.parse(ast);

		// all dependencies
		this.resolvedIds = blank();

		// Virtual scopes for the local and exported names.
		this.locals = bundle.scope.virtual(true);
		this.exports = bundle.scope.virtual(false);

		var _exports2 = this.exports;
		var reference = _exports2.reference;
		var inScope = _exports2.inScope;

		this.exports.reference = function (name) {
			// If we have it, grab it.
			if (inScope.call(_this12.exports, name)) {
				return reference.call(_this12.exports, name);
			}

			// ... otherwise search allExportsFrom
			for (var i = 0; i < _this12.allExportsFrom.length; i += 1) {
				var _module2 = _this12.allExportsFrom[i];
				if (_module2.exports.inScope(name)) {
					return _module2.exports.reference(name);
				}
			}

			// throw new Error( `The name "${name}" is never exported (from ${this.id})!` );
			return reference.call(_this12.exports, name);
		};

		this.exports.inScope = function (name) {
			if (inScope.call(_this12.exports, name)) return true;

			return _this12.allExportsFrom.some(function (module) {
				return module.exports.inScope(name);
			});
		};

		// Create a unique virtual scope for references to the module.
		// const unique = bundle.scope.virtual();
		// unique.define( this.name, this );
		// this.reference = unique.reference( this.name );

		// As far as we know, all our exported bindings have been resolved.
		this.allExportsResolved = true;
		this.allExportsFrom = [];

		this.reassignments = [];

		// TODO: change to false, and detect when it's necessary.
		this.needsDynamicAccess = false;

		this.dependencies = this.collectDependencies();
	}

	// A minimal `Identifier` implementation. Anything that has an `originalName`,
	// and a mutable `name` property can be used as an `Identifier`.

	Module.prototype.addExport = function addExport(statement) {
		var _this13 = this;

		var node = statement.node;
		var source = node.source && node.source.value;

		// export { name } from './other'
		if (source) {
			(function () {
				var module = _this13.getModule(source);

				if (node.type === 'ExportAllDeclaration') {
					// Store `export * from '...'` statements in an array of delegates.
					// When an unknown import is encountered, we see if one of them can satisfy it.

					if (module.isExternal) {
						var err = new Error('Cannot trace \'export *\' references through external modules.');
						err.file = _this13.id;
						err.loc = getLocation(_this13.source, node.start);
						throw err;
					}

					// It seems like we must re-export all exports from another module...
					_this13.allExportsResolved = false;

					if (! ~_this13.allExportsFrom.indexOf(module)) {
						_this13.allExportsFrom.push(module);
					}
				} else {
					node.specifiers.forEach(function (specifier) {
						// Bind the export of this module, to the export of the other.
						_this13.exports.bind(specifier.exported.name, module.exports.reference(specifier.local.name));
					});
				}
			})();
		}

		// export default function foo () {}
		// export default foo;
		// export default 42;
		else if (node.type === 'ExportDefaultDeclaration') {
				var isDeclaration = /Declaration$/.test(node.declaration.type);
				var isAnonymous = /(?:Class|Function)Expression$/.test(node.declaration.type);

				var identifier = isDeclaration ? node.declaration.id.name : node.declaration.type === 'Identifier' ? node.declaration.name : null;
				var _name3 = identifier || this.name;

				// Always define a new `Identifier` for the default export.
				var id = new _Id(this, _name3, statement);

				// Keep the identifier name, if one exists.
				// We can optimize the newly created default `Identifier` away,
				// if it is never modified.
				// in case of `export default foo; foo = somethingElse`
				assign(id, { isDeclaration: isDeclaration, isAnonymous: isAnonymous, identifier: identifier });

				this.exports.define('default', id);
			}

			// export { foo, bar, baz }
			// export var foo = 42;
			// export function foo () {}
			else if (node.type === 'ExportNamedDeclaration') {
					if (node.specifiers.length) {
						// export { foo, bar, baz }
						node.specifiers.forEach(function (specifier) {
							var localName = specifier.local.name;
							var exportedName = specifier.exported.name;

							_this13.exports.bind(exportedName, _this13.locals.reference(localName));
						});
					} else {
						var declaration = node.declaration;

						var _name4 = undefined;

						if (declaration.type === 'VariableDeclaration') {
							// export var foo = 42
							_name4 = declaration.declarations[0].id.name;
						} else {
							// export function foo () {}
							_name4 = declaration.id.name;
						}

						this.locals.define(_name4, new _Id(this, _name4, statement));
						this.exports.bind(_name4, this.locals.reference(_name4));
					}
				}
	};

	Module.prototype.addImport = function addImport(statement) {
		var _this14 = this;

		var node = statement.node;
		var module = this.getModule(node.source.value);

		node.specifiers.forEach(function (specifier) {
			var isDefault = specifier.type === 'ImportDefaultSpecifier';
			var isNamespace = specifier.type === 'ImportNamespaceSpecifier';

			var localName = specifier.local.name;

			if (_this14.locals.defines(localName)) {
				var err = new Error('Duplicated import \'' + localName + '\'');
				err.file = _this14.id;
				err.loc = getLocation(_this14.source, specifier.start);
				throw err;
			}

			if (isNamespace) {
				// If it's a namespace import, we bind the localName to the module itself.
				module.needsAll = true;
				module.name = localName;
				_this14.locals.bind(localName, module);
			} else {
				var _name5 = isDefault ? 'default' : specifier.imported.name;

				_this14.locals.bind(localName, module.exports.reference(_name5));

				// For compliance with earlier Rollup versions.
				// If the module is external, and we access the default.
				// Rewrite the module name, and the default name to the
				// `localName` we use for it.
				if (module.isExternal && isDefault) {
					var id = module.exports.lookup(_name5);
					module.name = id.name = localName;
					id.name += '__default';
				}
			}
		});
	};

	Module.prototype.analyse = function analyse() {
		var _this15 = this;

		// discover this module's imports and exports
		this.statements.forEach(function (statement) {
			if (statement.isImportDeclaration) _this15.addImport(statement);else if (statement.isExportDeclaration) _this15.addExport(statement);

			statement.analyse();

			// consolidate names that are defined/modified in this module
			keys(statement.defines).forEach(function (name) {
				_this15.locals.define(name, new _Id(_this15, name, statement));
			});
		});

		// If all exports aren't resolved, but all our delegate modules are...
		if (!this.allExportsResolved && this.allExportsFrom.every(function (module) {
			return module.allExportsResolved;
		})) {
			// .. then all our exports should be as well.
			this.allExportsResolved = true;

			// For all modules we export all from, iterate through its exported names.
			// If we don't already define the binding 'name',
			// bind the name to the other module's reference.
			this.allExportsFrom.forEach(function (module) {
				module.exports.getNames().forEach(function (name) {
					if (!_this15.exports.defines(name)) {
						_this15.exports.bind(name, module.exports.reference(name));
					}
				});
			});
		}

		// discover variables that are reassigned inside function
		// bodies, so we can keep bindings live, e.g.
		//
		//   export var count = 0;
		//   export function incr () { count += 1 }
		var reassigned = blank();
		this.statements.forEach(function (statement) {
			keys(statement.reassigns).forEach(function (name) {
				reassigned[name] = true;
			});
		});

		// if names are referenced that are neither defined nor imported
		// in this module, we assume that they're globals
		this.statements.forEach(function (statement) {
			if (statement.isReexportDeclaration) return;

			// while we're here, mark reassignments
			statement.scope.varDeclarations.forEach(function (name) {
				if (reassigned[name] && ! ~_this15.reassignments.indexOf(name)) {
					_this15.reassignments.push(name);
				}
			});

			keys(statement.dependsOn).forEach(function (name) {
				// For each name we depend on that isn't in scope,
				// add a new global and bind the local name to it.
				if (!_this15.locals.inScope(name)) {
					_this15.bundle.globals.define(name, {
						originalName: name,
						name: name,
						mark: function () {}
					});
					_this15.locals.bind(name, _this15.bundle.globals.reference(name));
				}
			});
		});

		// OPTIMIZATION!
		// If we have a default export and it's value is never modified,
		// bind to it directly.
		var def = this.exports.lookup('default');
		if (def && !def.isModified && def.identifier) {
			this.exports.bind('default', this.locals.reference(def.identifier));
		}
	};

	// Returns the set of imported module ids by going through all import/exports statements.

	Module.prototype.collectDependencies = function collectDependencies() {
		var importedModules = blank();

		this.statements.forEach(function (statement) {
			if (statement.isImportDeclaration || statement.isExportDeclaration && statement.node.source) {
				importedModules[statement.node.source.value] = true;
			}
		});

		return keys(importedModules);
	};

	Module.prototype.consolidateDependencies = function consolidateDependencies() {
		var _this16 = this;

		var strongDependencies = blank();

		function addDependency(dependencies, declaration) {
			if (declaration && declaration.module && !declaration.module.isExternal) {
				dependencies[declaration.module.id] = declaration.module;
				return true;
			}
		}

		this.statements.forEach(function (statement) {
			if (statement.isImportDeclaration && !statement.node.specifiers.length) {
				// include module for its side-effects
				var _module3 = _this16.getModule(statement.node.source.value);

				if (!_module3.isExternal) strongDependencies[_module3.id] = _module3;
			} else if (statement.isReexportDeclaration) {
				if (statement.node.specifiers) {
					statement.node.specifiers.forEach(function (specifier) {
						var name = specifier.exported.name;

						var id = _this16.exports.lookup(name);

						addDependency(strongDependencies, id);
					});
				}
			} else {
				keys(statement.stronglyDependsOn).forEach(function (name) {
					if (statement.defines[name]) return;

					addDependency(strongDependencies, _this16.locals.lookup(name));
				});
			}
		});

		var weakDependencies = blank();

		this.statements.forEach(function (statement) {
			keys(statement.dependsOn).forEach(function (name) {
				if (statement.defines[name]) return;

				addDependency(weakDependencies, _this16.locals.lookup(name));
			});
		});

		// Go through all our local and exported ids and make us depend on
		// the defining modules as well as
		this.exports.getIds().concat(this.locals.getIds()).forEach(function (id) {
			if (id.module && !id.module.isExternal) {
				weakDependencies[id.module.id] = id.module;
			}

			if (!id.modifierStatements) return;

			id.modifierStatements.forEach(function (statement) {
				var module = statement.module;
				weakDependencies[module.id] = module;
			});
		});

		// `Bundle.sort` gets stuck in an infinite loop if a module has
		// `strongDependencies` to itself. Make sure it doesn't happen.
		delete strongDependencies[this.id];
		delete weakDependencies[this.id];

		return { strongDependencies: strongDependencies, weakDependencies: weakDependencies };
	};

	Module.prototype.getModule = function getModule(source) {
		return this.bundle.moduleById[this.resolvedIds[source]];
	};

	// If a module is marked, enforce dynamic access of its properties.

	Module.prototype.mark = function mark() {
		if (this.needsDynamicAccess) return;
		this.needsDynamicAccess = true;

		this.markAllExports();
	};

	Module.prototype.markAllSideEffects = function markAllSideEffects() {
		this.statements.forEach(function (statement) {
			statement.markSideEffect();
		});
	};

	Module.prototype.markAllStatements = function markAllStatements(isEntryModule) {
		var _this17 = this;

		this.statements.forEach(function (statement) {
			if (statement.isIncluded) return; // TODO can this happen? probably not...

			// skip import declarations...
			if (statement.isImportDeclaration) {
				// ...unless they're empty, in which case assume we're importing them for the side-effects
				// THIS IS NOT FOOLPROOF. Probably need /*rollup: include */ or similar
				if (!statement.node.specifiers.length) {
					var otherModule = _this17.getModule(statement.node.source.value);

					if (!otherModule.isExternal) otherModule.markAllStatements();
				}
			}

			// skip `export { foo, bar, baz }`...
			else if (statement.node.type === 'ExportNamedDeclaration' && statement.node.specifiers.length) {
					// ...but ensure they are defined, if this is the entry module
					if (isEntryModule) statement.mark();
				}

				// include everything else
				else {
						// Be sure to mark the default export for the entry module.
						if (isEntryModule && statement.node.type === 'ExportDefaultDeclaration') {
							_this17.exports.lookup('default').mark();
						}

						statement.mark();
					}
		});
	};

	// Marks all exported identifiers.

	Module.prototype.markAllExports = function markAllExports() {
		this.exports.getIds().forEach(function (id) {
			return id.mark();
		});
	};

	Module.prototype.parse = function parse(ast) {
		var _this18 = this;

		// The ast can be supplied programmatically (but usually won't be)
		if (!ast) {
			// Try to extract a list of top-level statements/declarations. If
			// the parse fails, attach file info and abort
			try {
				ast = acorn.parse(this.source, {
					ecmaVersion: 6,
					sourceType: 'module',
					onComment: function (block, text, start, end) {
						return _this18.comments.push({ block: block, text: text, start: start, end: end });
					}
				});
			} catch (err) {
				err.code = 'PARSE_ERROR';
				err.file = this.id; // see above - not necessarily true, but true enough
				throw err;
			}
		}

		walk(ast, {
			enter: function (node) {
				_this18.magicString.addSourcemapLocation(node.start);
				_this18.magicString.addSourcemapLocation(node.end);
			}
		});

		var statements = [];
		var lastChar = 0;
		var commentIndex = 0;

		ast.body.forEach(function (node) {
			// special case - top-level var declarations with multiple declarators
			// should be split up. Otherwise, we may end up including code we
			// don't need, just because an unwanted declarator is included
			if (node.type === 'VariableDeclaration' && node.declarations.length > 1) {
				// remove the leading var/let/const... UNLESS the previous node
				// was also a synthetic node, in which case it'll get removed anyway
				var lastStatement = statements[statements.length - 1];
				if (!lastStatement || !lastStatement.node.isSynthetic) {
					_this18.magicString.remove(node.start, node.declarations[0].start);
				}

				node.declarations.forEach(function (declarator) {
					var start = declarator.start;
					var end = declarator.end;

					var syntheticNode = {
						type: 'VariableDeclaration',
						kind: node.kind,
						start: start,
						end: end,
						declarations: [declarator],
						isSynthetic: true
					};

					var statement = new Statement(syntheticNode, _this18, start, end);
					statements.push(statement);
				});

				lastChar = node.end; // TODO account for trailing line comment
			} else {
					var comment = undefined;
					do {
						comment = _this18.comments[commentIndex];
						if (!comment) break;
						if (comment.start > node.start) break;
						commentIndex += 1;
					} while (comment.end < lastChar);

					var start = comment ? Math.min(comment.start, node.start) : node.start;
					var end = node.end; // TODO account for trailing line comment

					var statement = new Statement(node, _this18, start, end);
					statements.push(statement);

					lastChar = end;
				}
		});

		statements.forEach(function (statement, i) {
			var nextStatement = statements[i + 1];
			statement.next = nextStatement ? nextStatement.start : statement.end;
		});

		return statements;
	};

	Module.prototype.render = function render(toExport, direct) {
		var _this19 = this;

		var magicString = this.magicString.clone();

		this.statements.forEach(function (statement) {
			if (!statement.isIncluded) {
				magicString.remove(statement.start, statement.next);
				return;
			}

			// skip `export { foo, bar, baz }`
			if (statement.node.type === 'ExportNamedDeclaration') {
				// skip `export { foo, bar, baz }`
				if (statement.node.specifiers.length) {
					magicString.remove(statement.start, statement.next);
					return;
				}

				// skip `export var foo;` if foo is exported
				if (isEmptyExportedVarDeclaration(statement.node.declaration, _this19.exports, toExport)) {
					magicString.remove(statement.start, statement.next);
					return;
				}
			}

			// skip empty var declarations for exported bindings
			// (otherwise we're left with `exports.foo;`, which is useless)
			if (isEmptyExportedVarDeclaration(statement.node, _this19.exports, toExport)) {
				magicString.remove(statement.start, statement.next);
				return;
			}

			// split up/remove var declarations as necessary
			if (statement.node.isSynthetic) {
				// insert `var/let/const` if necessary
				if (!toExport[statement.node.declarations[0].id.name]) {
					magicString.insert(statement.start, statement.node.kind + ' ');
				}

				magicString.overwrite(statement.end, statement.next, ';\n'); // TODO account for trailing newlines
			}

			var replacements = blank();
			var bundleExports = blank();

			// Indirect identifier access.
			if (!direct) {
				keys(statement.dependsOn).forEach(function (name) {
					var id = _this19.locals.lookup(name);

					// We shouldn't create a replacement for `id` if
					//   1. `id` is a Global, in which case it has no module property
					//   2. `id.module` isn't external, which means we have direct access
					//   3. `id` is its own module, in the case of namespace imports
					if (id.module && id.module.isExternal && id.module !== id) {
						replacements[name] = id.originalName === 'default' ?
						// default names are always directly accessed
						id.name :
						// other names are indirectly accessed
						id.module.name + '.' + id.originalName;
					}
				});
			}

			keys(statement.dependsOn).concat(keys(statement.defines)).forEach(function (name) {
				var bundleName = _this19.locals.lookup(name).name;

				if (toExport[bundleName]) {
					bundleExports[name] = replacements[name] = toExport[bundleName];
				} else if (bundleName !== name && !replacements[name]) {
					// TODO weird structure
					replacements[name] = bundleName;
				}
			});

			statement.replaceIdentifiers(magicString, replacements, bundleExports);

			// modify exports as necessary
			if (statement.isExportDeclaration) {
				// remove `export` from `export var foo = 42`
				if (statement.node.type === 'ExportNamedDeclaration' && statement.node.declaration.type === 'VariableDeclaration') {
					magicString.remove(statement.node.start, statement.node.declaration.start);
				} else if (statement.node.type === 'ExportAllDeclaration') {
					// TODO: remove once `export * from 'external'` is supported.
					magicString.remove(statement.start, statement.next);
				}

				// remove `export` from `export class Foo {...}` or `export default Foo`
				// TODO default exports need different treatment
				else if (statement.node.declaration.id) {
						magicString.remove(statement.node.start, statement.node.declaration.start);
					} else if (statement.node.type === 'ExportDefaultDeclaration') {
						var def = _this19.exports.lookup('default');

						// FIXME: dunno what to do here yet.
						if (statement.node.declaration.type === 'Identifier' && def.name === (replacements[statement.node.declaration.name] || statement.node.declaration.name)) {
							magicString.remove(statement.start, statement.next);
							return;
						}

						// prevent `var undefined = sideEffectyDefault(foo)`
						if (!def.isUsed) {
							magicString.remove(statement.start, statement.node.declaration.start);
							return;
						}

						// anonymous functions should be converted into declarations
						if (statement.node.declaration.type === 'FunctionExpression') {
							magicString.overwrite(statement.node.start, statement.node.declaration.start + 8, 'function ' + def.name);
						} else {
							magicString.overwrite(statement.node.start, statement.node.declaration.start, 'var ' + def.name + ' = ');
						}
					} else {
						throw new Error('Unhandled export');
					}
			}
		});

		return magicString.trim();
	};

	return Module;
})();

var Identifier = (function () {
	function Identifier(name) {
		_classCallCheck(this, Identifier);

		this.originalName = this.name = name;
	}

	// A reference to an `Identifier`.

	Identifier.prototype.mark = function mark() {
		// noop
	};

	return Identifier;
})();

function Reference(scope, index) {
	this.scope = scope;
	this.index = index;
}

// Dereferences a `Reference`.
function dereference(ref) {
	return ref.scope.ids[ref.index];
}

function isntReference(id) {
	return !(id instanceof Reference);
}

// Prefix the argument with '_'.
function underscorePrefix(x) {
	return '_' + x;
}

// ## Scope
// A Scope is a mapping from string names to `Identifiers`.

var Scope = (function () {
	function Scope(parent) {
		_classCallCheck(this, Scope);

		this.ids = [];
		this.names = blank();

		this.parent = parent || null;
		this.used = blank();
	}

	// Binds the `name` to the given reference `ref`.

	Scope.prototype.bind = function bind(name, ref) {
		this.ids[this.index(name)] = ref;
	};

	// Deconflict all names within the scope,
	// using the given renaming function.
	// If no function is supplied, `underscorePrefix` is used.

	Scope.prototype.deconflict = function deconflict() {
		var _this20 = this;

		var rename = arguments.length <= 0 || arguments[0] === undefined ? underscorePrefix : arguments[0];

		var names = this.used;

		this.ids.filter(function (ref) {
			return ref instanceof Reference;
		}).forEach(function (ref) {
			// Same scope.
			if (ref.scope.ids === _this20.ids) return;

			// Another scope!
			while (ref instanceof Reference) {
				ref = dereference(ref);
			}

			names[ref.name] = ref;
		});

		this.ids.filter(isntReference).forEach(function (id) {
			if (typeof id === 'string') {
				throw new Error('Required name "' + id + '" is undefined!');
			}

			var name = id.name;

			while (name in names && names[name] !== id) {
				name = rename(name);
			}
			names[name] = id;

			id.name = name;
		});
	};

	// Defines `name` in the scope to be `id`.
	// If no `id` is supplied, a plain `Identifier` is created.

	Scope.prototype.define = function define(name, id) {
		this.ids[this.index(name)] = id || new Identifier(name);
	};

	// TODO: rename! Too similar to `define`.

	Scope.prototype.defines = function defines(name) {
		return name in this.names;
	};

	// Return the names referenced to in the scope.

	Scope.prototype.getNames = function getNames() {
		return keys(this.names);
	};

	// *private, don't use*
	//
	// Return `name`'s index in the `ids` array if it exists,
	// otherwise returns the index to a new placeholder slot.

	Scope.prototype.index = function index(name) {
		if (!(name in this.names)) {
			return this.names[name] = this.ids.push(name) - 1;
		}

		return this.names[name];
	};

	// Returns true if `name` is in Scope.

	Scope.prototype.inScope = function inScope(name) {
		if (name in this.names) return true;

		return this.parent ? this.parent.inScope(name) : false;
	};

	// Returns a list of `[ name, identifier ]` tuples.

	Scope.prototype.getIds = function getIds() {
		var _this21 = this;

		return keys(this.names).map(function (name) {
			return _this21.lookup(name);
		});
	};

	// Lookup the identifier referred to by `name`.

	Scope.prototype.lookup = function lookup(name) {
		if (!(name in this.names) && this.parent) {
			return this.parent.lookup(name);
		}

		var id = this.ids[this.names[name]];

		while (id instanceof Reference) {
			id = dereference(id);
		}

		return id;
	};

	// Get a reference to the identifier `name` in this scope.

	Scope.prototype.reference = function reference(name) {
		return new Reference(this, this.index(name));
	};

	// Return the used names of the scope.
	// Names aren't considered used unless they're deconflicted.

	Scope.prototype.usedNames = function usedNames() {
		return keys(this.used).sort();
	};

	// Create and return a virtual `Scope` instance, bound to
	// the actual scope of `this`, optionally inherit the parent scope.

	Scope.prototype.virtual = function virtual(inheritParent) {
		var scope = new Scope(inheritParent ? this.parent : null);
		scope.ids = this.ids;
		return scope;
	};

	return Scope;
})();

function ensureArray(thing) {
	if (Array.isArray(thing)) return thing;
	if (thing == undefined) return [];
	return [thing];
}

function dirExists(dir) {
	try {
		sander.readdirSync(dir);
		return true;
	} catch (err) {
		return false;
	}
}

function defaultResolver(importee, importer, options) {
	// absolute paths are left untouched
	if (isAbsolute(importee)) return importee;

	// if this is the entry point, resolve against cwd
	if (importer === undefined) return resolve(process.cwd(), importee);

	// we try to resolve external modules
	if (importee[0] !== '.') {
		var _importee$split = importee.split(/[\/\\]/);

		var id = _importee$split[0];

		// unless we want to keep it external, that is
		if (~options.external.indexOf(id)) return null;

		return options.resolveExternal(importee, importer, options);
	}

	return resolve(dirname(importer), importee).replace(/\.js$/, '') + '.js';
}

function defaultExternalResolver(id, importer) {
	// for now, only node_modules is supported, and only jsnext:main
	var root = absolutePath.exec(importer)[0];
	var dir = dirname(importer);

	// `foo` should use jsnext:main, but `foo/src/bar` shouldn't
	var parts = id.split(/[\/\\]/);

	while (dir !== root && dir !== '.') {
		var modulePath = resolve(dir, 'node_modules', parts[0]);

		if (dirExists(modulePath)) {
			// `foo/src/bar`
			if (parts.length > 1) {
				return resolve.apply(undefined, [modulePath].concat(_toConsumableArray(parts.slice(1)))).replace(/\.js$/, '') + '.js';
			}

			// `foo`
			var pkgPath = resolve(modulePath, 'package.json');
			var pkg = undefined;

			try {
				pkg = JSON.parse(sander.readFileSync(pkgPath).toString());
			} catch (err) {
				throw new Error('Missing or malformed package.json: ' + modulePath);
			}

			var main = pkg['jsnext:main'];

			if (!main) {
				throw new Error('Package ' + id + ' (imported by ' + importer + ') does not have a jsnext:main field, and so cannot be included in your rollup. Try adding it as an external module instead (e.g. options.external = [\'' + id + '\']). See https://github.com/rollup/rollup/wiki/jsnext:main for more info');
			}

			return resolve(dirname(pkgPath), main).replace(/\.js$/, '') + '.js';
		}

		dir = dirname(dir);
	}

	throw new Error('Could not find package ' + id + ' (required by ' + importer + ')');
}

function defaultLoader(id, options) {
	// TODO support plugins e.g. !css and !json?
	var source = sander.readFileSync(id, { encoding: 'utf-8' });

	return options.transform.reduce(function (source, transformer) {
		return transformer(source, id);
	}, source);
}

var _Bundle = (function () {
	function _Bundle(options) {
		var _this22 = this;

		_classCallCheck(this, _Bundle);

		this.entry = options.entry;
		this.entryModule = null;

		this.resolveId = options.resolveId || defaultResolver;
		this.load = options.load || defaultLoader;

		this.resolveOptions = {
			external: ensureArray(options.external),
			resolveExternal: options.resolveExternal || defaultExternalResolver
		};

		this.loadOptions = {
			transform: ensureArray(options.transform)
		};

		// The global scope, and the bundle's internal scope.
		this.globals = new Scope();
		this.scope = new Scope(this.globals);

		// Strictly speaking, these globals only apply to non-ES6, non-default-only bundles.
		// However, the deconfliction logic is greatly simplified by being the same for all formats.
		// * CommonJS needs `module` and `exports` ( and `require`? ) to be in scope.
		// * SystemJS needs a reference to a function for its `exports`,
		//   and another one for any `module` it imports. These global names can be reused!
		['exports', 'module'].forEach(function (name) {
			_this22.globals.define(name);
			_this22.scope.bind(name, _this22.globals.reference(name));
		});

		// Alias for entryModule.exports.
		this.exports = null;

		this.toExport = null;

		this.pending = blank();
		this.moduleById = blank();
		this.modules = [];

		this.statements = null;
		this.externalModules = [];
	}

	_Bundle.prototype.build = function build() {
		var _this23 = this;

		return sander.Promise.resolve(this.resolveId(this.entry, undefined, this.resolveOptions)).then(function (id) {
			return _this23.fetchModule(id);
		}).then(function (entryModule) {
			_this23.entryModule = entryModule;
			_this23.exports = entryModule.exports;

			entryModule.markAllStatements(true);
			entryModule.markAllExports();

			// Include all side-effects
			_this23.modules.forEach(function (module) {
				module.markAllSideEffects();
			});

			// Sort the modules.
			_this23.orderedModules = _this23.sort();

			// As a last step, deconflict all identifier names, once.
			_this23.scope.deconflict();

			// Alias the default import to the external module named
			// for external modules that don't need named imports.
			_this23.externalModules.forEach(function (module) {
				var externalDefault = module.exports.lookup('default');

				if (externalDefault && !(module.needsNamed || module.needsAll)) {
					externalDefault.name = module.name;
				}
			});
		});
	};

	_Bundle.prototype.fetchModule = function fetchModule(id) {
		var _this24 = this;

		// short-circuit cycles
		if (this.pending[id]) return null;
		this.pending[id] = true;

		return sander.Promise.resolve(this.load(id, this.loadOptions)).then(function (source) {
			var ast = undefined;

			if (typeof source === 'object') {
				ast = source.ast;
				source = source.code;
			}

			var module = new Module({
				id: id,
				source: source,
				ast: ast,
				bundle: _this24
			});

			_this24.modules.push(module);
			_this24.moduleById[id] = module;

			return _this24.fetchAllDependencies(module).then(function () {
				// Analyze the module once all its dependencies have been resolved.
				// This means that any dependencies of a module has already been
				// analysed when it's time for the module itself.
				module.analyse();
				return module;
			});
		});
	};

	_Bundle.prototype.fetchAllDependencies = function fetchAllDependencies(module) {
		var _this25 = this;

		var promises = module.dependencies.map(function (source) {
			return sander.Promise.resolve(_this25.resolveId(source, module.id, _this25.resolveOptions)).then(function (resolvedId) {
				module.resolvedIds[source] = resolvedId || source;

				// external module
				if (!resolvedId) {
					if (!_this25.moduleById[source]) {
						var _module4 = new ExternalModule({ id: source, bundle: _this25 });
						_this25.externalModules.push(_module4);
						_this25.moduleById[source] = _module4;
					}
				} else if (resolvedId === module.id) {
					throw new Error('A module cannot import itself (' + resolvedId + ')');
				} else {
					return _this25.fetchModule(resolvedId);
				}
			});
		});

		return sander.Promise.all(promises);
	};

	_Bundle.prototype.render = function render() {
		var _this26 = this;

		var options = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];

		var format = options.format || 'es6';

		// Determine export mode - 'default', 'named', 'none'
		var exportMode = getExportMode(this, options.exports);

		// If we have named exports from the bundle, and those exports
		// are assigned to *within* the bundle, we may need to rewrite e.g.
		//
		//   export let count = 0;
		//   export function incr () { count++ }
		//
		// might become...
		//
		//   exports.count = 0;
		//   function incr () {
		//     exports.count += 1;
		//   }
		//   exports.incr = incr;
		//
		// This doesn't apply if the bundle is exported as ES6!
		var allBundleExports = blank();
		var isReassignedVarDeclaration = blank();
		var varExports = blank();
		var getterExports = [];

		this.orderedModules.forEach(function (module) {
			module.reassignments.forEach(function (name) {
				isReassignedVarDeclaration[module.locals.lookup(name).name] = true;
			});
		});

		if (format !== 'es6' && exportMode === 'named') {
			this.exports.getNames().forEach(function (name) {
				var canonicalName = _this26.exports.lookup(name).name;

				if (isReassignedVarDeclaration[canonicalName]) {
					varExports[name] = true;

					// if the same binding is exported multiple ways, we need to
					// use getters to keep all exports in sync
					if (allBundleExports[canonicalName]) {
						getterExports.push({ key: name, value: allBundleExports[canonicalName] });
					} else {
						allBundleExports[canonicalName] = 'exports.' + name;
					}
				}
			});
		}

		// since we're rewriting variable exports, we want to
		// ensure we don't try and export them again at the bottom
		this.toExport = this.exports.getNames().filter(function (key) {
			return !varExports[key];
		});

		var magicString = new MagicString.Bundle({ separator: '\n\n' });

		this.orderedModules.forEach(function (module) {
			var source = module.render(allBundleExports, format === 'es6');
			if (source.toString().length) {
				magicString.addSource(source);
			}
		});

		// prepend bundle with internal namespaces
		var indentString = getIndentString(magicString, options);

		var namespaceBlock = this.modules.filter(function (module) {
			return module.needsDynamicAccess;
		}).map(function (module) {
			var exports = module.exports.getNames().map(function (name) {
				var id = module.exports.lookup(name);
				return indentString + 'get ' + name + ' () { return ' + id.name + '; }';
			});

			return 'var ' + module.name + ' = {\n' + exports.join(',\n') + '\n};\n\n';
		}).join('');

		magicString.prepend(namespaceBlock);

		if (getterExports.length) {
			// TODO offer ES3-safe (but not spec-compliant) alternative?
			var getterExportsBlock = 'Object.defineProperties(exports, {\n' + getterExports.map(function (_ref9) {
				var key = _ref9.key;
				var value = _ref9.value;
				return indentString + (key + ': { get: function () { return ' + value + '; } }');
			}).join(',\n') + '\n});';

			magicString.append('\n\n' + getterExportsBlock);
		}

		var finalise = _index[format];

		if (!finalise) {
			throw new Error('You must specify an output type - valid options are ' + keys(_index).join(', '));
		}

		magicString = finalise(this, magicString.trim(), { exportMode: exportMode, indentString: indentString }, options);

		if (options.banner) magicString.prepend(options.banner + '\n');
		if (options.footer) magicString.append('\n' + options.footer);

		var code = magicString.toString();
		var map = null;

		if (options.sourceMap) {
			var file = options.sourceMapFile || options.dest;
			map = magicString.generateMap({
				includeContent: true,
				file: file
				// TODO
			});

			map.sources = map.sources.map(unixizePath);
		}

		return { code: code, map: map };
	};

	_Bundle.prototype.sort = function sort() {
		// Set of visited module ids.
		var seen = blank();

		var ordered = [];
		var hasCycles = undefined;

		// Map from module id to list of modules.
		var strongDeps = blank();

		// Map from module id to boolean.
		var stronglyDependsOn = blank();

		function visit(module) {
			seen[module.id] = true;

			var _module$consolidateDependencies = module.consolidateDependencies();

			var strongDependencies = _module$consolidateDependencies.strongDependencies;
			var weakDependencies = _module$consolidateDependencies.weakDependencies;

			strongDeps[module.id] = [];
			stronglyDependsOn[module.id] = {};

			keys(strongDependencies).forEach(function (id) {
				var imported = strongDependencies[id];

				strongDeps[module.id].push(imported);

				if (seen[id]) {
					// we need to prevent an infinite loop, and note that
					// we need to check for strong/weak dependency relationships
					hasCycles = true;
					return;
				}

				visit(imported);
			});

			keys(weakDependencies).forEach(function (id) {
				var imported = weakDependencies[id];

				if (seen[id]) {
					// we need to prevent an infinite loop, and note that
					// we need to check for strong/weak dependency relationships
					hasCycles = true;
					return;
				}

				visit(imported);
			});

			// add second (and third...) order dependencies
			function addStrongDependencies(dependency) {
				if (stronglyDependsOn[module.id][dependency.id]) return;

				stronglyDependsOn[module.id][dependency.id] = true;
				strongDeps[dependency.id].forEach(addStrongDependencies);
			}

			strongDeps[module.id].forEach(addStrongDependencies);

			ordered.push(module);
		}

		visit(this.entryModule);

		if (hasCycles) {
			var unordered = ordered;
			ordered = [];

			// unordered is actually semi-ordered, as [ fewer dependencies ... more dependencies ]
			unordered.forEach(function (module) {
				// ensure strong dependencies of `module` that don't strongly depend on `module` go first
				strongDeps[module.id].forEach(place);

				function place(dep) {
					if (!stronglyDependsOn[dep.id][module.id] && ! ~ordered.indexOf(dep)) {
						strongDeps[dep.id].forEach(place);
						ordered.push(dep);
					}
				}

				if (! ~ordered.indexOf(module)) {
					ordered.push(module);
				}
			});
		}

		return ordered;
	};

	return _Bundle;
})();

function rollup(options) {
	if (!options || !options.entry) {
		throw new Error('You must supply options.entry to rollup');
	}

	var bundle = new _Bundle(options);

	return bundle.build().then(function () {
		return {
			imports: bundle.externalModules.map(function (module) {
				return module.id;
			}),
			exports: keys(bundle.entryModule.exports),
			modules: bundle.orderedModules.map(function (module) {
				return { id: module.id };
			}),

			generate: function (options) {
				return bundle.render(options);
			},
			write: function (options) {
				if (!options || !options.dest) {
					throw new Error('You must supply options.dest to bundle.write');
				}

				var dest = options.dest;

				var _bundle$render = bundle.render(options);

				var code = _bundle$render.code;
				var map = _bundle$render.map;

				var promises = [];

				if (options.sourceMap) {
					var url = undefined;

					if (options.sourceMap === 'inline') {
						url = map.toUrl();
					} else {
						url = basename(dest) + '.map';
						promises.push(sander.writeFile(dest + '.map', map.toString()));
					}

					code += '\n//# ' + SOURCEMAPPING_URL + '=' + url;
				}

				promises.push(sander.writeFile(dest, code));
				return Promise.all(promises);
			}
		};
	});
}

exports.rollup = rollup;
//# sourceMappingURL=rollup.js.map
